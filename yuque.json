[
  {
    "id": 1330085,
    "slug": "airbnb",
    "title": "Airbnb JavaScript 代码规范",
    "book_id": 223480,
    "book": {
      "id": 223480,
      "type": "Book",
      "slug": "lch",
      "name": "Lite Code House",
      "user_id": 273716,
      "description": "share mark",
      "creator_id": 273716,
      "public": 1,
      "items_count": 6,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-05T14:56:11.170Z",
      "updated_at": "2019-03-05T14:56:11.000Z",
      "created_at": "2019-02-23T14:05:16.000Z",
      "namespace": "maclejean/lch",
      "user": {
        "id": 273716,
        "type": "User",
        "login": "maclejean",
        "name": "张杰",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2019-02-23T08:29:39.000Z",
        "updated_at": "2019-02-26T02:38:41.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 273716,
    "creator": {
      "id": 273716,
      "type": "User",
      "login": "maclejean",
      "name": "张杰",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2019-02-23T08:29:39.000Z",
      "updated_at": "2019-02-26T02:38:41.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "转自 https://github.com/BingKui/javascript-zh\n\n_一种写JavaScript更合理的代码风格。_\n\n> **Note**: 本指南假设你使用了 [Babel](https://babeljs.io), 并且要求你使用 [babel-preset-airbnb](https://npmjs.com/babel-preset-airbnb) 或者其他同等资源。 并且假设你在你的应用中安装了 shims/polyfills ，使用[airbnb-browser-shims](https://npmjs.com/airbnb-browser-shims) 或者相同功能。\n\n其他代码风格指南\n\n* [ES5 (Deprecated)](https://github.com/airbnb/javascript/tree/es5-deprecated/es5)\n* [React](react/)\n* [CSS-in-JavaScript](css-in-javascript/)\n* [CSS & Sass](https://github.com/airbnb/css)\n* [Ruby](https://github.com/airbnb/ruby)\n\n<a name=\"767fa455\"></a>\n## [目录]()\n\n1. [类型](#types)\n1. [引用](#references)\n1. [对象](#objects)\n1. [数组](#arrays)\n1. [解构](#destructuring)\n1. [字符](#strings)\n1. [方法](#functions)\n1. [箭头函数](#arrow-functions)\n1. [类和构造器](#classes--constructors)\n1. [模块](#modules)\n1. [迭代器和发生器](#iterators-and-generators)\n1. [属性](#properties)\n1. [变量](#variables)\n1. [提升](#hoisting)\n1. [比较运算符和等号](#comparison-operators--equality)\n1. [块](#blocks)\n1. [控制语句](#control-statements)\n1. [注释](#comments)\n1. [空白](#whitespace)\n1. [逗号](#commas)\n1. [分号](#semicolons)\n1. [类型转换和强制类型转换](#type-casting--coercion)\n1. [命名规范](#naming-conventions)\n1. [存取器](#accessors)\n1. [事件](#events)\n1. [jQuery](#jquery)\n1. [ECMAScript 5 兼容性](#ecmascript-5-compatibility)\n1. [ECMAScript 6+ (ES 2015+) 风格](#ecmascript-6-es-2015-styles)\n1. [标准库](#standard-library)\n1. [测试](#testing)\n1. [性能](#performance)\n1. [资源](#resources)\n1. [JavaScript风格指南的指南](#the-javascript-style-guide-guide)\n1. [许可证](#license)\n1. [修正案](#amendments)\n\n<a name=\"226b0912\"></a>\n## [类型]()\n\n\n* [1.1](#types--primitives) **原始值**: 当你访问一个原始类型的时候，你可以直接使用它的值。\n  * `string`\n  * `number`\n  * `boolean`\n  * `null`\n  * `undefined`\n  * `symbol`\n```javascript\nconst foo = 1;\nlet bar = foo;\n\nbar = 9;\n\nconsole.log(foo, bar); // => 1, 9\n```\n  * 标识符不能完全被支持，因此在针对不支持的浏览器或者环境时不应该使用它们。\n\n\n* [1.2](#types--complex)  **复杂类型**: 当你访问一个复杂类型的时候，你需要一个值得引用。\n  * `object`\n  * `array`\n  * `function`\n```javascript\nconst foo = [1, 2];\nconst bar = foo;\n\nbar[0] = 9;\n\nconsole.log(foo[0], bar[0]); // => 9, 9\n```\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"3b61c966\"></a>\n## [引用]()\n\n\n* [2.1](#references--prefer-const) 使用 `const` 定义你的所有引用；避免使用 `var`。 eslint: [`prefer-const`](https://eslint.org/docs/rules/prefer-const.html), [`no-const-assign`](https://eslint.org/docs/rules/no-const-assign.html)\n> 为什么? 这样能够确保你不能重新赋值你的引用，否则可能导致错误或者产生难以理解的代码。.\n\n```javascript\n// bad\nvar a = 1;\nvar b = 2;\n\n// good\nconst a = 1;\nconst b = 2;\n```\n\n\n\n* [2.2](#references--disallow-var) 如果你必须重新赋值你的引用， 使用 `let` 代替 `var`。 eslint: [`no-var`](https://eslint.org/docs/rules/no-var.html)\n> 为什么? `let` 是块级作用域，而不像 `var` 是函数作用域.\n\n```javascript\n// bad\nvar count = 1;\nif (true) {\n  count += 1;\n}\n\n// good, use the let.\nlet count = 1;\nif (true) {\n  count += 1;\n}\n```\n\n\n\n* [2.3](#references--block-scope) 注意，let 和 const 都是块级范围的。\n```javascript\n// const 和 let 只存在于他们定义的块中。\n{\n  let a = 1;\n  const b = 1;\n}\nconsole.log(a); // ReferenceError\nconsole.log(b); // ReferenceError\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"b1449413\"></a>\n## [对象]()\n\n\n* [3.1](#objects--no-new) 使用字面语法来创建对象。 eslint: [`no-new-object`](https://eslint.org/docs/rules/no-new-object.html)\n```javascript\n// bad\nconst item = new Object();\n\n// good\nconst item = {};\n```\n\n\n\n* [3.2](#es6-computed-properties) 在创建具有动态属性名称的对象时使用计算属性名。\n> 为什么? 它允许你在一个地方定义对象的所有属性。\n\n```javascript\nfunction getKey(k) {\n  return `a key named ${k}`;\n}\n\n// bad\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n  [getKey('enabled')]: true,\n};\n```\n\n\n\n* [3.3](#es6-object-shorthand) 使用对象方法的缩写。 eslint: [`object-shorthand`](https://eslint.org/docs/rules/object-shorthand.html)\n```javascript\n// bad\nconst atom = {\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};\n```\n\n\n\n* [3.4](#es6-object-concise) 使用属性值的缩写。 eslint: [`object-shorthand`](https://eslint.org/docs/rules/object-shorthand.html)\n> 为什么? 它的写法和描述较短。\n\n```javascript\nconst lukeSkywalker = 'Luke Skywalker';\n\n// bad\nconst obj = {\n  lukeSkywalker: lukeSkywalker,\n};\n\n// good\nconst obj = {\n  lukeSkywalker,\n};\n```\n\n\n\n* [3.5](#objects--grouped-shorthand) 在对象声明的时候将简写的属性进行分组。\n> 为什么? 这样更容易的判断哪些属性使用的简写。\n\n```javascript\nconst anakinSkywalker = 'Anakin Skywalker';\nconst lukeSkywalker = 'Luke Skywalker';\n\n// bad\nconst obj = {\n  episodeOne: 1,\n  twoJediWalkIntoACantina: 2,\n  lukeSkywalker,\n  episodeThree: 3,\n  mayTheFourth: 4,\n  anakinSkywalker,\n};\n\n// good\nconst obj = {\n  lukeSkywalker,\n  anakinSkywalker,\n  episodeOne: 1,\n  twoJediWalkIntoACantina: 2,\n  episodeThree: 3,\n  mayTheFourth: 4,\n};\n```\n\n\n\n* [3.6](#objects--quoted-props) 只使用引号标注无效标识符的属性。 eslint: [`quote-props`](https://eslint.org/docs/rules/quote-props.html)\n> 为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。\n\n```javascript\n// bad\nconst bad = {\n  'foo': 3,\n  'bar': 4,\n  'data-blah': 5,\n};\n\n// good\nconst good = {\n  foo: 3,\n  bar: 4,\n  'data-blah': 5,\n};\n```\n\n\n\n* [3.7](#objects--prototype-builtins) 不能直接调用 `Object.prototype` 的方法，如： `hasOwnProperty` 、 `propertyIsEnumerable` 和 `isPrototypeOf`。\n> 为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 `{ hasOwnProperty: false }` - 或者，对象是一个空对象 (`Object.create(null)`)。\n\n```javascript\n// bad\nconsole.log(object.hasOwnProperty(key));\n\n// good\nconsole.log(Object.prototype.hasOwnProperty.call(object, key));\n\n// best\nconst has = Object.prototype.hasOwnProperty; // 在模块范围内的缓存中查找一次\n/* or */\nimport has from 'has'; // https://www.npmjs.com/package/has\n// ...\nconsole.log(has.call(object, key));\n```\n\n\n\n* [3.8](#objects--rest-spread) 更喜欢对象扩展操作符，而不是用 [`Object.assign`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。\n```javascript\n// very bad\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign(original, { c: 3 }); // 变异的 `original` ಠ_ಠ\ndelete copy.a; // 这....\n\n// bad\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign({}, original, { c: 3 }); // copy => { a: 1, b: 2, c: 3 }\n\n// good\nconst original = { a: 1, b: 2 };\nconst copy = { ...original, c: 3 }; // copy => { a: 1, b: 2, c: 3 }\n\nconst { a, ...noA } = copy; // noA => { b: 2, c: 3 }\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"0e67d4b0\"></a>\n## [数组]()\n\n\n* [4.1](#arrays--literals) 使用字面语法创建数组。 eslint: [`no-array-constructor`](https://eslint.org/docs/rules/no-array-constructor.html)\n```javascript\n// bad\nconst items = new Array();\n\n// good\nconst items = [];\n```\n\n\n\n* [4.2](#arrays--push) 使用 [Array#push](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push) 取代直接赋值来给数组添加项。\n```javascript\nconst someStack = [];\n\n// bad\nsomeStack[someStack.length] = 'abracadabra';\n\n// good\nsomeStack.push('abracadabra');\n```\n\n\n\n* [4.3](#es6-array-spreads) 使用数组展开方法 `...` 来拷贝数组。\n```javascript\n// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i < len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];\n```\n\n\n\n* [4.4](#arrays--from) 将一个类数组对象转换成一个数组， 使用展开方法 `...` 代替 [`Array.from`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from)。\n```javascript\nconst foo = document.querySelectorAll('.foo');\n\n// good\nconst nodes = Array.from(foo);\n\n// best\nconst nodes = [...foo];\n```\n\n\n\n* [4.5](#arrays--mapping) 对于对迭代器的映射，使用 [Array.from](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 替代展开方法 `...` ， 因为它避免了创建中间数组。\n```javascript\n// bad\nconst baz = [...foo].map(bar);\n\n// good\nconst baz = Array.from(foo, bar);\n```\n\n\n\n* [4.6](#arrays--callback-return) 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 [8.2](#arrows--implicit-return)。 eslint: [`array-callback-return`](https://eslint.org/docs/rules/array-callback-return)\n```javascript\n// good\n[1, 2, 3].map((x) => {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map(x => x + 1);\n\n// bad - 没有返回值，意味着在第一次迭代后 `acc` 没有被定义\n[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) => {\n  const flatten = acc.concat(item);\n  acc[index] = flatten;\n});\n\n// good\n[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) => {\n  const flatten = acc.concat(item);\n  acc[index] = flatten;\n  return flatten;\n});\n\n// bad\ninbox.filter((msg) => {\n  const { subject, author } = msg;\n  if (subject === 'Mockingbird') {\n    return author === 'Harper Lee';\n  } else {\n    return false;\n  }\n});\n\n// good\ninbox.filter((msg) => {\n  const { subject, author } = msg;\n  if (subject === 'Mockingbird') {\n    return author === 'Harper Lee';\n  }\n\n  return false;\n});\n```\n\n\n\n* [4.7](#arrays--bracket-newline) 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。\n```javascript\n// bad\nconst arr = [\n  [0, 1], [2, 3], [4, 5],\n];\n\nconst objectInArray = [{\n  id: 1,\n}, {\n  id: 2,\n}];\n\nconst numberInArray = [\n  1, 2,\n];\n\n// good\nconst arr = [[0, 1], [2, 3], [4, 5]];\n\nconst objectInArray = [\n  {\n    id: 1,\n  },\n  {\n    id: 2,\n  },\n];\n\nconst numberInArray = [\n  1,\n  2,\n];\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"2be143d5\"></a>\n## [解构]()\n\n\n* [5.1](#destructuring--object) 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: [`prefer-destructuring`](https://eslint.org/docs/rules/prefer-destructuring)\n> 为什么? 解构可以避免为这些属性创建临时引用。\n\n```javascript\n// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n\n  return `${firstName} ${lastName}`;\n}\n\n// good\nfunction getFullName(user) {\n  const { firstName, lastName } = user;\n  return `${firstName} ${lastName}`;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}\n```\n\n\n\n* [5.2](#destructuring--array) 使用数组解构。 eslint: [`prefer-destructuring`](https://eslint.org/docs/rules/prefer-destructuring)\n```javascript\nconst arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;\n```\n\n\n\n* [5.3](#destructuring--object-over-array) 对于多个返回值使用对象解构，而不是数组解构。\n> 为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。\n\n```javascript\n// bad\nfunction processInput(input) {\n  // 处理代码...\n  return [left, right, top, bottom];\n}\n\n// 调用者需要考虑返回数据的顺序。\nconst [left, __, top] = processInput(input);\n\n// good\nfunction processInput(input) {\n  // 处理代码...\n  return { left, right, top, bottom };\n}\n\n// 调用者只选择他们需要的数据。\nconst { left, top } = processInput(input);\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"9c07532d\"></a>\n## [字符]()\n\n\n* [6.1](#strings--quotes) 使用单引号 `''` 定义字符串。 eslint: [`quotes`](https://eslint.org/docs/rules/quotes.html)\n```javascript\n// bad\nconst name = \"Capt. Janeway\";\n\n// bad - 模板文字应该包含插值或换行。\nconst name = `Capt. Janeway`;\n\n// good\nconst name = 'Capt. Janeway';\n```\n\n\n\n* [6.2](#strings--line-length) 使行超过100个字符的字符串不应使用字符串连接跨多行写入。\n> 为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。\n\n```javascript\n// bad\nconst errorMessage = 'This is a super long error that was thrown because \\\nof Batman. When you stop to think about how Batman had anything to do \\\nwith this, you would get nowhere \\\nfast.';\n\n// bad\nconst errorMessage = 'This is a super long error that was thrown because ' +\n  'of Batman. When you stop to think about how Batman had anything to do ' +\n  'with this, you would get nowhere fast.';\n\n// good\nconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';\n```\n\n\n\n* [6.3](#es6-template-literals) 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: [`prefer-template`](https://eslint.org/docs/rules/prefer-template.html) [`template-curly-spacing`](https://eslint.org/docs/rules/template-curly-spacing)\n> 为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。\n\n```javascript\n// bad\nfunction sayHi(name) {\n  return 'How are you, ' + name + '?';\n}\n\n// bad\nfunction sayHi(name) {\n  return ['How are you, ', name, '?'].join();\n}\n\n// bad\nfunction sayHi(name) {\n  return `How are you, ${ name }?`;\n}\n\n// good\nfunction sayHi(name) {\n  return `How are you, ${name}?`;\n}\n```\n\n\n\n* [6.4](#strings--eval) 不要在字符串上使用 `eval()` ，它打开了太多漏洞。 eslint: [`no-eval`](https://eslint.org/docs/rules/no-eval)\n\n\n* [6.5](#strings--escaping) 不要转义字符串中不必要的字符。 eslint: [`no-useless-escape`](https://eslint.org/docs/rules/no-useless-escape)\n> 为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。\n\n```javascript\n// bad\nconst foo = '\\'this\\' \\i\\s \\\"quoted\\\"';\n\n// good\nconst foo = '\\'this\\' is \"quoted\"';\nconst foo = `my name is '${name}'`;\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"ea340b9d\"></a>\n## [方法]()\n\n\n* [7.1](#functions--declarations) 使用命名的函数表达式代替函数声明。 eslint: [`func-style`](https://eslint.org/docs/rules/func-style)\n> 为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 ([Discussion](https://github.com/airbnb/javascript/issues/794))\n\n```javascript\n// bad\nfunction foo() {\n  // ...\n}\n\n// bad\nconst foo = function () {\n  // ...\n};\n\n// good\n// 从变量引用调用中区分的词汇名称\nconst short = function longUniqueMoreDescriptiveLexicalFoo() {\n  // ...\n};\n```\n\n\n\n* [7.2](#functions--iife) Wrap立即调用函数表达式。 eslint: [`wrap-iife`](https://eslint.org/docs/rules/wrap-iife.html)\n> 为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。\n\n```javascript\n// immediately-invoked function expression (IIFE) 立即调用的函数表达式\n(function () {\n  console.log('Welcome to the Internet. Please follow me.');\n}());\n```\n\n\n\n* [7.3](#functions--in-blocks) 切记不要在非功能块中声明函数 (`if`, `while`, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: [`no-loop-func`](https://eslint.org/docs/rules/no-loop-func.html)\n\n\n* [7.4](#functions--note-on-blocks) **注意:** ECMA-262 将 `block` 定义为语句列表。 函数声明不是语句。\n```javascript\n// bad\nif (currentUser) {\n  function test() {\n    console.log('Nope.');\n  }\n}\n\n// good\nlet test;\nif (currentUser) {\n  test = () => {\n    console.log('Yup.');\n  };\n}\n```\n\n\n\n* [7.5](#functions--arguments-shadow) 永远不要定义一个参数为 `arguments`。 这将会优先于每个函数给定范围的 `arguments` 对象。\n```javascript\n// bad\nfunction foo(name, options, arguments) {\n  // ...\n}\n\n// good\nfunction foo(name, options, args) {\n  // ...\n}\n```\n\n\n\n* [7.6](#es6-rest) 不要使用 `arguments`, 选择使用 rest 语法 `...` 代替。 eslint: [`prefer-rest-params`](https://eslint.org/docs/rules/prefer-rest-params)\n> 为什么? `...` 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 `arguments` 。\n\n```javascript\n// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}\n```\n\n\n\n* [7.7](#es6-default-parameters) 使用默认的参数语法，而不是改变函数参数。\n```javascript\n// really bad\nfunction handleThings(opts) {\n  // No! We shouldn’t mutate function arguments.\n  // Double bad: if opts is falsy it'll be set to an object which may\n  // be what you want but it can introduce subtle bugs.\n  opts = opts || {};\n  // ...\n}\n\n// still bad\nfunction handleThings(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // ...\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}\n```\n\n\n\n* [7.8](#functions--default-side-effects) 避免使用默认参数的副作用。\n> 为什么? 他们很容易混淆。\n\n```javascript\nvar b = 1;\n// bad\nfunction count(a = b++) {\n  console.log(a);\n}\ncount();  // 1\ncount();  // 2\ncount(3); // 3\ncount();  // 3\n```\n\n\n\n* [7.9](#functions--defaults-last) 总是把默认参数放在最后。\n```javascript\n// bad\nfunction handleThings(opts = {}, name) {\n  // ...\n}\n\n// good\nfunction handleThings(name, opts = {}) {\n  // ...\n}\n```\n\n\n\n* [7.10](#functions--constructor) 永远不要使用函数构造器来创建一个新函数。 eslint: [`no-new-func`](https://eslint.org/docs/rules/no-new-func)\n> 为什么? 以这种方式创建一个函数将对一个类似于 `eval()` 的字符串进行计算，这将打开漏洞。\n\n```javascript\n// bad\nvar add = new Function('a', 'b', 'return a + b');\n\n// still bad\nvar subtract = Function('a', 'b', 'return a - b');\n```\n\n\n\n* [7.11](#functions--signature-spacing) 函数签名中的间距。 eslint: [`space-before-function-paren`](https://eslint.org/docs/rules/space-before-function-paren) [`space-before-blocks`](https://eslint.org/docs/rules/space-before-blocks)\n> 为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。\n\n```javascript\n// bad\nconst f = function(){};\nconst g = function (){};\nconst h = function() {};\n\n// good\nconst x = function () {};\nconst y = function a() {};\n```\n\n\n\n* [7.12](#functions--mutate-params) 没用变异参数。 eslint: [`no-param-reassign`](https://eslint.org/docs/rules/no-param-reassign.html)\n> 为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。\n\n```javascript\n// bad\nfunction f1(obj) {\n  obj.key = 1;\n}\n\n// good\nfunction f2(obj) {\n  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;\n}\n```\n\n\n\n* [7.13](#functions--reassign-params) 不要再赋值参数。 eslint: [`no-param-reassign`](https://eslint.org/docs/rules/no-param-reassign.html)\n> 为什么? 重新赋值参数会导致意外的行为，尤其是在访问 `arguments` 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。\n\n```javascript\n// bad\nfunction f1(a) {\n  a = 1;\n  // ...\n}\n\nfunction f2(a) {\n  if (!a) { a = 1; }\n  // ...\n}\n\n// good\nfunction f3(a) {\n  const b = a || 1;\n  // ...\n}\n\nfunction f4(a = 1) {\n  // ...\n}\n```\n\n\n\n* [7.14](#functions--spread-vs-apply) 优先使用扩展运算符 `...` 来调用可变参数函数。 eslint: [`prefer-spread`](https://eslint.org/docs/rules/prefer-spread)\n> 为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 `apply` 来 `new` 。\n\n```javascript\n// bad\nconst x = [1, 2, 3, 4, 5];\nconsole.log.apply(console, x);\n\n// good\nconst x = [1, 2, 3, 4, 5];\nconsole.log(...x);\n\n// bad\nnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));\n\n// good\nnew Date(...[2016, 8, 5]);\n```\n\n\n\n* [7.15](#functions--signature-invocation-indentation) 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: [`function-paren-newline`](https://eslint.org/docs/rules/function-paren-newline)\n```javascript\n// bad\nfunction foo(bar,\n             baz,\n             quux) {\n  // ...\n}\n\n// good\nfunction foo(\n  bar,\n  baz,\n  quux,\n) {\n  // ...\n}\n\n// bad\nconsole.log(foo,\n  bar,\n  baz);\n\n// good\nconsole.log(\n  foo,\n  bar,\n  baz,\n);\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"d86f8699\"></a>\n## [箭头函数]()\n\n\n* [8.1](#arrows--use-them) 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: [`prefer-arrow-callback`](https://eslint.org/docs/rules/prefer-arrow-callback.html), [`arrow-spacing`](https://eslint.org/docs/rules/arrow-spacing.html)\n> 为什么? 它创建了一个在 `this` 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。\n\n> 为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。\n\n```javascript\n// bad\n[1, 2, 3].map(function (x) {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  const y = x + 1;\n  return x * y;\n});\n```\n\n\n\n* [8.2](#arrows--implicit-return) 如果函数体包含一个单独的语句，返回一个没有副作用的 [expression](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions) ， 省略括号并使用隐式返回。否则，保留括号并使用 `return` 语句。 eslint: [`arrow-parens`](https://eslint.org/docs/rules/arrow-parens.html), [`arrow-body-style`](https://eslint.org/docs/rules/arrow-body-style.html)\n> 为什么? 语法糖。 多个函数被链接在一起时，提高可读性。\n\n```javascript\n// bad\n[1, 2, 3].map(number => {\n  const nextNumber = number + 1;\n  `A string containing the ${nextNumber}.`;\n});\n\n// good\n[1, 2, 3].map(number => `A string containing the ${number}.`);\n\n// good\n[1, 2, 3].map((number) => {\n  const nextNumber = number + 1;\n  return `A string containing the ${nextNumber}.`;\n});\n\n// good\n[1, 2, 3].map((number, index) => ({\n  [index]: number,\n}));\n\n// 没有副作用的隐式返回\nfunction foo(callback) {\n  const val = callback();\n  if (val === true) {\n    // 如果回调返回 true 执行\n  }\n}\n\nlet bool = false;\n\n// bad\nfoo(() => bool = true);\n\n// good\nfoo(() => {\n  bool = true;\n});\n```\n\n\n\n* [8.3](#arrows--paren-wrap) 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n> 为什么? 它清楚地显示了函数的起点和终点。\n\n```javascript\n// bad\n['get', 'post', 'put'].map(httpMethod => Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod,\n  )\n);\n\n// good\n['get', 'post', 'put'].map(httpMethod => (\n  Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod,\n  )\n));\n```\n\n\n\n* [8.4](#arrows--one-arg-parens) 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 [“always” option](https://eslint.org/docs/rules/arrow-parens#always) 来配置 eslint. eslint: [`arrow-parens`](https://eslint.org/docs/rules/arrow-parens.html)\n> 为什么? 减少视觉上的混乱。\n\n```javascript\n// bad\n[1, 2, 3].map((x) => x * x);\n\n// good\n[1, 2, 3].map(x => x * x);\n\n// good\n[1, 2, 3].map(number => (\n  `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`\n));\n\n// bad\n[1, 2, 3].map(x => {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map((x) => {\n  const y = x + 1;\n  return x * y;\n});\n```\n\n\n\n* [8.5](#arrows--confusing) 避免箭头函数符号 (`=>`) 和比较运算符 (`<=`, `>=`) 的混淆。 eslint: [`no-confusing-arrow`](https://eslint.org/docs/rules/no-confusing-arrow)\n```javascript\n// bad\nconst itemHeight = item => item.height > 256 ? item.largeSize : item.smallSize;\n\n// bad\nconst itemHeight = (item) => item.height > 256 ? item.largeSize : item.smallSize;\n\n// good\nconst itemHeight = item => (item.height > 256 ? item.largeSize : item.smallSize);\n\n// good\nconst itemHeight = (item) => {\n  const { height, largeSize, smallSize } = item;\n  return height > 256 ? largeSize : smallSize;\n};\n```\n\n\n\n* [8.6](#whitespace--implicit-arrow-linebreak) 注意带有隐式返回的箭头函数函数体的位置。 eslint: [`implicit-arrow-linebreak`](https://eslint.org/docs/rules/implicit-arrow-linebreak)\n```javascript\n// bad\n(foo) =>\n  bar;\n\n(foo) =>\n  (bar);\n\n// good\n(foo) => bar;\n(foo) => (bar);\n(foo) => (\n   bar\n)\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"93d5dc10\"></a>\n## [类和构造器]()\n\n\n* [9.1](#constructors--use-class) 尽量使用 `class`. 避免直接操作 `prototype` .\n> 为什么? `class` 语法更简洁，更容易推理。\n\n```javascript\n// bad\nfunction Queue(contents = []) {\n  this.queue = [...contents];\n}\nQueue.prototype.pop = function () {\n  const value = this.queue[0];\n  this.queue.splice(0, 1);\n  return value;\n};\n\n// good\nclass Queue {\n  constructor(contents = []) {\n    this.queue = [...contents];\n  }\n  pop() {\n    const value = this.queue[0];\n    this.queue.splice(0, 1);\n    return value;\n  }\n}\n```\n\n\n\n* [9.2](#constructors--extends) 使用 `extends` 来扩展继承。\n> 为什么? 它是一个内置的方法，可以在不破坏 `instanceof` 的情况下继承原型功能。\n\n```javascript\n// bad\nconst inherits = require('inherits');\nfunction PeekableQueue(contents) {\n  Queue.apply(this, contents);\n}\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function () {\n  return this.queue[0];\n};\n\n// good\nclass PeekableQueue extends Queue {\n  peek() {\n    return this.queue[0];\n  }\n}\n```\n\n\n\n* [9.3](#constructors--chaining) 方法返回了 `this` 来供其内部方法调用。\n```javascript\n// bad\nJedi.prototype.jump = function () {\n  this.jumping = true;\n  return true;\n};\n\nJedi.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nconst luke = new Jedi();\nluke.jump(); // => true\nluke.setHeight(20); // => undefined\n\n// good\nclass Jedi {\n  jump() {\n    this.jumping = true;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\n\nconst luke = new Jedi();\n\nluke.jump()\n  .setHeight(20);\n```\n\n\n\n* [9.4](#constructors--tostring) 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 `toString()` 方法也是可以的。\n```javascript\nclass Jedi {\n  constructor(options = {}) {\n    this.name = options.name || 'no name';\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  toString() {\n    return `Jedi - ${this.getName()}`;\n  }\n}\n```\n\n\n\n* [9.5](#constructors--no-useless) 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: [`no-useless-constructor`](https://eslint.org/docs/rules/no-useless-constructor)\n```javascript\n// bad\nclass Jedi {\n  constructor() {}\n\n  getName() {\n    return this.name;\n  }\n}\n\n// bad\nclass Rey extends Jedi {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n// good\nclass Rey extends Jedi {\n  constructor(...args) {\n    super(...args);\n    this.name = 'Rey';\n  }\n}\n```\n\n\n\n* [9.6](#classes--no-duplicate-members) 避免定义重复的类成员。 eslint: [`no-dupe-class-members`](https://eslint.org/docs/rules/no-dupe-class-members)\n> 为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。\n\n```javascript\n// bad\nclass Foo {\n  bar() { return 1; }\n  bar() { return 2; }\n}\n\n// good\nclass Foo {\n  bar() { return 1; }\n}\n\n// good\nclass Foo {\n  bar() { return 2; }\n}\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"fac54c34\"></a>\n## [模块]()\n\n\n* [10.1](#modules--use-them) 你可能经常使用模块 (`import`/`export`) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n> 为什么? 模块是未来的趋势，让我们拥抱未来。\n\n```javascript\n// bad\nconst AirbnbStyleGuide = require('./AirbnbStyleGuide');\nmodule.exports = AirbnbStyleGuide.es6;\n\n// ok\nimport AirbnbStyleGuide from './AirbnbStyleGuide';\nexport default AirbnbStyleGuide.es6;\n\n// best\nimport { es6 } from './AirbnbStyleGuide';\nexport default es6;\n```\n\n\n\n* [10.2](#modules--no-wildcard) 不要使用通配符导入。\n> 为什么? 这确定你有一个单独的默认导出。\n\n```javascript\n// bad\nimport * as AirbnbStyleGuide from './AirbnbStyleGuide';\n\n// good\nimport AirbnbStyleGuide from './AirbnbStyleGuide';\n```\n\n\n\n* [10.3](#modules--no-export-from-import) 不要直接从导入导出。\n> 为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。\n\n```javascript\n// bad\n// filename es6.js\nexport { es6 as default } from './AirbnbStyleGuide';\n\n// good\n// filename es6.js\nimport { es6 } from './AirbnbStyleGuide';\nexport default es6;\n```\n\n\n\n* [10.4](#modules--no-duplicate-imports) 只从一个路径导入所有需要的东西。<br />\neslint: [`no-duplicate-imports`](https://eslint.org/docs/rules/no-duplicate-imports)\n> 为什么? 从同一个路径导入多个行，使代码更难以维护。\n\n```javascript\n// bad\nimport foo from 'foo';\n// … 其他导入 … //\nimport { named1, named2 } from 'foo';\n\n// good\nimport foo, { named1, named2 } from 'foo';\n\n// good\nimport foo, {\n  named1,\n  named2,\n} from 'foo';\n```\n\n\n\n* [10.5](#modules--no-mutable-exports) 不要导出可变的引用。<br />\neslint: [`import/no-mutable-exports`](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-mutable-exports.md)\n> 为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。\n\n```javascript\n// bad\nlet foo = 3;\nexport { foo };\n\n// good\nconst foo = 3;\nexport { foo };\n```\n\n\n\n* [10.6](#modules--prefer-default-export) 在单个导出的模块中，选择默认模块而不是指定的导出。<br />\neslint: [`import/prefer-default-export`](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/prefer-default-export.md)\n> 为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。\n\n```javascript\n// bad\nexport function foo() {}\n\n// good\nexport default function foo() {}\n```\n\n\n\n* [10.7](#modules--imports-first) 将所有的 `import`s 语句放在所有非导入语句的上边。<br />\neslint: [`import/first`](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/first.md)\n> 为什么? 由于所有的 `import`s 都被提前，保持他们在顶部是为了防止意外发生。\n\n```javascript\n// bad\nimport foo from 'foo';\nfoo.init();\n\nimport bar from 'bar';\n\n// good\nimport foo from 'foo';\nimport bar from 'bar';\n\nfoo.init();\n```\n\n\n\n* [10.8](#modules--multiline-imports-over-newlines) 多行导入应该像多行数组和对象一样缩进。\n> 为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。\n\n```javascript\n// bad\nimport {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';\n\n// good\nimport {\n  longNameA,\n  longNameB,\n  longNameC,\n  longNameD,\n  longNameE,\n} from 'path';\n```\n\n\n\n* [10.9](#modules--no-webpack-loader-syntax) 在模块导入语句中禁止使用 Webpack 加载器语法。<br />\neslint: [`import/no-webpack-loader-syntax`](https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md)\n> 为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 `webpack.config.js` 中使用加载器语法。\n\n```javascript\n// bad\nimport fooSass from 'css!sass!foo.scss';\nimport barCss from 'style!css!bar.css';\n\n// good\nimport fooSass from 'foo.scss';\nimport barCss from 'bar.css';\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"3caad93c\"></a>\n## [迭代器和发生器]()\n\n\n* [11.1](#iterators--nope) 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 `for-in` 或者 `for-of`。 eslint: [`no-iterator`](https://eslint.org/docs/rules/no-iterator.html) [`no-restricted-syntax`](https://eslint.org/docs/rules/no-restricted-syntax)\n> 为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。\n\n> 使用 `map()` / `every()` / `filter()` / `find()` / `findIndex()` / `reduce()` / `some()` / ... 遍历数组， 和使用 `Object.keys()` / `Object.values()` / `Object.entries()` 迭代你的对象生成数组。\n\n```javascript\nconst numbers = [1, 2, 3, 4, 5];\n\n// bad\nlet sum = 0;\nfor (let num of numbers) {\n  sum += num;\n}\nsum === 15;\n\n// good\nlet sum = 0;\nnumbers.forEach((num) => {\n  sum += num;\n});\nsum === 15;\n\n// best (use the functional force)\nconst sum = numbers.reduce((total, num) => total + num, 0);\nsum === 15;\n\n// bad\nconst increasedByOne = [];\nfor (let i = 0; i < numbers.length; i++) {\n  increasedByOne.push(numbers[i] + 1);\n}\n\n// good\nconst increasedByOne = [];\nnumbers.forEach((num) => {\n  increasedByOne.push(num + 1);\n});\n\n// best (keeping it functional)\nconst increasedByOne = numbers.map(num => num + 1);\n```\n\n\n\n* [11.2](#generators--nope) 不要使用发生器。\n> 为什么? 它们不能很好的适应 ES5。\n\n\n\n\n* [11.3](#generators--spacing) 如果你必须使用发生器或者无视 [我们的建议](#generators--nope)，请确保他们的函数签名是正常的间隔。 eslint: [`generator-star-spacing`](https://eslint.org/docs/rules/generator-star-spacing)\n> 为什么? `function` 和 `*` 是同一个概念关键字的一部分 - `*` 不是 `function` 的修饰符， `function*` 是一个不同于 `function` 的构造器。\n\n```javascript\n// bad\nfunction * foo() {\n  // ...\n}\n\n// bad\nconst bar = function * () {\n  // ...\n};\n\n// bad\nconst baz = function *() {\n  // ...\n};\n\n// bad\nconst quux = function*() {\n  // ...\n};\n\n// bad\nfunction*foo() {\n  // ...\n}\n\n// bad\nfunction *foo() {\n  // ...\n}\n\n// very bad\nfunction\n*\nfoo() {\n  // ...\n}\n\n// very bad\nconst wat = function\n*\n() {\n  // ...\n};\n\n// good\nfunction* foo() {\n  // ...\n}\n\n// good\nconst foo = function* () {\n  // ...\n};\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"24d67862\"></a>\n## [属性]()\n\n\n* [12.1](#properties--dot) 访问属性时使用点符号。 eslint: [`dot-notation`](https://eslint.org/docs/rules/dot-notation.html)\n```javascript\nconst luke = {\n  jedi: true,\n  age: 28,\n};\n\n// bad\nconst isJedi = luke['jedi'];\n\n// good\nconst isJedi = luke.jedi;\n```\n\n\n\n* [12.2](#properties--bracket) 使用变量访问属性时，使用 `[]`表示法。\n```javascript\nconst luke = {\n  jedi: true,\n  age: 28,\n};\n\nfunction getProp(prop) {\n  return luke[prop];\n}\n\nconst isJedi = getProp('jedi');\n```\n\n\n\n* [12.3](#es2016-properties--exponentiation-operator) 计算指数时，可以使用 `**` 运算符。 eslint: [`no-restricted-properties`](https://eslint.org/docs/rules/no-restricted-properties).\n```javascript\n// bad\nconst binary = Math.pow(2, 10);\n\n// good\nconst binary = 2 ** 10;\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"ddc7d28b\"></a>\n## [变量]()\n\n\n* [13.1](#variables--const) 使用 `const` 或者 `let` 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: [`no-undef`](https://eslint.org/docs/rules/no-undef) [`prefer-const`](https://eslint.org/docs/rules/prefer-const)\n```javascript\n// bad\nsuperPower = new SuperPower();\n\n// good\nconst superPower = new SuperPower();\n```\n\n\n\n* [13.2](#variables--one-const) 使用 `const` 或者 `let` 声明每一个变量。 eslint: [`one-var`](https://eslint.org/docs/rules/one-var.html)\n> 为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 `;` 还是使用 `,` 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。\n\n```javascript\n// bad\nconst items = getItems(),\n    goSportsTeam = true,\n    dragonball = 'z';\n\n// bad\n// (compare to above, and try to spot the mistake)\nconst items = getItems(),\n    goSportsTeam = true;\n    dragonball = 'z';\n\n// good\nconst items = getItems();\nconst goSportsTeam = true;\nconst dragonball = 'z';\n```\n\n\n\n* [13.3](#variables--const-let-group) 把 `const` 声明的放在一起，把 `let` 声明的放在一起。.\n> 为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。\n\n```javascript\n// bad\nlet i, len, dragonball,\n    items = getItems(),\n    goSportsTeam = true;\n\n// bad\nlet i;\nconst items = getItems();\nlet dragonball;\nconst goSportsTeam = true;\nlet len;\n\n// good\nconst goSportsTeam = true;\nconst items = getItems();\nlet dragonball;\nlet i;\nlet length;\n```\n\n\n\n* [13.4](#variables--define-where-used) 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\n> 为什么? `let` 和 `const` 是块级作用域而不是函数作用域。\n\n```javascript\n// bad - 不必要的函数调用\nfunction checkName(hasName) {\n  const name = getName();\n\n  if (hasName === 'test') {\n    return false;\n  }\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n\n// good\nfunction checkName(hasName) {\n  if (hasName === 'test') {\n    return false;\n  }\n\n  const name = getName();\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n```\n\n\n\n* [13.5](#variables--no-chain-assignment) 不要链式变量赋值。 eslint: [`no-multi-assign`](https://eslint.org/docs/rules/no-multi-assign)\n> 为什么? 链式变量赋值会创建隐式全局变量。\n\n```javascript\n// bad\n(function example() {\n  // JavaScript 把它解释为\n  // let a = ( b = ( c = 1 ) );\n  // let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。\n  let a = b = c = 1;\n}());\n\nconsole.log(a); // throws ReferenceError\nconsole.log(b); // 1\nconsole.log(c); // 1\n\n// good\n(function example() {\n  let a = 1;\n  let b = a;\n  let c = a;\n}());\n\nconsole.log(a); // throws ReferenceError\nconsole.log(b); // throws ReferenceError\nconsole.log(c); // throws ReferenceError\n\n// 对于 `const` 也一样\n```\n\n\n\n* [13.6](#variables--unary-increment-decrement) 避免使用不必要的递增和递减 (`++`, `--`)。 eslint [`no-plusplus`](https://eslint.org/docs/rules/no-plusplus)\n> 为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 `num += 1` 这样的语句来改变您的值，而不是使用 `num++` 或 `num ++` 。不允许不必要的增量和减量语句也会使您无法预先递增/预递减值，这也会导致程序中的意外行为。\n\n```javascript\n// bad\n\nconst array = [1, 2, 3];\nlet num = 1;\nnum++;\n--num;\n\nlet sum = 0;\nlet truthyCount = 0;\nfor (let i = 0; i < array.length; i++) {\n  let value = array[i];\n  sum += value;\n  if (value) {\n    truthyCount++;\n  }\n}\n\n// good\n\nconst array = [1, 2, 3];\nlet num = 1;\nnum += 1;\nnum -= 1;\n\nconst sum = array.reduce((a, b) => a + b, 0);\nconst truthyCount = array.filter(Boolean).length;\n```\n\n\n\n* [13.7](#variables--linebreak) 避免在赋值语句 `=` 前后换行。如果你的代码违反了 [`max-len`](https://eslint.org/docs/rules/max-len.html)， 使用括号包裹。 eslint [`operator-linebreak`](https://eslint.org/docs/rules/operator-linebreak.html).\n> 为什么? 在 `=` 前后换行，可能混淆赋的值。\n\n```javascript\n// bad\nconst foo =\n  superLongLongLongLongLongLongLongLongFunctionName();\n\n// bad\nconst foo\n  = 'superLongLongLongLongLongLongLongLongString';\n\n// good\nconst foo = (\n  superLongLongLongLongLongLongLongLongFunctionName()\n);\n\n// good\nconst foo = 'superLongLongLongLongLongLongLongLongString';\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"c290b27e\"></a>\n## [提升]()\n\n\n* [14.1](#hoisting--about) `var` 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。`const` 和 `let` 声明的变量受到一个称之为 [Temporal Dead Zones (TDZ)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let) 的新概念保护。 知道为什么 [typeof 不再安全](http://es-discourse.com/t/why-typeof-is-no-longer-safe/15) 是很重要的。\n```javascript\n// 我们知道这个行不通 (假设没有未定义的全局变量)\nfunction example() {\n  console.log(notDefined); // => throws a ReferenceError\n}\n\n// 在引用变量后创建变量声明将会因变量提升而起作用。\n// 注意: 真正的值 `true` 不会被提升。\nfunction example() {\n  console.log(declaredButNotAssigned); // => undefined\n  var declaredButNotAssigned = true;\n}\n\n// 解释器将变量提升到函数的顶部\n// 这意味着我们可以将上边的例子重写为：\nfunction example() {\n  let declaredButNotAssigned;\n  console.log(declaredButNotAssigned); // => undefined\n  declaredButNotAssigned = true;\n}\n\n// 使用 const 和 let\nfunction example() {\n  console.log(declaredButNotAssigned); // => throws a ReferenceError\n  console.log(typeof declaredButNotAssigned); // => throws a ReferenceError\n  const declaredButNotAssigned = true;\n}\n```\n\n\n\n* [14.2](#hoisting--anon-expressions) 匿名函数表达式提升变量名，而不是函数赋值。\n```javascript\nfunction example() {\n  console.log(anonymous); // => undefined\n\n  anonymous(); // => TypeError anonymous is not a function\n\n  var anonymous = function () {\n    console.log('anonymous function expression');\n  };\n}\n```\n\n\n\n* [14.3](#hoisting--named-expressions) 命名函数表达式提升的是变量名，而不是函数名或者函数体。\n```javascript\nfunction example() {\n  console.log(named); // => undefined\n\n  named(); // => TypeError named is not a function\n\n  superPower(); // => ReferenceError superPower is not defined\n\n  var named = function superPower() {\n    console.log('Flying');\n  };\n}\n\n// 当函数名和变量名相同时也是如此。\nfunction example() {\n  console.log(named); // => undefined\n\n  named(); // => TypeError named is not a function\n\n  var named = function named() {\n    console.log('named');\n  };\n}\n```\n\n\n\n* [14.4](#hoisting--declarations) 函数声明提升其名称和函数体。\n```javascript\nfunction example() {\n  superPower(); // => Flying\n\n  function superPower() {\n    console.log('Flying');\n  }\n}\n```\n\n* 更多信息请参考 [Ben Cherry](http://www.adequatelygood.com/) 的 [JavaScript Scoping & Hoisting](http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting/)。\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"d6cfcb92\"></a>\n## [比较运算符和等号]()\n\n\n* [15.1](#comparison--eqeqeq) 使用 `===` 和 `!==` 而不是 `==` 和 `!=`。 eslint: [`eqeqeq`](https://eslint.org/docs/rules/eqeqeq.html)\n\n\n* [15.2](#comparison--if) 条件语句，例如 `if` 语句使用 `ToBoolean` 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：\n  * **Objects**true**\n  * **Undefined**false**\n  * **Null**false**\n  * **Booleans**布尔值的取值**\n  * **Numbers**+0, -0, or NaN**false**true**\n  * **Strings** 的取值为: 如果是一个空字符串 `''` 值为 **false**true**\n```javascript\nif ([0] && []) {\n  // true\n  // 一个数组（即使是空的）是一个对象，对象的取值为 true\n}\n```\n\n\n* [15.3](#comparison--shortcuts) 对于布尔值使用简写，但是对于字符串和数字进行显式比较。\n```javascript\n// bad\nif (isValid === true) {\n  // ...\n}\n\n// good\nif (isValid) {\n  // ...\n}\n\n// bad\nif (name) {\n  // ...\n}\n\n// good\nif (name !== '') {\n  // ...\n}\n\n// bad\nif (collection.length) {\n  // ...\n}\n\n// good\nif (collection.length > 0) {\n  // ...\n}\n```\n\n\n\n* [15.4](#comparison--moreinfo) 获取更多信息请查看 Angus Croll 的 [Truth Equality and JavaScript](https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108) 。\n\n\n* [15.5](#comparison--switch-blocks) 在 `case` 和 `default` 的子句中，如果存在声明 (例如. `let`, `const`, `function`, 和 `class`)，使用大括号来创建块 。 eslint: [`no-case-declarations`](https://eslint.org/docs/rules/no-case-declarations.html)\n> 为什么? 语法声明在整个 `switch` 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 `case` 条件达到才会发生。 当多个 `case` 语句定义相同的东西是，这会导致问题问题。\n\n```javascript\n// bad\nswitch (foo) {\n  case 1:\n    let x = 1;\n    break;\n  case 2:\n    const y = 2;\n    break;\n  case 3:\n    function f() {\n      // ...\n    }\n    break;\n  default:\n    class C {}\n}\n\n// good\nswitch (foo) {\n  case 1: {\n    let x = 1;\n    break;\n  }\n  case 2: {\n    const y = 2;\n    break;\n  }\n  case 3: {\n    function f() {\n      // ...\n    }\n    break;\n  }\n  case 4:\n    bar();\n    break;\n  default: {\n    class C {}\n  }\n}\n```\n\n\n\n* [15.6](#comparison--nested-ternaries) 三目表达式不应该嵌套，通常是单行表达式。 eslint: [`no-nested-ternary`](https://eslint.org/docs/rules/no-nested-ternary.html)\n```javascript\n// bad\nconst foo = maybe1 > maybe2\n  ? \"bar\"\n  : value1 > value2 ? \"baz\" : null;\n\n// 分离为两个三目表达式\nconst maybeNull = value1 > value2 ? 'baz' : null;\n\n// better\nconst foo = maybe1 > maybe2\n  ? 'bar'\n  : maybeNull;\n\n// best\nconst foo = maybe1 > maybe2 ? 'bar' : maybeNull;\n```\n\n\n\n* [15.7](#comparison--unneeded-ternary) 避免不必要的三目表达式。 eslint: [`no-unneeded-ternary`](https://eslint.org/docs/rules/no-unneeded-ternary.html)\n```javascript\n// bad\nconst foo = a ? a : b;\nconst bar = c ? true : false;\nconst baz = c ? false : true;\n\n// good\nconst foo = a || b;\nconst bar = !!c;\nconst baz = !c;\n```\n\n\n\n* [15.8](#comparison--no-mixed-operators) 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (`+`, `-`, `*`, & `/`) 因为他们的优先级被广泛理解。 eslint: [`no-mixed-operators`](https://eslint.org/docs/rules/no-mixed-operators.html)\n> 为什么? 这能提高可读性并且表明开发人员的意图。\n\n```javascript\n// bad\nconst foo = a && b < 0 || c > 0 || d + 1 === 0;\n\n// bad\nconst bar = a ** b - 5 % d;\n\n// bad\n// 可能陷入一种 (a || b) && c 的思考\nif (a || b && c) {\n  return d;\n}\n\n// good\nconst foo = (a && b < 0) || c > 0 || (d + 1 === 0);\n\n// good\nconst bar = (a ** b) - (5 % d);\n\n// good\nif (a || (b && c)) {\n  return d;\n}\n\n// good\nconst bar = a + b / c * d;\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"7084eb1b\"></a>\n## [块]()\n\n\n* [16.1](#blocks--braces) 当有多行代码块的时候，使用大括号包裹。 eslint: [`nonblock-statement-body-position`](https://eslint.org/docs/rules/nonblock-statement-body-position)\n```javascript\n// bad\nif (test)\n  return false;\n\n// good\nif (test) return false;\n\n// good\nif (test) {\n  return false;\n}\n\n// bad\nfunction foo() { return false; }\n\n// good\nfunction bar() {\n  return false;\n}\n```\n\n\n\n* [16.2](#blocks--cuddled-elses) 如果你使用的是 `if` 和 `else` 的多行代码块，则将 `else` 语句放在 `if` 块闭括号同一行的位置。 eslint: [`brace-style`](https://eslint.org/docs/rules/brace-style.html)\n```javascript\n// bad\nif (test) {\n  thing1();\n  thing2();\n}\nelse {\n  thing3();\n}\n\n// good\nif (test) {\n  thing1();\n  thing2();\n} else {\n  thing3();\n}\n```\n\n\n\n* [16.3](#blocks--no-else-return) 如果一个 `if` 块总是执行一个 `return` 语句，那么接下来的 `else` 块就没有必要了。 如果一个包含 `return` 语句的 `else if` 块，在一个包含了 `return` 语句的 `if` 块之后，那么可以拆成多个 `if` 块。 eslint: [`no-else-return`](https://eslint.org/docs/rules/no-else-return)\n```javascript\n// bad\nfunction foo() {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\n// bad\nfunction cats() {\n  if (x) {\n    return x;\n  } else if (y) {\n    return y;\n  }\n}\n\n// bad\nfunction dogs() {\n  if (x) {\n    return x;\n  } else {\n    if (y) {\n      return y;\n    }\n  }\n}\n\n// good\nfunction foo() {\n  if (x) {\n    return x;\n  }\n\n  return y;\n}\n\n// good\nfunction cats() {\n  if (x) {\n    return x;\n  }\n\n  if (y) {\n    return y;\n  }\n}\n\n// good\nfunction dogs(x) {\n  if (x) {\n    if (z) {\n      return y;\n    }\n  } else {\n    return z;\n  }\n}\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"ea5302a4\"></a>\n## [控制语句]()\n\n\n* [17.1](#control-statements) 如果你的控制语句 (`if`, `while` 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。\n> 为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。\n\n```javascript\n// bad\nif ((foo === 123 || bar === 'abc') && doesItLookGoodWhenItBecomesThatLong() && isThisReallyHappening()) {\n  thing1();\n}\n\n// bad\nif (foo === 123 &&\n  bar === 'abc') {\n  thing1();\n}\n\n// bad\nif (foo === 123\n  && bar === 'abc') {\n  thing1();\n}\n\n// bad\nif (\n  foo === 123 &&\n  bar === 'abc'\n) {\n  thing1();\n}\n\n// good\nif (\n  foo === 123\n  && bar === 'abc'\n) {\n  thing1();\n}\n\n// good\nif (\n  (foo === 123 || bar === 'abc')\n  && doesItLookGoodWhenItBecomesThatLong()\n  && isThisReallyHappening()\n) {\n  thing1();\n}\n\n// good\nif (foo === 123 && bar === 'abc') {\n  thing1();\n}\n```\n\n\n\n* [17.2](#control-statements--value-selection) 不要使用选择操作符代替控制语句。\n```javascript\n// bad\n!isRunning && startRunning();\n\n// good\nif (!isRunning) {\n  startRunning();\n}\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"ee656aa1\"></a>\n## [注释]()\n\n\n* [18.1](#comments--multiline) 使用 `/** ... */` 来进行多行注释。\n```javascript\n// bad\n// make() returns a new element\n// based on the passed in tag name\n//\n// @param {String} tag\n// @return {Element} element\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n\n// good\n/**\n * make() returns a new element\n * based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n```\n\n\n\n* [18.2](#comments--singleline) 使用 `//` 进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。\n```javascript\n// bad\nconst active = true;  // is current tab\n\n// good\n// is current tab\nconst active = true;\n\n// bad\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  const type = this.type || 'no type';\n\n  return type;\n}\n\n// good\nfunction getType() {\n  console.log('fetching type...');\n\n  // set the default type to 'no type'\n  const type = this.type || 'no type';\n\n  return type;\n}\n\n// also good\nfunction getType() {\n  // set the default type to 'no type'\n  const type = this.type || 'no type';\n\n  return type;\n}\n```\n\n\n\n* [18.3](#comments--spaces) 用一个空格开始所有的注释，使它更容易阅读。 eslint: [`spaced-comment`](https://eslint.org/docs/rules/spaced-comment)\n```javascript\n// bad\n//is current tab\nconst active = true;\n\n// good\n// is current tab\nconst active = true;\n\n// bad\n/**\n *make() returns a new element\n *based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n\n// good\n/**\n * make() returns a new element\n * based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n```\n\n\n\n* [18.4](#comments--actionitems) 使用 `FIXME` 或者 `TODO` 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 `FIXME: -- 需要解决这个问题` 或者 `TODO: -- 需要被实现`。\n\n\n* [18.5](#comments--fixme) 使用 `// FIXME:` 注释一个问题。\n```javascript\nclass Calculator extends Abacus {\n  constructor() {\n    super();\n\n    // FIXME: 这里不应该使用全局变量\n    total = 0;\n  }\n}\n```\n\n\n\n* [18.6](#comments--todo) 使用 `// TODO:` 注释解决问题的方法。\n```javascript\nclass Calculator extends Abacus {\n  constructor() {\n    super();\n\n    // TODO: total 应该由一个 param 的选项配置\n    this.total = 0;\n  }\n}\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"6874c973\"></a>\n## [空白]()\n\n\n* [19.1](#whitespace--spaces) 使用 tabs (空格字符) 设置为 2 个空格。 eslint: [`indent`](https://eslint.org/docs/rules/indent.html)\n```javascript\n// bad\nfunction foo() {\n∙∙∙∙let name;\n}\n\n// bad\nfunction bar() {\n∙let name;\n}\n\n// good\nfunction baz() {\n∙∙let name;\n}\n```\n\n\n\n* [19.2](#whitespace--before-blocks) 在主体前放置一个空格。 eslint: [`space-before-blocks`](https://eslint.org/docs/rules/space-before-blocks.html)\n```javascript\n// bad\nfunction test(){\n  console.log('test');\n}\n\n// good\nfunction test() {\n  console.log('test');\n}\n\n// bad\ndog.set('attr',{\n  age: '1 year',\n  breed: 'Bernese Mountain Dog',\n});\n\n// good\ndog.set('attr', {\n  age: '1 year',\n  breed: 'Bernese Mountain Dog',\n});\n```\n\n\n\n* [19.3](#whitespace--around-keywords) 在控制语句（`if`, `while` 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: [`keyword-spacing`](https://eslint.org/docs/rules/keyword-spacing.html)\n```javascript\n// bad\nif(isJedi) {\n  fight ();\n}\n\n// good\nif (isJedi) {\n  fight();\n}\n\n// bad\nfunction fight () {\n  console.log ('Swooosh!');\n}\n\n// good\nfunction fight() {\n  console.log('Swooosh!');\n}\n```\n\n\n\n* [19.4](#whitespace--infix-ops) 用空格分离操作符。 eslint: [`space-infix-ops`](https://eslint.org/docs/rules/space-infix-ops.html)\n```javascript\n// bad\nconst x=y+5;\n\n// good\nconst x = y + 5;\n```\n\n\n\n* [19.5](#whitespace--newline-at-end) 使用单个换行符结束文件。 eslint: [`eol-last`](https://github.com/eslint/eslint/blob/master/docs/rules/eol-last.md)\n```javascript\n// bad\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;\n```\n```javascript\n// bad\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;↵\n↵\n```\n```javascript\n// good\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;↵\n```\n\n\n\n* [19.6](#whitespace--chains) 在使用链式方法调用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: [`newline-per-chained-call`](https://eslint.org/docs/rules/newline-per-chained-call) [`no-whitespace-before-property`](https://eslint.org/docs/rules/no-whitespace-before-property)\n```javascript\n// bad\n$('#items').find('.selected').highlight().end().find('.open').updateCount();\n\n// bad\n$('#items').\n  find('.selected').\n    highlight().\n    end().\n  find('.open').\n    updateCount();\n\n// good\n$('#items')\n  .find('.selected')\n    .highlight()\n    .end()\n  .find('.open')\n    .updateCount();\n\n// bad\nconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true)\n    .attr('width', (radius + margin) * 2).append('svg:g')\n    .attr('transform', `translate(${radius + margin},${radius + margin})`)\n    .call(tron.led);\n\n// good\nconst leds = stage.selectAll('.led')\n    .data(data)\n  .enter().append('svg:svg')\n    .classed('led', true)\n    .attr('width', (radius + margin) * 2)\n  .append('svg:g')\n    .attr('transform', `translate(${radius + margin},${radius + margin})`)\n    .call(tron.led);\n\n// good\nconst leds = stage.selectAll('.led').data(data);\n```\n\n\n\n* [19.7](#whitespace--after-blocks) 在块和下一个语句之前留下一空白行。\n```javascript\n// bad\nif (foo) {\n  return bar;\n}\nreturn baz;\n\n// good\nif (foo) {\n  return bar;\n}\n\nreturn baz;\n\n// bad\nconst obj = {\n  foo() {\n  },\n  bar() {\n  },\n};\nreturn obj;\n\n// good\nconst obj = {\n  foo() {\n  },\n\n  bar() {\n  },\n};\n\nreturn obj;\n\n// bad\nconst arr = [\n  function foo() {\n  },\n  function bar() {\n  },\n];\nreturn arr;\n\n// good\nconst arr = [\n  function foo() {\n  },\n\n  function bar() {\n  },\n];\n\nreturn arr;\n```\n\n\n\n* [19.8](#whitespace--padded-blocks) 不要在块的开头使用空白行。 eslint: [`padded-blocks`](https://eslint.org/docs/rules/padded-blocks.html)\n```javascript\n// bad\nfunction bar() {\n\n  console.log(foo);\n\n}\n\n// bad\nif (baz) {\n\n  console.log(qux);\n} else {\n  console.log(foo);\n\n}\n\n// bad\nclass Foo {\n\n  constructor(bar) {\n    this.bar = bar;\n  }\n}\n\n// good\nfunction bar() {\n  console.log(foo);\n}\n\n// good\nif (baz) {\n  console.log(qux);\n} else {\n  console.log(foo);\n}\n```\n\n\n\n* [19.9](#whitespace--in-parens) 不要在括号内添加空格。 eslint: [`space-in-parens`](https://eslint.org/docs/rules/space-in-parens.html)\n```javascript\n// bad\nfunction bar( foo ) {\n  return foo;\n}\n\n// good\nfunction bar(foo) {\n  return foo;\n}\n\n// bad\nif ( foo ) {\n  console.log(foo);\n}\n\n// good\nif (foo) {\n  console.log(foo);\n}\n```\n\n\n\n* [19.10](#whitespace--in-brackets) 不要在中括号中添加空格。 eslint: [`array-bracket-spacing`](https://eslint.org/docs/rules/array-bracket-spacing.html)\n```javascript\n// bad\nconst foo = [ 1, 2, 3 ];\nconsole.log(foo[ 0 ]);\n\n// good\nconst foo = [1, 2, 3];\nconsole.log(foo[0]);\n```\n\n\n\n* [19.11](#whitespace--in-braces) 在花括号内添加空格。 eslint: [`object-curly-spacing`](https://eslint.org/docs/rules/object-curly-spacing.html)\n```javascript\n// bad\nconst foo = {clark: 'kent'};\n\n// good\nconst foo = { clark: 'kent' };\n```\n\n\n\n* [19.12](#whitespace--max-len) 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 [约束](#strings--line-length)，长字符串可免除此规定，不应分解。 eslint: [`max-len`](https://eslint.org/docs/rules/max-len.html)\n> 为什么? 这样能够确保可读性和可维护性。\n\n```javascript\n// bad\nconst foo = jsonData && jsonData.foo && jsonData.foo.bar && jsonData.foo.bar.baz && jsonData.foo.bar.baz.quux && jsonData.foo.bar.baz.quux.xyzzy;\n\n// bad\n$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() => console.log('Congratulations!')).fail(() => console.log('You have failed this city.'));\n\n// good\nconst foo = jsonData\n  && jsonData.foo\n  && jsonData.foo.bar\n  && jsonData.foo.bar.baz\n  && jsonData.foo.bar.baz.quux\n  && jsonData.foo.bar.baz.quux.xyzzy;\n\n// good\n$.ajax({\n  method: 'POST',\n  url: 'https://airbnb.com/',\n  data: { name: 'John' },\n})\n  .done(() => console.log('Congratulations!'))\n  .fail(() => console.log('You have failed this city.'));\n```\n\n\n\n* [19.13](#whitespace--block-spacing) 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: [`block-spacing`](https://eslint.org/docs/rules/block-spacing)\n```javascript\n// bad\nfunction foo() {return true;}\nif (foo) { bar = 0;}\n\n// good\nfunction foo() { return true; }\nif (foo) { bar = 0; }\n```\n\n\n\n* [19.14](#whitespace--comma-spacing) 逗号之前避免使用空格，逗号之后需要使用空格。eslint: [`comma-spacing`](https://eslint.org/docs/rules/comma-spacing)\n```javascript\n// bad\nvar foo = 1,bar = 2;\nvar arr = [1 , 2];\n\n// good\nvar foo = 1, bar = 2;\nvar arr = [1, 2];\n```\n\n\n\n* [19.15](#whitespace--computed-property-spacing) 在计算属性之间强化间距。eslint: [`computed-property-spacing`](https://eslint.org/docs/rules/computed-property-spacing)\n```javascript\n// bad\nobj[foo ]\nobj[ 'foo']\nvar x = {[ b ]: a}\nobj[foo[ bar ]]\n\n// good\nobj[foo]\nobj['foo']\nvar x = { [b]: a }\nobj[foo[bar]]\n```\n\n\n\n* [19.16](#whitespace--func-call-spacing) 在函数和它的调用之间强化间距。 eslint: [`func-call-spacing`](https://eslint.org/docs/rules/func-call-spacing)\n```javascript\n// bad\nfunc ();\n\nfunc\n();\n\n// good\nfunc();\n```\n\n\n\n* [19.17](#whitespace--key-spacing) 在对象的属性和值之间强化间距。 eslint: [`key-spacing`](https://eslint.org/docs/rules/key-spacing)\n```javascript\n// bad\nvar obj = { \"foo\" : 42 };\nvar obj2 = { \"foo\":42 };\n\n// good\nvar obj = { \"foo\": 42 };\n```\n\n\n\n* [19.18](#whitespace--no-trailing-spaces) 在行的末尾避免使用空格。 eslint: [`no-trailing-spaces`](https://eslint.org/docs/rules/no-trailing-spaces)\n\n\n* [19.19](#whitespace--no-multiple-empty-lines) 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: [`no-multiple-empty-lines`](https://eslint.org/docs/rules/no-multiple-empty-lines)\n\n```javascript\n// bad\nvar x = 1;\n\n\n\nvar y = 2;\n\n// good\nvar x = 1;\n\nvar y = 2;\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"c2d5517a\"></a>\n## [逗号]()\n\n\n* [20.1](#commas--leading-trailing) 逗号前置： **不行** eslint: [`comma-style`](https://eslint.org/docs/rules/comma-style.html)\n```javascript\n// bad\nconst story = [\n    once\n  , upon\n  , aTime\n];\n\n// good\nconst story = [\n  once,\n  upon,\n  aTime,\n];\n\n// bad\nconst hero = {\n    firstName: 'Ada'\n  , lastName: 'Lovelace'\n  , birthYear: 1815\n  , superPower: 'computers'\n};\n\n// good\nconst hero = {\n  firstName: 'Ada',\n  lastName: 'Lovelace',\n  birthYear: 1815,\n  superPower: 'computers',\n};\n```\n\n\n\n* [20.2](#commas--dangling) 添加尾随逗号： **可以** eslint: [`comma-dangle`](https://eslint.org/docs/rules/comma-dangle.html)\n> 为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 [尾随逗号问题](https://github.com/airbnb/javascript/blob/es5-deprecated/es5/README.md#commas) 。\n\n```diff\n// bad - 没有尾随逗号的 git 差异\nconst hero = {\n     firstName: 'Florence',\n-    lastName: 'Nightingale'\n+    lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing']\n};\n\n// good - 有尾随逗号的 git 差异\nconst hero = {\n     firstName: 'Florence',\n     lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing'],\n};\n```\n```javascript\n// bad\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully'\n};\n\nconst heroes = [\n  'Batman',\n  'Superman'\n];\n\n// good\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully',\n};\n\nconst heroes = [\n  'Batman',\n  'Superman',\n];\n\n// bad\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf\n) {\n  // does nothing\n}\n\n// good\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf,\n) {\n  // does nothing\n}\n\n// good (注意逗号不能出现在 \"rest\" 元素后边)\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf,\n  ...heroArgs\n) {\n  // does nothing\n}\n\n// bad\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf\n);\n\n// good\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf,\n);\n\n// good (注意逗号不能出现在 \"rest\" 元素后边)\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf,\n  ...heroArgs\n);\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"cb368833\"></a>\n## [分号]()\n\n\n* [21.1](#semicolons--required) **对** eslint: [`semi`](https://eslint.org/docs/rules/semi.html)\n> 为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 [Automatic Semicolon Insertion](https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion) 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。\n\n```javascript\n// bad - 可能异常\nconst luke = {}\nconst leia = {}\n[luke, leia].forEach(jedi => jedi.father = 'vader')\n\n// bad - 可能异常\nconst reaction = \"No! That's impossible!\"\n(async function meanwhileOnTheFalcon() {\n  // handle `leia`, `lando`, `chewie`, `r2`, `c3p0`\n  // ...\n}())\n\n// bad - 返回 `undefined` 而不是下一行的值 - 当 `return` 单独一行的时候 ASI 总是会发生\nfunction foo() {\n  return\n    'search your feelings, you know it to be foo'\n}\n\n// good\nconst luke = {};\nconst leia = {};\n[luke, leia].forEach((jedi) => {\n  jedi.father = 'vader';\n});\n\n// good\nconst reaction = \"No! That's impossible!\";\n(async function meanwhileOnTheFalcon() {\n  // handle `leia`, `lando`, `chewie`, `r2`, `c3p0`\n  // ...\n}());\n\n// good\nfunction foo() {\n  return 'search your feelings, you know it to be foo';\n}\n```\n\n<br />[更多信息](https://stackoverflow.com/questions/7365172/semicolon-before-self-invoking-function/7365214#7365214).\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"bf7d863e\"></a>\n## [类型转换和强制类型转换]()\n\n\n* [22.1](#coercion--explicit) 在语句开始前进行类型转换。\n\n\n* [22.2](#coercion--strings)  字符类型： eslint: [`no-new-wrappers`](https://eslint.org/docs/rules/no-new-wrappers)\n```javascript\n// => this.reviewScore = 9;\n\n// bad\nconst totalScore = new String(this.reviewScore); // typeof totalScore is \"object\" not \"string\"\n\n// bad\nconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()\n\n// bad\nconst totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string\n\n// good\nconst totalScore = String(this.reviewScore);\n```\n\n\n\n* [22.3](#coercion--numbers) 数字类型：使用 `Number` 进行类型铸造和 `parseInt` 总是通过一个基数来解析一个字符串。 eslint: [`radix`](https://eslint.org/docs/rules/radix) [`no-new-wrappers`](https://eslint.org/docs/rules/no-new-wrappers)\n```javascript\nconst inputValue = '4';\n\n// bad\nconst val = new Number(inputValue);\n\n// bad\nconst val = +inputValue;\n\n// bad\nconst val = inputValue >> 0;\n\n// bad\nconst val = parseInt(inputValue);\n\n// good\nconst val = Number(inputValue);\n\n// good\nconst val = parseInt(inputValue, 10);\n```\n\n\n\n* [22.4](#coercion--comment-deviations) 如果出于某种原因，你正在做一些疯狂的事情，而 `parseInt` 是你的瓶颈，并且出于 [性能问题](https://jsperf.com/coercion-vs-casting/3) 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。\n```javascript\n// good\n/**\n * parseInt 使我的代码变慢。\n * 位运算将一个字符串转换成数字更快。\n */\nconst val = inputValue >> 0;\n```\n\n\n\n* [22.5](#coercion--bitwise) **注意：** 当你使用位运算的时候要小心。 数字总是被以 [64-bit 值](https://es5.github.io/#x4.3.19) 的形式表示，但是位运算总是返回一个 32-bit 的整数 ([来源](https://es5.github.io/#x11.7))。 对于大于 32 位的整数值，位运算可能会导致意外行为。[讨论](https://github.com/airbnb/javascript/issues/109)。 最大的 32 位整数是： 2,147,483,647。\n```javascript\n2147483647 >> 0; // => 2147483647\n2147483648 >> 0; // => -2147483648\n2147483649 >> 0; // => -2147483647\n```\n\n\n\n* [22.6](#coercion--booleans) 布尔类型： eslint: [`no-new-wrappers`](https://eslint.org/docs/rules/no-new-wrappers)\n```javascript\nconst age = 0;\n\n// bad\nconst hasAge = new Boolean(age);\n\n// good\nconst hasAge = Boolean(age);\n\n// best\nconst hasAge = !!age;\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"a3d10465\"></a>\n## [命名规范]()\n\n\n* [23.1](#naming--descriptive) 避免单字母的名字。用你的命名来描述功能。 eslint: [`id-length`](https://eslint.org/docs/rules/id-length)\n```javascript\n// bad\nfunction q() {\n  // ...\n}\n\n// good\nfunction query() {\n  // ...\n}\n```\n\n\n\n* [23.2](#naming--camelCase) 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: [`camelcase`](https://eslint.org/docs/rules/camelcase.html)\n```javascript\n// bad\nconst OBJEcttsssss = {};\nconst this_is_my_object = {};\nfunction c() {}\n\n// good\nconst thisIsMyObject = {};\nfunction thisIsMyFunction() {}\n```\n\n\n\n* [23.3](#naming--PascalCase) 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: [`new-cap`](https://eslint.org/docs/rules/new-cap.html)\n```javascript\n// bad\nfunction user(options) {\n  this.name = options.name;\n}\n\nconst bad = new user({\n  name: 'nope',\n});\n\n// good\nclass User {\n  constructor(options) {\n    this.name = options.name;\n  }\n}\n\nconst good = new User({\n  name: 'yup',\n});\n```\n\n\n\n* [23.4](#naming--leading-underscore) 不要使用前置或者后置下划线。 eslint: [`no-underscore-dangle`](https://eslint.org/docs/rules/no-underscore-dangle.html)\n> 为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。\n\n```javascript\n// bad\nthis.__firstName__ = 'Panda';\nthis.firstName_ = 'Panda';\nthis._firstName = 'Panda';\n\n// good\nthis.firstName = 'Panda';\n\n// 好，在 WeakMapx 可用的环境中\n// see https://kangax.github.io/compat-table/es6/#test-WeakMap\nconst firstNames = new WeakMap();\nfirstNames.set(this, 'Panda');\n```\n\n\n\n* [23.5](#naming--self-this) 不要保存 `this` 的引用。 使用箭头函数或者 [函数#bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind)。\n```javascript\n// bad\nfunction foo() {\n  const self = this;\n  return function () {\n    console.log(self);\n  };\n}\n\n// bad\nfunction foo() {\n  const that = this;\n  return function () {\n    console.log(that);\n  };\n}\n\n// good\nfunction foo() {\n  return () => {\n    console.log(this);\n  };\n}\n```\n\n\n\n* [23.6](#naming--filename-matches-export) 文件名应该和默认导出的名称完全匹配。\n```javascript\n// file 1 contents\nclass CheckBox {\n  // ...\n}\nexport default CheckBox;\n\n// file 2 contents\nexport default function fortyTwo() { return 42; }\n\n// file 3 contents\nexport default function insideDirectory() {}\n\n// in some other file\n// bad\nimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\nimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\nimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\n\n// bad\nimport CheckBox from './check_box'; // PascalCase import/export, snake_case filename\nimport forty_two from './forty_two'; // snake_case import/filename, camelCase export\nimport inside_directory from './inside_directory'; // snake_case import, camelCase export\nimport index from './inside_directory/index'; // requiring the index file explicitly\nimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\n\n// good\nimport CheckBox from './CheckBox'; // PascalCase export/import/filename\nimport fortyTwo from './fortyTwo'; // camelCase export/import/filename\nimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit \"index\"\n// ^ supports both insideDirectory.js and insideDirectory/index.js\n```\n\n\n\n* [23.7](#naming--camelCase-default-export) 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。\n```javascript\nfunction makeStyleGuide() {\n  // ...\n}\n\nexport default makeStyleGuide;\n```\n\n\n\n* [23.8](#naming--PascalCase-singleton) 当你导出一个构造器 / 类 / 单例 / 函数库 / 暴露的对象时应该使用帕斯卡命名法。\n```javascript\nconst AirbnbStyleGuide = {\n  es6: {\n  },\n};\n\nexport default AirbnbStyleGuide;\n```\n\n\n\n* [23.9](#naming--Acronyms-and-Initialisms) 缩略词和缩写都必须是全部大写或者全部小写。\n> 为什么? 名字是为了可读性，不是为了满足计算机算法。\n\n```javascript\n// bad\nimport SmsContainer from './containers/SmsContainer';\n\n// bad\nconst HttpRequests = [\n  // ...\n];\n\n// good\nimport SMSContainer from './containers/SMSContainer';\n\n// good\nconst HTTPRequests = [\n  // ...\n];\n\n// also good\nconst httpRequests = [\n  // ...\n];\n\n// best\nimport TextMessageContainer from './containers/TextMessageContainer';\n\n// best\nconst requests = [\n  // ...\n];\n```\n\n\n\n* [23.10](#naming--uppercase) 你可以大写一个常量，如果它：（1）被导出，（2）使用 `const` 定义（不能被重新赋值），（3）程序员可以信任它（以及其嵌套的属性）是不变的。\n> 为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。\n\n\n  * 是否是对所有的 `const` 定义的变量？ - 这个是没有必要的，不应该在文件中使用大写。但是，它应该用于导出常量。\n  * 导出对象呢？ - 在顶级导出属性 (e.g. `EXPORTED_OBJECT.key`) 并且保持所有嵌套属性不变。\n```javascript\n// bad\nconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\n\n// bad\nexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\n\n// bad\nexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\n\n// ---\n\n// 允许，但是不提供语义值\nexport const apiKey = 'SOMEKEY';\n\n// 多数情况下，很好\nexport const API_KEY = 'SOMEKEY';\n\n// ---\n\n// bad - 不必要大写 key 没有增加语义值\nexport const MAPPING = {\n  KEY: 'value'\n};\n\n// good\nexport const MAPPING = {\n  key: 'value'\n};\n```\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"cd92de2a\"></a>\n## [存取器]()\n\n\n* [24.1](#accessors--not-required) 对于属性的的存取函数不是必须的。\n\n\n* [24.2](#accessors--no-getters-setters) 不要使用 JavaScript 的 getters/setters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 `getVal()` 和 `setVal('hello')`。\n```javascript\n// bad\nclass Dragon {\n  get age() {\n    // ...\n  }\n\n  set age(value) {\n    // ...\n  }\n}\n\n// good\nclass Dragon {\n  getAge() {\n    // ...\n  }\n\n  setAge(value) {\n    // ...\n  }\n}\n```\n\n\n\n* [24.3](#accessors--boolean-prefix) 如果属性/方法是一个 `boolean` 值，使用 `isVal()` 或者 `hasVal()`。\n```javascript\n// bad\nif (!dragon.age()) {\n  return false;\n}\n\n// good\nif (!dragon.hasAge()) {\n  return false;\n}\n```\n\n\n\n* [24.4](#accessors--consistent) 可以创建 `get()` 和 `set()` 方法，但是要保证一致性。\n```javascript\nclass Jedi {\n  constructor(options = {}) {\n    const lightsaber = options.lightsaber || 'blue';\n    this.set('lightsaber', lightsaber);\n  }\n\n  set(key, val) {\n    this[key] = val;\n  }\n\n  get(key) {\n    return this[key];\n  }\n}\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"10b2761d\"></a>\n## [事件]()\n\n\n* [25.1](#events--hash) 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法：\n```javascript\n// bad\n$(this).trigger('listingUpdated', listing.id);\n\n// ...\n\n$(this).on('listingUpdated', (e, listingID) => {\n  // do something with listingID\n});\n```\n\n<br />更好的写法：\n```javascript\n// good\n$(this).trigger('listingUpdated', { listingID: listing.id });\n\n// ...\n\n$(this).on('listingUpdated', (e, data) => {\n  // do something with data.listingID\n});\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"jQuery\"></a>\n## jQuery\n\n\n* [26.1](#jquery--dollar-prefix) 对于 jQuery 对象的变量使用 `$` 作为前缀。\n```javascript\n// bad\nconst sidebar = $('.sidebar');\n\n// good\nconst $sidebar = $('.sidebar');\n\n// good\nconst $sidebarBtn = $('.sidebar-btn');\n```\n\n\n\n* [26.2](#jquery--cache) 缓存 jQuery 查询。\n```javascript\n// bad\nfunction setSidebar() {\n  $('.sidebar').hide();\n\n  // ...\n\n  $('.sidebar').css({\n    'background-color': 'pink',\n  });\n}\n\n// good\nfunction setSidebar() {\n  const $sidebar = $('.sidebar');\n  $sidebar.hide();\n\n  // ...\n\n  $sidebar.css({\n    'background-color': 'pink',\n  });\n}\n```\n\n\n\n* [26.3](#jquery--queries) 对于 DOM 查询使用层叠 `$('.sidebar ul')` 或 父元素 > 子元素 `$('.sidebar > ul')` 的格式。 [jsPerf](http://jsperf.com/jquery-find-vs-context-sel/16)\n\n\n* [26.4](#jquery--find) 对于有作用域的 jQuery 对象查询使用 `find` 。\n```javascript\n// bad\n$('ul', '.sidebar').hide();\n\n// bad\n$('.sidebar').find('ul').hide();\n\n// good\n$('.sidebar ul').hide();\n\n// good\n$('.sidebar > ul').hide();\n\n// good\n$sidebar.find('ul').hide();\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"b59ab4d6\"></a>\n## [ECMAScript 5 兼容性]()\n\n\n* [27.1](#es5-compat--kangax) 参考 [Kangax](https://twitter.com/kangax/)的 ES5 [兼容性表格](https://kangax.github.io/es5-compat-table/)。\n\n**[⬆ 返回目录](#table-of-contents)**\n\n\n<a name=\"c64dfd7d\"></a>\n## ECMAScript 6+ (ES 2015+) Styles\n\n\n* [28.1](#es6-styles) 这是一个链接到各种 ES6+ 特性的集合。\n\n1. [箭头函数](#arrow-functions)\n1. [类](#classes--constructors)\n1. [对象简写](#es6-object-shorthand)\n1. [对象简洁](#es6-object-concise)\n1. [对象计算属性](#es6-computed-properties)\n1. [字符串模板](#es6-template-literals)\n1. [解构](#destructuring)\n1. [默认参数](#es6-default-parameters)\n1. [Rest](#es6-rest)\n1. [数组展开](#es6-array-spreads)\n1. [Let 和 Const](#references)\n1. [求幂运算符](#es2016-properties--exponentiation-operator)\n1. [迭代器和发生器](#iterators-and-generators)\n1. [模块](#modules)\n\n\n* [28.2](#tc39-proposals) 不要使用尚未达到第3阶段的 [TC39 建议](https://github.com/tc39/proposals)。\n> 为什么? [它们没有最终确定](https://tc39.github.io/process-document/)， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。\n\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"dd970a1f\"></a>\n## [标准库]()\n\n[标准库](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects)<br />\n包含功能已损坏的实用工具，但因为遗留原因而保留。\n\n\n* [29.1](#standard-library--isnan) 使用 `Number.isNaN` 代替全局的 `isNaN`.<br />\neslint: [`no-restricted-globals`](https://eslint.org/docs/rules/no-restricted-globals)\n> 为什么? 全局的 `isNaN` 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。\n\n> 如果需要这种行为，请明确说明。\n\n```javascript\n// bad\nisNaN('1.2'); // false\nisNaN('1.2.3'); // true\n\n// good\nNumber.isNaN('1.2.3'); // false\nNumber.isNaN(Number('1.2.3')); // true\n```\n\n\n\n* [29.2](#standard-library--isfinite) 使用 `Number.isFinite` 代替全局的 `isFinite`.<br />\neslint: [`no-restricted-globals`](https://eslint.org/docs/rules/no-restricted-globals)\n> 为什么? 全局的 `isFinite` 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。\n\n> 如果需要这种行为，请明确说明。\n\n```javascript\n// bad\nisFinite('2e3'); // true\n\n// good\nNumber.isFinite('2e3'); // false\nNumber.isFinite(parseInt('2e3', 10)); // true\n```\n\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"Testing\"></a>\n## Testing\n\n\n* [30.1](#testing--yup) **是的.**\n```javascript\nfunction foo() {\n  return true;\n}\n```\n\n\n\n* [30.2](#testing--for-real) **没有，但是认真**:\n  * 无论你使用那种测试框架，都应该编写测试！\n  * 努力写出许多小的纯函数，并尽量减少发生错误的地方。\n  * 对于静态方法和 mock 要小心----它们会使你的测试更加脆弱。\n  * 我们主要在 Airbnb 上使用 [`mocha`](https://www.npmjs.com/package/mocha) 和 [`jest`](https://www.npmjs.com/package/jest) 。 [`tape`](https://www.npmjs.com/package/tape) 也会用在一些小的独立模块上。\n  * 100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。\n  * 无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"c3318eaa\"></a>\n## [性能]()\n\n* [On Layout & Web Performance](https://www.kellegous.com/j/2013/01/26/layout-performance/)\n* [String vs Array Concat](https://jsperf.com/string-vs-array-concat/2)\n* [Try/Catch Cost In a Loop](https://jsperf.com/try-catch-in-loop-cost)\n* [Bang Function](https://jsperf.com/bang-function)\n* [jQuery Find vs Context, Selector](https://jsperf.com/jquery-find-vs-context-sel/13)\n* [innerHTML vs textContent for script text](https://jsperf.com/innerhtml-vs-textcontent-for-script-text)\n* [Long String Concatenation](https://jsperf.com/ya-string-concat)\n* [Are Javascript functions like `map()`, `reduce()`, and `filter()` optimized for traversing arrays?](https://www.quora.com/JavaScript-programming-language-Are-Javascript-functions-like-map-reduce-and-filter-already-optimized-for-traversing-array/answer/Quildreen-Motta)\n* Loading...\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"eee83a92\"></a>\n## [资源]()\n\n**学习 ES6+**\n\n* [Latest ECMA spec](https://tc39.github.io/ecma262/)\n* [ExploringJS](http://exploringjs.com/)\n* [ES6 Compatibility Table](https://kangax.github.io/compat-table/es6/)\n* [Comprehensive Overview of ES6 Features](http://es6-features.org/)\n\n**读这个**\n\n* [Standard ECMA-262](http://www.ecma-international.org/ecma-262/6.0/index.html)\n\n**工具**\n\n* Code Style Linters\n  * [ESlint](https://eslint.org/) - [Airbnb Style .eslintrc](https://github.com/airbnb/javascript/blob/master/linters/.eslintrc)\n  * [JSHint](http://jshint.com/) - [Airbnb Style .jshintrc](https://github.com/airbnb/javascript/blob/master/linters/.jshintrc)\n* Neutrino preset - [neutrino-preset-airbnb-base](https://neutrino.js.org/presets/neutrino-preset-airbnb-base/)\n\n**其他编码规范**\n\n* [Google JavaScript Style Guide](https://google.github.io/styleguide/javascriptguide.xml)\n* [jQuery Core Style Guidelines](https://contribute.jquery.org/style-guide/js/)\n* [Principles of Writing Consistent, Idiomatic JavaScript](https://github.com/rwaldron/idiomatic.js)\n* [StandardJS](https://standardjs.com)\n\n**其他风格**\n\n* [Naming this in nested functions](https://gist.github.com/cjohansen/4135065) - Christian Johansen\n* [Conditional Callbacks](https://github.com/airbnb/javascript/issues/52) - Ross Allen\n* [Popular JavaScript Coding Conventions on GitHub](http://sideeffect.kr/popularconvention/#javascript) - JeongHoon Byun\n* [Multiple var statements in JavaScript, not superfluous](http://benalman.com/news/2012/05/multiple-var-statements-javascript/) - Ben Alman\n\n**进一步阅读**\n\n* [Understanding JavaScript Closures](https://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/) - Angus Croll\n* [Basic JavaScript for the impatient programmer](http://www.2ality.com/2013/06/basic-javascript.html) - Dr. Axel Rauschmayer\n* [You Might Not Need jQuery](http://youmightnotneedjquery.com/) - Zack Bloom & Adam Schwartz\n* [ES6 Features](https://github.com/lukehoban/es6features) - Luke Hoban\n* [Frontend Guidelines](https://github.com/bendc/frontend-guidelines) - Benjamin De Cock\n\n**书籍**\n\n* [JavaScript: The Good Parts](https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742) - Douglas Crockford\n* [JavaScript Patterns](https://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752) - Stoyan Stefanov\n* [Pro JavaScript Design Patterns](https://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X)  - Ross Harmes and Dustin Diaz\n* [High Performance Web Sites: Essential Knowledge for Front-End Engineers](https://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309) - Steve Souders\n* [Maintainable JavaScript](https://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680) - Nicholas C. Zakas\n* [JavaScript Web Applications](https://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X) - Alex MacCaw\n* [Pro JavaScript Techniques](https://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273) - John Resig\n* [Smashing Node.js: JavaScript Everywhere](https://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595) - Guillermo Rauch\n* [Secrets of the JavaScript Ninja](https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X) - John Resig and Bear Bibeault\n* [Human JavaScript](http://humanjavascript.com/) - Henrik Joreteg\n* [Superhero.js](http://superherojs.com/) - Kim Joar Bekkelund, Mads Mobæk, & Olav Bjorkoy\n* [JSBooks](http://jsbooks.revolunet.com/) - Julien Bouquillon\n* [Third Party JavaScript](https://www.manning.com/books/third-party-javascript) - Ben Vinegar and Anton Kovalyov\n* [Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript](http://amzn.com/0321812182) - David Herman\n* [Eloquent JavaScript](http://eloquentjavascript.net/) - Marijn Haverbeke\n* [You Don’t Know JS: ES6 & Beyond](http://shop.oreilly.com/product/0636920033769.do) - Kyle Simpson\n\n**博客**\n\n* [JavaScript Weekly](http://javascriptweekly.com/)\n* [JavaScript, JavaScript...](https://javascriptweblog.wordpress.com/)\n* [Bocoup Weblog](https://bocoup.com/weblog)\n* [Adequately Good](http://www.adequatelygood.com/)\n* [NCZOnline](https://www.nczonline.net/)\n* [Perfection Kills](http://perfectionkills.com/)\n* [Ben Alman](http://benalman.com/)\n* [Dmitry Baranovskiy](http://dmitry.baranovskiy.com/)\n* [nettuts](http://code.tutsplus.com/?s=javascript)\n\n**播客**\n\n* [JavaScript Air](https://javascriptair.com/)\n* [JavaScript Jabber](https://devchat.tv/js-jabber/)\n\n**[⬆ 返回目录](#table-of-contents)**\n\n<a name=\"935a8bc4\"></a>\n## [JavaScript风格指南的指南]()\n\n* [Reference](https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide)\n\n<a name=\"20a28457\"></a>\n## [许可证]()\n\n(The MIT License)\n\nCopyright (c) 2012 康兵奎\n\nPermission is hereby granted, free of charge, to any person obtaining<br />\na copy of this software and associated documentation files (the<br />\n'Software'), to deal in the Software without restriction, including<br />\nwithout limitation the rights to use, copy, modify, merge, publish,<br />\ndistribute, sublicense, and/or sell copies of the Software, and to<br />\npermit persons to whom the Software is furnished to do so, subject to<br />\nthe following conditions:\n\nThe above copyright notice and this permission notice shall be<br />\nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,<br />\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF<br />\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.<br />\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY<br />\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<br />\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE<br />\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n**[⬆ 返回目录](#table-of-contents)**\n<a name=\"d41d8cd9\"></a>\n## \n",
    "body_draft": "",
    "body_html": "<p><u>转自 https://github.com/BingKui/javascript-zh</u></p><p><br /></p><p><em>一种写JavaScript更合理的代码风格。</em></p><p><br /></p><blockquote><p><strong>Note</strong>: 本指南假设你使用了 <a href=\"https://babeljs.io\" target=\"_blank\">Babel</a>, 并且要求你使用 <a href=\"https://npmjs.com/babel-preset-airbnb\" target=\"_blank\">babel-preset-airbnb</a> 或者其他同等资源。 并且假设你在你的应用中安装了 shims/polyfills ，使用<a href=\"https://npmjs.com/airbnb-browser-shims\" target=\"_blank\">airbnb-browser-shims</a> 或者相同功能。</p></blockquote><p>其他代码风格指南</p><p><br /></p><ul><li><a href=\"https://github.com/airbnb/javascript/tree/es5-deprecated/es5\" target=\"_blank\">ES5 (Deprecated)</a></li></ul><ul><li><a href=\"react/\">React</a></li></ul><ul><li><a href=\"css-in-javascript/\">CSS-in-JavaScript</a></li></ul><ul><li><a href=\"https://github.com/airbnb/css\" target=\"_blank\">CSS &amp; Sass</a></li></ul><ul><li><a href=\"https://github.com/airbnb/ruby\" target=\"_blank\">Ruby</a></li></ul><p><br /></p><h2 id=\"767fa455\"><a>目录</a></h2><p><br /></p><ol start=\"1\"><li><a href=\"#types\">类型</a></li></ol><ol start=\"2\"><li><a href=\"#references\">引用</a></li></ol><ol start=\"3\"><li><a href=\"#objects\">对象</a></li></ol><ol start=\"4\"><li><a href=\"#arrays\">数组</a></li></ol><ol start=\"5\"><li><a href=\"#destructuring\">解构</a></li></ol><ol start=\"6\"><li><a href=\"#strings\">字符</a></li></ol><ol start=\"7\"><li><a href=\"#functions\">方法</a></li></ol><ol start=\"8\"><li><a href=\"#arrow-functions\">箭头函数</a></li></ol><ol start=\"9\"><li><a href=\"#classes--constructors\">类和构造器</a></li></ol><ol start=\"10\"><li><a href=\"#modules\">模块</a></li></ol><ol start=\"11\"><li><a href=\"#iterators-and-generators\">迭代器和发生器</a></li></ol><ol start=\"12\"><li><a href=\"#properties\">属性</a></li></ol><ol start=\"13\"><li><a href=\"#variables\">变量</a></li></ol><ol start=\"14\"><li><a href=\"#hoisting\">提升</a></li></ol><ol start=\"15\"><li><a href=\"#comparison-operators--equality\">比较运算符和等号</a></li></ol><ol start=\"16\"><li><a href=\"#blocks\">块</a></li></ol><ol start=\"17\"><li><a href=\"#control-statements\">控制语句</a></li></ol><ol start=\"18\"><li><a href=\"#comments\">注释</a></li></ol><ol start=\"19\"><li><a href=\"#whitespace\">空白</a></li></ol><ol start=\"20\"><li><a href=\"#commas\">逗号</a></li></ol><ol start=\"21\"><li><a href=\"#semicolons\">分号</a></li></ol><ol start=\"22\"><li><a href=\"#type-casting--coercion\">类型转换和强制类型转换</a></li></ol><ol start=\"23\"><li><a href=\"#naming-conventions\">命名规范</a></li></ol><ol start=\"24\"><li><a href=\"#accessors\">存取器</a></li></ol><ol start=\"25\"><li><a href=\"#events\">事件</a></li></ol><ol start=\"26\"><li><a href=\"#jquery\">jQuery</a></li></ol><ol start=\"27\"><li><a href=\"#ecmascript-5-compatibility\">ECMAScript 5 兼容性</a></li></ol><ol start=\"28\"><li><a href=\"#ecmascript-6-es-2015-styles\">ECMAScript 6+ (ES 2015+) 风格</a></li></ol><ol start=\"29\"><li><a href=\"#standard-library\">标准库</a></li></ol><ol start=\"30\"><li><a href=\"#testing\">测试</a></li></ol><ol start=\"31\"><li><a href=\"#performance\">性能</a></li></ol><ol start=\"32\"><li><a href=\"#resources\">资源</a></li></ol><ol start=\"33\"><li><a href=\"#the-javascript-style-guide-guide\">JavaScript风格指南的指南</a></li></ol><ol start=\"34\"><li><a href=\"#license\">许可证</a></li></ol><ol start=\"35\"><li><a href=\"#amendments\">修正案</a></li></ol><p><br /></p><h2 id=\"226b0912\"><a>类型</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#types--primitives\">1.1</a> <strong>原始值</strong>: 当你访问一个原始类型的时候，你可以直接使用它的值。</li></ul><ul data-lake-indent=\"1\"><li><code>string</code></li></ul><ul data-lake-indent=\"1\"><li><code>number</code></li></ul><ul data-lake-indent=\"1\"><li><code>boolean</code></li></ul><ul data-lake-indent=\"1\"><li><code>null</code></li></ul><ul data-lake-indent=\"1\"><li><code>undefined</code></li></ul><ul data-lake-indent=\"1\"><li><code>symbol</code></li></ul><pre data-lang=\"javascript\"><code>const foo = 1;\nlet bar = foo;\n\nbar = 9;\n\nconsole.log(foo, bar); // =&gt; 1, 9</code></pre><ul data-lake-indent=\"1\"><li>标识符不能完全被支持，因此在针对不支持的浏览器或者环境时不应该使用它们。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#types--complex\">1.2</a>  <strong>复杂类型</strong>: 当你访问一个复杂类型的时候，你需要一个值得引用。</li></ul><ul data-lake-indent=\"1\"><li><code>object</code></li></ul><ul data-lake-indent=\"1\"><li><code>array</code></li></ul><ul data-lake-indent=\"1\"><li><code>function</code></li></ul><pre data-lang=\"javascript\"><code>const foo = [1, 2];\nconst bar = foo;\n\nbar[0] = 9;\n\nconsole.log(foo[0], bar[0]); // =&gt; 9, 9</code></pre><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"3b61c966\"><a>引用</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#references--prefer-const\">2.1</a> 使用 <code>const</code> 定义你的所有引用；避免使用 <code>var</code>。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-const.html\" target=\"_blank\"><code>prefer-const</code></a>, <a href=\"https://eslint.org/docs/rules/no-const-assign.html\" target=\"_blank\"><code>no-const-assign</code></a>\n<blockquote><p>为什么? 这样能够确保你不能重新赋值你的引用，否则可能导致错误或者产生难以理解的代码。.</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nvar a = 1;\nvar b = 2;\n\n// good\nconst a = 1;\nconst b = 2;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#references--disallow-var\">2.2</a> 如果你必须重新赋值你的引用， 使用 <code>let</code> 代替 <code>var</code>。 eslint: <a href=\"https://eslint.org/docs/rules/no-var.html\" target=\"_blank\"><code>no-var</code></a>\n<blockquote><p>为什么? <code>let</code> 是块级作用域，而不像 <code>var</code> 是函数作用域.</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nvar count = 1;\nif (true) {\n  count += 1;\n}\n\n// good, use the let.\nlet count = 1;\nif (true) {\n  count += 1;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#references--block-scope\">2.3</a> 注意，let 和 const 都是块级范围的。\n<pre data-lang=\"javascript\"><code>// const 和 let 只存在于他们定义的块中。\n{\n  let a = 1;\n  const b = 1;\n}\nconsole.log(a); // ReferenceError\nconsole.log(b); // ReferenceError</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"b1449413\"><a>对象</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#objects--no-new\">3.1</a> 使用字面语法来创建对象。 eslint: <a href=\"https://eslint.org/docs/rules/no-new-object.html\" target=\"_blank\"><code>no-new-object</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst item = new Object();\n\n// good\nconst item = {};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-computed-properties\">3.2</a> 在创建具有动态属性名称的对象时使用计算属性名。\n<blockquote><p>为什么? 它允许你在一个地方定义对象的所有属性。</p></blockquote><pre data-lang=\"javascript\"><code>function getKey(k) {\n  return `a key named ${k}`;\n}\n\n// bad\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n};\nobj[getKey('enabled')] = true;\n\n// good\nconst obj = {\n  id: 5,\n  name: 'San Francisco',\n  [getKey('enabled')]: true,\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-object-shorthand\">3.3</a> 使用对象方法的缩写。 eslint: <a href=\"https://eslint.org/docs/rules/object-shorthand.html\" target=\"_blank\"><code>object-shorthand</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst atom = {\n  value: 1,\n\n  addValue: function (value) {\n    return atom.value + value;\n  },\n};\n\n// good\nconst atom = {\n  value: 1,\n\n  addValue(value) {\n    return atom.value + value;\n  },\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-object-concise\">3.4</a> 使用属性值的缩写。 eslint: <a href=\"https://eslint.org/docs/rules/object-shorthand.html\" target=\"_blank\"><code>object-shorthand</code></a>\n<blockquote><p>为什么? 它的写法和描述较短。</p></blockquote><pre data-lang=\"javascript\"><code>const lukeSkywalker = 'Luke Skywalker';\n\n// bad\nconst obj = {\n  lukeSkywalker: lukeSkywalker,\n};\n\n// good\nconst obj = {\n  lukeSkywalker,\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--grouped-shorthand\">3.5</a> 在对象声明的时候将简写的属性进行分组。\n<blockquote><p>为什么? 这样更容易的判断哪些属性使用的简写。</p></blockquote><pre data-lang=\"javascript\"><code>const anakinSkywalker = 'Anakin Skywalker';\nconst lukeSkywalker = 'Luke Skywalker';\n\n// bad\nconst obj = {\n  episodeOne: 1,\n  twoJediWalkIntoACantina: 2,\n  lukeSkywalker,\n  episodeThree: 3,\n  mayTheFourth: 4,\n  anakinSkywalker,\n};\n\n// good\nconst obj = {\n  lukeSkywalker,\n  anakinSkywalker,\n  episodeOne: 1,\n  twoJediWalkIntoACantina: 2,\n  episodeThree: 3,\n  mayTheFourth: 4,\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--quoted-props\">3.6</a> 只使用引号标注无效标识符的属性。 eslint: <a href=\"https://eslint.org/docs/rules/quote-props.html\" target=\"_blank\"><code>quote-props</code></a>\n<blockquote><p>为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst bad = {\n  'foo': 3,\n  'bar': 4,\n  'data-blah': 5,\n};\n\n// good\nconst good = {\n  foo: 3,\n  bar: 4,\n  'data-blah': 5,\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--prototype-builtins\">3.7</a> 不能直接调用 <code>Object.prototype</code> 的方法，如： <code>hasOwnProperty</code> 、 <code>propertyIsEnumerable</code> 和 <code>isPrototypeOf</code>。\n<blockquote><p>为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 <code>{ hasOwnProperty: false }</code> - 或者，对象是一个空对象 (<code>Object.create(null)</code>)。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconsole.log(object.hasOwnProperty(key));\n\n// good\nconsole.log(Object.prototype.hasOwnProperty.call(object, key));\n\n// best\nconst has = Object.prototype.hasOwnProperty; // 在模块范围内的缓存中查找一次\n/* or */\nimport has from 'has'; // https://www.npmjs.com/package/has\n// ...\nconsole.log(has.call(object, key));</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--rest-spread\">3.8</a> 更喜欢对象扩展操作符，而不是用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\"><code>Object.assign</code></a> 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。\n<pre data-lang=\"javascript\"><code>// very bad\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign(original, { c: 3 }); // 变异的 `original` ಠ_ಠ\ndelete copy.a; // 这....\n\n// bad\nconst original = { a: 1, b: 2 };\nconst copy = Object.assign({}, original, { c: 3 }); // copy =&gt; { a: 1, b: 2, c: 3 }\n\n// good\nconst original = { a: 1, b: 2 };\nconst copy = { ...original, c: 3 }; // copy =&gt; { a: 1, b: 2, c: 3 }\n\nconst { a, ...noA } = copy; // noA =&gt; { b: 2, c: 3 }</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"0e67d4b0\"><a>数组</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--literals\">4.1</a> 使用字面语法创建数组。 eslint: <a href=\"https://eslint.org/docs/rules/no-array-constructor.html\" target=\"_blank\"><code>no-array-constructor</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst items = new Array();\n\n// good\nconst items = [];</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--push\">4.2</a> 使用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push\" target=\"_blank\">Array#push</a> 取代直接赋值来给数组添加项。\n<pre data-lang=\"javascript\"><code>const someStack = [];\n\n// bad\nsomeStack[someStack.length] = 'abracadabra';\n\n// good\nsomeStack.push('abracadabra');</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-array-spreads\">4.3</a> 使用数组展开方法 <code>...</code> 来拷贝数组。\n<pre data-lang=\"javascript\"><code>// bad\nconst len = items.length;\nconst itemsCopy = [];\nlet i;\n\nfor (i = 0; i &lt; len; i += 1) {\n  itemsCopy[i] = items[i];\n}\n\n// good\nconst itemsCopy = [...items];</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--from\">4.4</a> 将一个类数组对象转换成一个数组， 使用展开方法 <code>...</code> 代替 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\"><code>Array.from</code></a>。\n<pre data-lang=\"javascript\"><code>const foo = document.querySelectorAll('.foo');\n\n// good\nconst nodes = Array.from(foo);\n\n// best\nconst nodes = [...foo];</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--mapping\">4.5</a> 对于对迭代器的映射，使用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\">Array.from</a> 替代展开方法 <code>...</code> ， 因为它避免了创建中间数组。\n<pre data-lang=\"javascript\"><code>// bad\nconst baz = [...foo].map(bar);\n\n// good\nconst baz = Array.from(foo, bar);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--callback-return\">4.6</a> 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 <a href=\"#arrows--implicit-return\">8.2</a>。 eslint: <a href=\"https://eslint.org/docs/rules/array-callback-return\" target=\"_blank\"><code>array-callback-return</code></a>\n<pre data-lang=\"javascript\"><code>// good\n[1, 2, 3].map((x) =&gt; {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map(x =&gt; x + 1);\n\n// bad - 没有返回值，意味着在第一次迭代后 `acc` 没有被定义\n[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; {\n  const flatten = acc.concat(item);\n  acc[index] = flatten;\n});\n\n// good\n[[0, 1], [2, 3], [4, 5]].reduce((acc, item, index) =&gt; {\n  const flatten = acc.concat(item);\n  acc[index] = flatten;\n  return flatten;\n});\n\n// bad\ninbox.filter((msg) =&gt; {\n  const { subject, author } = msg;\n  if (subject === 'Mockingbird') {\n    return author === 'Harper Lee';\n  } else {\n    return false;\n  }\n});\n\n// good\ninbox.filter((msg) =&gt; {\n  const { subject, author } = msg;\n  if (subject === 'Mockingbird') {\n    return author === 'Harper Lee';\n  }\n\n  return false;\n});</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--bracket-newline\">4.7</a> 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。\n<pre data-lang=\"javascript\"><code>// bad\nconst arr = [\n  [0, 1], [2, 3], [4, 5],\n];\n\nconst objectInArray = [{\n  id: 1,\n}, {\n  id: 2,\n}];\n\nconst numberInArray = [\n  1, 2,\n];\n\n// good\nconst arr = [[0, 1], [2, 3], [4, 5]];\n\nconst objectInArray = [\n  {\n    id: 1,\n  },\n  {\n    id: 2,\n  },\n];\n\nconst numberInArray = [\n  1,\n  2,\n];</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"2be143d5\"><a>解构</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#destructuring--object\">5.1</a> 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-destructuring\" target=\"_blank\"><code>prefer-destructuring</code></a>\n<blockquote><p>为什么? 解构可以避免为这些属性创建临时引用。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction getFullName(user) {\n  const firstName = user.firstName;\n  const lastName = user.lastName;\n\n  return `${firstName} ${lastName}`;\n}\n\n// good\nfunction getFullName(user) {\n  const { firstName, lastName } = user;\n  return `${firstName} ${lastName}`;\n}\n\n// best\nfunction getFullName({ firstName, lastName }) {\n  return `${firstName} ${lastName}`;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#destructuring--array\">5.2</a> 使用数组解构。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-destructuring\" target=\"_blank\"><code>prefer-destructuring</code></a>\n<pre data-lang=\"javascript\"><code>const arr = [1, 2, 3, 4];\n\n// bad\nconst first = arr[0];\nconst second = arr[1];\n\n// good\nconst [first, second] = arr;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#destructuring--object-over-array\">5.3</a> 对于多个返回值使用对象解构，而不是数组解构。\n<blockquote><p>为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction processInput(input) {\n  // 处理代码...\n  return [left, right, top, bottom];\n}\n\n// 调用者需要考虑返回数据的顺序。\nconst [left, __, top] = processInput(input);\n\n// good\nfunction processInput(input) {\n  // 处理代码...\n  return { left, right, top, bottom };\n}\n\n// 调用者只选择他们需要的数据。\nconst { left, top } = processInput(input);</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"9c07532d\"><a>字符</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#strings--quotes\">6.1</a> 使用单引号 <code>''</code> 定义字符串。 eslint: <a href=\"https://eslint.org/docs/rules/quotes.html\" target=\"_blank\"><code>quotes</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst name = &quot;Capt. Janeway&quot;;\n\n// bad - 模板文字应该包含插值或换行。\nconst name = `Capt. Janeway`;\n\n// good\nconst name = 'Capt. Janeway';</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#strings--line-length\">6.2</a> 使行超过100个字符的字符串不应使用字符串连接跨多行写入。\n<blockquote><p>为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst errorMessage = 'This is a super long error that was thrown because \\\nof Batman. When you stop to think about how Batman had anything to do \\\nwith this, you would get nowhere \\\nfast.';\n\n// bad\nconst errorMessage = 'This is a super long error that was thrown because ' +\n  'of Batman. When you stop to think about how Batman had anything to do ' +\n  'with this, you would get nowhere fast.';\n\n// good\nconst errorMessage = 'This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.';</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-template-literals\">6.3</a> 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-template.html\" target=\"_blank\"><code>prefer-template</code></a> <a href=\"https://eslint.org/docs/rules/template-curly-spacing\" target=\"_blank\"><code>template-curly-spacing</code></a>\n<blockquote><p>为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction sayHi(name) {\n  return 'How are you, ' + name + '?';\n}\n\n// bad\nfunction sayHi(name) {\n  return ['How are you, ', name, '?'].join();\n}\n\n// bad\nfunction sayHi(name) {\n  return `How are you, ${ name }?`;\n}\n\n// good\nfunction sayHi(name) {\n  return `How are you, ${name}?`;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#strings--eval\">6.4</a> 不要在字符串上使用 <code>eval()</code> ，它打开了太多漏洞。 eslint: <a href=\"https://eslint.org/docs/rules/no-eval\" target=\"_blank\"><code>no-eval</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#strings--escaping\">6.5</a> 不要转义字符串中不必要的字符。 eslint: <a href=\"https://eslint.org/docs/rules/no-useless-escape\" target=\"_blank\"><code>no-useless-escape</code></a>\n<blockquote><p>为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst foo = '\\'this\\' \\i\\s \\&quot;quoted\\&quot;';\n\n// good\nconst foo = '\\'this\\' is &quot;quoted&quot;';\nconst foo = `my name is '${name}'`;</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ea340b9d\"><a>方法</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#functions--declarations\">7.1</a> 使用命名的函数表达式代替函数声明。 eslint: <a href=\"https://eslint.org/docs/rules/func-style\" target=\"_blank\"><code>func-style</code></a>\n<blockquote><p>为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 (<a href=\"https://github.com/airbnb/javascript/issues/794\" target=\"_blank\">Discussion</a>)</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction foo() {\n  // ...\n}\n\n// bad\nconst foo = function () {\n  // ...\n};\n\n// good\n// 从变量引用调用中区分的词汇名称\nconst short = function longUniqueMoreDescriptiveLexicalFoo() {\n  // ...\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--iife\">7.2</a> Wrap立即调用函数表达式。 eslint: <a href=\"https://eslint.org/docs/rules/wrap-iife.html\" target=\"_blank\"><code>wrap-iife</code></a>\n<blockquote><p>为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。</p></blockquote><pre data-lang=\"javascript\"><code>// immediately-invoked function expression (IIFE) 立即调用的函数表达式\n(function () {\n  console.log('Welcome to the Internet. Please follow me.');\n}());</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--in-blocks\">7.3</a> 切记不要在非功能块中声明函数 (<code>if</code>, <code>while</code>, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: <a href=\"https://eslint.org/docs/rules/no-loop-func.html\" target=\"_blank\"><code>no-loop-func</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--note-on-blocks\">7.4</a> <strong>注意:</strong> ECMA-262 将 <code>block</code> 定义为语句列表。 函数声明不是语句。\n<pre data-lang=\"javascript\"><code>// bad\nif (currentUser) {\n  function test() {\n    console.log('Nope.');\n  }\n}\n\n// good\nlet test;\nif (currentUser) {\n  test = () =&gt; {\n    console.log('Yup.');\n  };\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--arguments-shadow\">7.5</a> 永远不要定义一个参数为 <code>arguments</code>。 这将会优先于每个函数给定范围的 <code>arguments</code> 对象。\n<pre data-lang=\"javascript\"><code>// bad\nfunction foo(name, options, arguments) {\n  // ...\n}\n\n// good\nfunction foo(name, options, args) {\n  // ...\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-rest\">7.6</a> 不要使用 <code>arguments</code>, 选择使用 rest 语法 <code>...</code> 代替。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-rest-params\" target=\"_blank\"><code>prefer-rest-params</code></a>\n<blockquote><p>为什么? <code>...</code> 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 <code>arguments</code> 。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction concatenateAll() {\n  const args = Array.prototype.slice.call(arguments);\n  return args.join('');\n}\n\n// good\nfunction concatenateAll(...args) {\n  return args.join('');\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-default-parameters\">7.7</a> 使用默认的参数语法，而不是改变函数参数。\n<pre data-lang=\"javascript\"><code>// really bad\nfunction handleThings(opts) {\n  // No! We shouldn’t mutate function arguments.\n  // Double bad: if opts is falsy it'll be set to an object which may\n  // be what you want but it can introduce subtle bugs.\n  opts = opts || {};\n  // ...\n}\n\n// still bad\nfunction handleThings(opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  // ...\n}\n\n// good\nfunction handleThings(opts = {}) {\n  // ...\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--default-side-effects\">7.8</a> 避免使用默认参数的副作用。\n<blockquote><p>为什么? 他们很容易混淆。</p></blockquote><pre data-lang=\"javascript\"><code>var b = 1;\n// bad\nfunction count(a = b++) {\n  console.log(a);\n}\ncount();  // 1\ncount();  // 2\ncount(3); // 3\ncount();  // 3</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--defaults-last\">7.9</a> 总是把默认参数放在最后。\n<pre data-lang=\"javascript\"><code>// bad\nfunction handleThings(opts = {}, name) {\n  // ...\n}\n\n// good\nfunction handleThings(name, opts = {}) {\n  // ...\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--constructor\">7.10</a> 永远不要使用函数构造器来创建一个新函数。 eslint: <a href=\"https://eslint.org/docs/rules/no-new-func\" target=\"_blank\"><code>no-new-func</code></a>\n<blockquote><p>为什么? 以这种方式创建一个函数将对一个类似于 <code>eval()</code> 的字符串进行计算，这将打开漏洞。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nvar add = new Function('a', 'b', 'return a + b');\n\n// still bad\nvar subtract = Function('a', 'b', 'return a - b');</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--signature-spacing\">7.11</a> 函数签名中的间距。 eslint: <a href=\"https://eslint.org/docs/rules/space-before-function-paren\" target=\"_blank\"><code>space-before-function-paren</code></a> <a href=\"https://eslint.org/docs/rules/space-before-blocks\" target=\"_blank\"><code>space-before-blocks</code></a>\n<blockquote><p>为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst f = function(){};\nconst g = function (){};\nconst h = function() {};\n\n// good\nconst x = function () {};\nconst y = function a() {};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--mutate-params\">7.12</a> 没用变异参数。 eslint: <a href=\"https://eslint.org/docs/rules/no-param-reassign.html\" target=\"_blank\"><code>no-param-reassign</code></a>\n<blockquote><p>为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction f1(obj) {\n  obj.key = 1;\n}\n\n// good\nfunction f2(obj) {\n  const key = Object.prototype.hasOwnProperty.call(obj, 'key') ? obj.key : 1;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--reassign-params\">7.13</a> 不要再赋值参数。 eslint: <a href=\"https://eslint.org/docs/rules/no-param-reassign.html\" target=\"_blank\"><code>no-param-reassign</code></a>\n<blockquote><p>为什么? 重新赋值参数会导致意外的行为，尤其是在访问 <code>arguments</code> 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction f1(a) {\n  a = 1;\n  // ...\n}\n\nfunction f2(a) {\n  if (!a) { a = 1; }\n  // ...\n}\n\n// good\nfunction f3(a) {\n  const b = a || 1;\n  // ...\n}\n\nfunction f4(a = 1) {\n  // ...\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--spread-vs-apply\">7.14</a> 优先使用扩展运算符 <code>...</code> 来调用可变参数函数。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-spread\" target=\"_blank\"><code>prefer-spread</code></a>\n<blockquote><p>为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 <code>apply</code> 来 <code>new</code> 。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst x = [1, 2, 3, 4, 5];\nconsole.log.apply(console, x);\n\n// good\nconst x = [1, 2, 3, 4, 5];\nconsole.log(...x);\n\n// bad\nnew (Function.prototype.bind.apply(Date, [null, 2016, 8, 5]));\n\n// good\nnew Date(...[2016, 8, 5]);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--signature-invocation-indentation\">7.15</a> 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: <a href=\"https://eslint.org/docs/rules/function-paren-newline\" target=\"_blank\"><code>function-paren-newline</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction foo(bar,\n             baz,\n             quux) {\n  // ...\n}\n\n// good\nfunction foo(\n  bar,\n  baz,\n  quux,\n) {\n  // ...\n}\n\n// bad\nconsole.log(foo,\n  bar,\n  baz);\n\n// good\nconsole.log(\n  foo,\n  bar,\n  baz,\n);</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"d86f8699\"><a>箭头函数</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--use-them\">8.1</a> 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-arrow-callback.html\" target=\"_blank\"><code>prefer-arrow-callback</code></a>, <a href=\"https://eslint.org/docs/rules/arrow-spacing.html\" target=\"_blank\"><code>arrow-spacing</code></a>\n<blockquote><p>为什么? 它创建了一个在 <code>this</code> 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。</p></blockquote><blockquote><p>为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n[1, 2, 3].map(function (x) {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map((x) =&gt; {\n  const y = x + 1;\n  return x * y;\n});</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--implicit-return\">8.2</a> 如果函数体包含一个单独的语句，返回一个没有副作用的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions\" target=\"_blank\">expression</a> ， 省略括号并使用隐式返回。否则，保留括号并使用 <code>return</code> 语句。 eslint: <a href=\"https://eslint.org/docs/rules/arrow-parens.html\" target=\"_blank\"><code>arrow-parens</code></a>, <a href=\"https://eslint.org/docs/rules/arrow-body-style.html\" target=\"_blank\"><code>arrow-body-style</code></a>\n<blockquote><p>为什么? 语法糖。 多个函数被链接在一起时，提高可读性。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n[1, 2, 3].map(number =&gt; {\n  const nextNumber = number + 1;\n  `A string containing the ${nextNumber}.`;\n});\n\n// good\n[1, 2, 3].map(number =&gt; `A string containing the ${number}.`);\n\n// good\n[1, 2, 3].map((number) =&gt; {\n  const nextNumber = number + 1;\n  return `A string containing the ${nextNumber}.`;\n});\n\n// good\n[1, 2, 3].map((number, index) =&gt; ({\n  [index]: number,\n}));\n\n// 没有副作用的隐式返回\nfunction foo(callback) {\n  const val = callback();\n  if (val === true) {\n    // 如果回调返回 true 执行\n  }\n}\n\nlet bool = false;\n\n// bad\nfoo(() =&gt; bool = true);\n\n// good\nfoo(() =&gt; {\n  bool = true;\n});</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--paren-wrap\">8.3</a> 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n<blockquote><p>为什么? 它清楚地显示了函数的起点和终点。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n['get', 'post', 'put'].map(httpMethod =&gt; Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod,\n  )\n);\n\n// good\n['get', 'post', 'put'].map(httpMethod =&gt; (\n  Object.prototype.hasOwnProperty.call(\n    httpMagicObjectWithAVeryLongName,\n    httpMethod,\n  )\n));</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--one-arg-parens\">8.4</a> 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 <a href=\"https://eslint.org/docs/rules/arrow-parens#always\" target=\"_blank\">“always” option</a> 来配置 eslint. eslint: <a href=\"https://eslint.org/docs/rules/arrow-parens.html\" target=\"_blank\"><code>arrow-parens</code></a>\n<blockquote><p>为什么? 减少视觉上的混乱。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n[1, 2, 3].map((x) =&gt; x * x);\n\n// good\n[1, 2, 3].map(x =&gt; x * x);\n\n// good\n[1, 2, 3].map(number =&gt; (\n  `A long string with the ${number}. It’s so long that we don’t want it to take up space on the .map line!`\n));\n\n// bad\n[1, 2, 3].map(x =&gt; {\n  const y = x + 1;\n  return x * y;\n});\n\n// good\n[1, 2, 3].map((x) =&gt; {\n  const y = x + 1;\n  return x * y;\n});</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--confusing\">8.5</a> 避免箭头函数符号 (<code>=&gt;</code>) 和比较运算符 (<code>&lt;=</code>, <code>&gt;=</code>) 的混淆。 eslint: <a href=\"https://eslint.org/docs/rules/no-confusing-arrow\" target=\"_blank\"><code>no-confusing-arrow</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst itemHeight = item =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;\n\n// bad\nconst itemHeight = (item) =&gt; item.height &gt; 256 ? item.largeSize : item.smallSize;\n\n// good\nconst itemHeight = item =&gt; (item.height &gt; 256 ? item.largeSize : item.smallSize);\n\n// good\nconst itemHeight = (item) =&gt; {\n  const { height, largeSize, smallSize } = item;\n  return height &gt; 256 ? largeSize : smallSize;\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--implicit-arrow-linebreak\">8.6</a> 注意带有隐式返回的箭头函数函数体的位置。 eslint: <a href=\"https://eslint.org/docs/rules/implicit-arrow-linebreak\" target=\"_blank\"><code>implicit-arrow-linebreak</code></a>\n<pre data-lang=\"javascript\"><code>// bad\n(foo) =&gt;\n  bar;\n\n(foo) =&gt;\n  (bar);\n\n// good\n(foo) =&gt; bar;\n(foo) =&gt; (bar);\n(foo) =&gt; (\n   bar\n)</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"93d5dc10\"><a>类和构造器</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--use-class\">9.1</a> 尽量使用 <code>class</code>. 避免直接操作 <code>prototype</code> .\n<blockquote><p>为什么? <code>class</code> 语法更简洁，更容易推理。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction Queue(contents = []) {\n  this.queue = [...contents];\n}\nQueue.prototype.pop = function () {\n  const value = this.queue[0];\n  this.queue.splice(0, 1);\n  return value;\n};\n\n// good\nclass Queue {\n  constructor(contents = []) {\n    this.queue = [...contents];\n  }\n  pop() {\n    const value = this.queue[0];\n    this.queue.splice(0, 1);\n    return value;\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--extends\">9.2</a> 使用 <code>extends</code> 来扩展继承。\n<blockquote><p>为什么? 它是一个内置的方法，可以在不破坏 <code>instanceof</code> 的情况下继承原型功能。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst inherits = require('inherits');\nfunction PeekableQueue(contents) {\n  Queue.apply(this, contents);\n}\ninherits(PeekableQueue, Queue);\nPeekableQueue.prototype.peek = function () {\n  return this.queue[0];\n};\n\n// good\nclass PeekableQueue extends Queue {\n  peek() {\n    return this.queue[0];\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--chaining\">9.3</a> 方法返回了 <code>this</code> 来供其内部方法调用。\n<pre data-lang=\"javascript\"><code>// bad\nJedi.prototype.jump = function () {\n  this.jumping = true;\n  return true;\n};\n\nJedi.prototype.setHeight = function (height) {\n  this.height = height;\n};\n\nconst luke = new Jedi();\nluke.jump(); // =&gt; true\nluke.setHeight(20); // =&gt; undefined\n\n// good\nclass Jedi {\n  jump() {\n    this.jumping = true;\n    return this;\n  }\n\n  setHeight(height) {\n    this.height = height;\n    return this;\n  }\n}\n\nconst luke = new Jedi();\n\nluke.jump()\n  .setHeight(20);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--tostring\">9.4</a> 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 <code>toString()</code> 方法也是可以的。\n<pre data-lang=\"javascript\"><code>class Jedi {\n  constructor(options = {}) {\n    this.name = options.name || 'no name';\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  toString() {\n    return `Jedi - ${this.getName()}`;\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--no-useless\">9.5</a> 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: <a href=\"https://eslint.org/docs/rules/no-useless-constructor\" target=\"_blank\"><code>no-useless-constructor</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nclass Jedi {\n  constructor() {}\n\n  getName() {\n    return this.name;\n  }\n}\n\n// bad\nclass Rey extends Jedi {\n  constructor(...args) {\n    super(...args);\n  }\n}\n\n// good\nclass Rey extends Jedi {\n  constructor(...args) {\n    super(...args);\n    this.name = 'Rey';\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#classes--no-duplicate-members\">9.6</a> 避免定义重复的类成员。 eslint: <a href=\"https://eslint.org/docs/rules/no-dupe-class-members\" target=\"_blank\"><code>no-dupe-class-members</code></a>\n<blockquote><p>为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nclass Foo {\n  bar() { return 1; }\n  bar() { return 2; }\n}\n\n// good\nclass Foo {\n  bar() { return 1; }\n}\n\n// good\nclass Foo {\n  bar() { return 2; }\n}</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"fac54c34\"><a>模块</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#modules--use-them\">10.1</a> 你可能经常使用模块 (<code>import</code>/<code>export</code>) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n<blockquote><p>为什么? 模块是未来的趋势，让我们拥抱未来。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst AirbnbStyleGuide = require('./AirbnbStyleGuide');\nmodule.exports = AirbnbStyleGuide.es6;\n\n// ok\nimport AirbnbStyleGuide from './AirbnbStyleGuide';\nexport default AirbnbStyleGuide.es6;\n\n// best\nimport { es6 } from './AirbnbStyleGuide';\nexport default es6;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-wildcard\">10.2</a> 不要使用通配符导入。\n<blockquote><p>为什么? 这确定你有一个单独的默认导出。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nimport * as AirbnbStyleGuide from './AirbnbStyleGuide';\n\n// good\nimport AirbnbStyleGuide from './AirbnbStyleGuide';</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-export-from-import\">10.3</a> 不要直接从导入导出。\n<blockquote><p>为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n// filename es6.js\nexport { es6 as default } from './AirbnbStyleGuide';\n\n// good\n// filename es6.js\nimport { es6 } from './AirbnbStyleGuide';\nexport default es6;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-duplicate-imports\">10.4</a> 只从一个路径导入所有需要的东西。<br />\neslint: <a href=\"https://eslint.org/docs/rules/no-duplicate-imports\" target=\"_blank\"><code>no-duplicate-imports</code></a>\n<blockquote><p>为什么? 从同一个路径导入多个行，使代码更难以维护。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nimport foo from 'foo';\n// … 其他导入 … //\nimport { named1, named2 } from 'foo';\n\n// good\nimport foo, { named1, named2 } from 'foo';\n\n// good\nimport foo, {\n  named1,\n  named2,\n} from 'foo';</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-mutable-exports\">10.5</a> 不要导出可变的引用。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-mutable-exports.md\" target=\"_blank\"><code>import/no-mutable-exports</code></a>\n<blockquote><p>为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nlet foo = 3;\nexport { foo };\n\n// good\nconst foo = 3;\nexport { foo };</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--prefer-default-export\">10.6</a> 在单个导出的模块中，选择默认模块而不是指定的导出。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/prefer-default-export.md\" target=\"_blank\"><code>import/prefer-default-export</code></a>\n<blockquote><p>为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nexport function foo() {}\n\n// good\nexport default function foo() {}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--imports-first\">10.7</a> 将所有的 <code>import</code>s 语句放在所有非导入语句的上边。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/first.md\" target=\"_blank\"><code>import/first</code></a>\n<blockquote><p>为什么? 由于所有的 <code>import</code>s 都被提前，保持他们在顶部是为了防止意外发生。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nimport foo from 'foo';\nfoo.init();\n\nimport bar from 'bar';\n\n// good\nimport foo from 'foo';\nimport bar from 'bar';\n\nfoo.init();</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--multiline-imports-over-newlines\">10.8</a> 多行导入应该像多行数组和对象一样缩进。\n<blockquote><p>为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nimport {longNameA, longNameB, longNameC, longNameD, longNameE} from 'path';\n\n// good\nimport {\n  longNameA,\n  longNameB,\n  longNameC,\n  longNameD,\n  longNameE,\n} from 'path';</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-webpack-loader-syntax\">10.9</a> 在模块导入语句中禁止使用 Webpack 加载器语法。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md\" target=\"_blank\"><code>import/no-webpack-loader-syntax</code></a>\n<blockquote><p>为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 <code>webpack.config.js</code> 中使用加载器语法。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nimport fooSass from 'css!sass!foo.scss';\nimport barCss from 'style!css!bar.css';\n\n// good\nimport fooSass from 'foo.scss';\nimport barCss from 'bar.css';</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"3caad93c\"><a>迭代器和发生器</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#iterators--nope\">11.1</a> 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 <code>for-in</code> 或者 <code>for-of</code>。 eslint: <a href=\"https://eslint.org/docs/rules/no-iterator.html\" target=\"_blank\"><code>no-iterator</code></a> <a href=\"https://eslint.org/docs/rules/no-restricted-syntax\" target=\"_blank\"><code>no-restricted-syntax</code></a>\n<blockquote><p>为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。</p></blockquote><blockquote><p>使用 <code>map()</code> / <code>every()</code> / <code>filter()</code> / <code>find()</code> / <code>findIndex()</code> / <code>reduce()</code> / <code>some()</code> / ... 遍历数组， 和使用 <code>Object.keys()</code> / <code>Object.values()</code> / <code>Object.entries()</code> 迭代你的对象生成数组。</p></blockquote><pre data-lang=\"javascript\"><code>const numbers = [1, 2, 3, 4, 5];\n\n// bad\nlet sum = 0;\nfor (let num of numbers) {\n  sum += num;\n}\nsum === 15;\n\n// good\nlet sum = 0;\nnumbers.forEach((num) =&gt; {\n  sum += num;\n});\nsum === 15;\n\n// best (use the functional force)\nconst sum = numbers.reduce((total, num) =&gt; total + num, 0);\nsum === 15;\n\n// bad\nconst increasedByOne = [];\nfor (let i = 0; i &lt; numbers.length; i++) {\n  increasedByOne.push(numbers[i] + 1);\n}\n\n// good\nconst increasedByOne = [];\nnumbers.forEach((num) =&gt; {\n  increasedByOne.push(num + 1);\n});\n\n// best (keeping it functional)\nconst increasedByOne = numbers.map(num =&gt; num + 1);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#generators--nope\">11.2</a> 不要使用发生器。\n<blockquote><p>为什么? 它们不能很好的适应 ES5。</p></blockquote></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#generators--spacing\">11.3</a> 如果你必须使用发生器或者无视 <a href=\"#generators--nope\">我们的建议</a>，请确保他们的函数签名是正常的间隔。 eslint: <a href=\"https://eslint.org/docs/rules/generator-star-spacing\" target=\"_blank\"><code>generator-star-spacing</code></a>\n<blockquote><p>为什么? <code>function</code> 和 <code>*</code> 是同一个概念关键字的一部分 - <code>*</code> 不是 <code>function</code> 的修饰符， <code>function*</code> 是一个不同于 <code>function</code> 的构造器。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nfunction * foo() {\n  // ...\n}\n\n// bad\nconst bar = function * () {\n  // ...\n};\n\n// bad\nconst baz = function *() {\n  // ...\n};\n\n// bad\nconst quux = function*() {\n  // ...\n};\n\n// bad\nfunction*foo() {\n  // ...\n}\n\n// bad\nfunction *foo() {\n  // ...\n}\n\n// very bad\nfunction\n*\nfoo() {\n  // ...\n}\n\n// very bad\nconst wat = function\n*\n() {\n  // ...\n};\n\n// good\nfunction* foo() {\n  // ...\n}\n\n// good\nconst foo = function* () {\n  // ...\n};</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"24d67862\"><a>属性</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#properties--dot\">12.1</a> 访问属性时使用点符号。 eslint: <a href=\"https://eslint.org/docs/rules/dot-notation.html\" target=\"_blank\"><code>dot-notation</code></a>\n<pre data-lang=\"javascript\"><code>const luke = {\n  jedi: true,\n  age: 28,\n};\n\n// bad\nconst isJedi = luke['jedi'];\n\n// good\nconst isJedi = luke.jedi;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#properties--bracket\">12.2</a> 使用变量访问属性时，使用 <code>[]</code>表示法。\n<pre data-lang=\"javascript\"><code>const luke = {\n  jedi: true,\n  age: 28,\n};\n\nfunction getProp(prop) {\n  return luke[prop];\n}\n\nconst isJedi = getProp('jedi');</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es2016-properties--exponentiation-operator\">12.3</a> 计算指数时，可以使用 <code>**</code> 运算符。 eslint: <a href=\"https://eslint.org/docs/rules/no-restricted-properties\" target=\"_blank\"><code>no-restricted-properties</code></a>.\n<pre data-lang=\"javascript\"><code>// bad\nconst binary = Math.pow(2, 10);\n\n// good\nconst binary = 2 ** 10;</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ddc7d28b\"><a>变量</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#variables--const\">13.1</a> 使用 <code>const</code> 或者 <code>let</code> 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: <a href=\"https://eslint.org/docs/rules/no-undef\" target=\"_blank\"><code>no-undef</code></a> <a href=\"https://eslint.org/docs/rules/prefer-const\" target=\"_blank\"><code>prefer-const</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nsuperPower = new SuperPower();\n\n// good\nconst superPower = new SuperPower();</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--one-const\">13.2</a> 使用 <code>const</code> 或者 <code>let</code> 声明每一个变量。 eslint: <a href=\"https://eslint.org/docs/rules/one-var.html\" target=\"_blank\"><code>one-var</code></a>\n<blockquote><p>为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 <code>;</code> 还是使用 <code>,</code> 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst items = getItems(),\n    goSportsTeam = true,\n    dragonball = 'z';\n\n// bad\n// (compare to above, and try to spot the mistake)\nconst items = getItems(),\n    goSportsTeam = true;\n    dragonball = 'z';\n\n// good\nconst items = getItems();\nconst goSportsTeam = true;\nconst dragonball = 'z';</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--const-let-group\">13.3</a> 把 <code>const</code> 声明的放在一起，把 <code>let</code> 声明的放在一起。.\n<blockquote><p>为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nlet i, len, dragonball,\n    items = getItems(),\n    goSportsTeam = true;\n\n// bad\nlet i;\nconst items = getItems();\nlet dragonball;\nconst goSportsTeam = true;\nlet len;\n\n// good\nconst goSportsTeam = true;\nconst items = getItems();\nlet dragonball;\nlet i;\nlet length;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--define-where-used\">13.4</a> 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\n<blockquote><p>为什么? <code>let</code> 和 <code>const</code> 是块级作用域而不是函数作用域。</p></blockquote><pre data-lang=\"javascript\"><code>// bad - 不必要的函数调用\nfunction checkName(hasName) {\n  const name = getName();\n\n  if (hasName === 'test') {\n    return false;\n  }\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}\n\n// good\nfunction checkName(hasName) {\n  if (hasName === 'test') {\n    return false;\n  }\n\n  const name = getName();\n\n  if (name === 'test') {\n    this.setName('');\n    return false;\n  }\n\n  return name;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--no-chain-assignment\">13.5</a> 不要链式变量赋值。 eslint: <a href=\"https://eslint.org/docs/rules/no-multi-assign\" target=\"_blank\"><code>no-multi-assign</code></a>\n<blockquote><p>为什么? 链式变量赋值会创建隐式全局变量。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n(function example() {\n  // JavaScript 把它解释为\n  // let a = ( b = ( c = 1 ) );\n  // let 关键词只适用于变量 a ；变量 b 和变量 c 则变成了全局变量。\n  let a = b = c = 1;\n}());\n\nconsole.log(a); // throws ReferenceError\nconsole.log(b); // 1\nconsole.log(c); // 1\n\n// good\n(function example() {\n  let a = 1;\n  let b = a;\n  let c = a;\n}());\n\nconsole.log(a); // throws ReferenceError\nconsole.log(b); // throws ReferenceError\nconsole.log(c); // throws ReferenceError\n\n// 对于 `const` 也一样</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--unary-increment-decrement\">13.6</a> 避免使用不必要的递增和递减 (<code>++</code>, <code>--</code>)。 eslint <a href=\"https://eslint.org/docs/rules/no-plusplus\" target=\"_blank\"><code>no-plusplus</code></a>\n<blockquote><p>为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 <code>num += 1</code> 这样的语句来改变您的值，而不是使用 <code>num++</code> 或 <code>num ++</code> 。不允许不必要的增量和减量语句也会使您无法预先递增/预递减值，这也会导致程序中的意外行为。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\n\nconst array = [1, 2, 3];\nlet num = 1;\nnum++;\n--num;\n\nlet sum = 0;\nlet truthyCount = 0;\nfor (let i = 0; i &lt; array.length; i++) {\n  let value = array[i];\n  sum += value;\n  if (value) {\n    truthyCount++;\n  }\n}\n\n// good\n\nconst array = [1, 2, 3];\nlet num = 1;\nnum += 1;\nnum -= 1;\n\nconst sum = array.reduce((a, b) =&gt; a + b, 0);\nconst truthyCount = array.filter(Boolean).length;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--linebreak\">13.7</a> 避免在赋值语句 <code>=</code> 前后换行。如果你的代码违反了 <a href=\"https://eslint.org/docs/rules/max-len.html\" target=\"_blank\"><code>max-len</code></a>， 使用括号包裹。 eslint <a href=\"https://eslint.org/docs/rules/operator-linebreak.html\" target=\"_blank\"><code>operator-linebreak</code></a>.\n<blockquote><p>为什么? 在 <code>=</code> 前后换行，可能混淆赋的值。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst foo =\n  superLongLongLongLongLongLongLongLongFunctionName();\n\n// bad\nconst foo\n  = 'superLongLongLongLongLongLongLongLongString';\n\n// good\nconst foo = (\n  superLongLongLongLongLongLongLongLongFunctionName()\n);\n\n// good\nconst foo = 'superLongLongLongLongLongLongLongLongString';</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"c290b27e\"><a>提升</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--about\">14.1</a> <code>var</code> 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。<code>const</code> 和 <code>let</code> 声明的变量受到一个称之为 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let\" target=\"_blank\">Temporal Dead Zones (TDZ)</a> 的新概念保护。 知道为什么 <a href=\"http://es-discourse.com/t/why-typeof-is-no-longer-safe/15\" target=\"_blank\">typeof 不再安全</a> 是很重要的。\n<pre data-lang=\"javascript\"><code>// 我们知道这个行不通 (假设没有未定义的全局变量)\nfunction example() {\n  console.log(notDefined); // =&gt; throws a ReferenceError\n}\n\n// 在引用变量后创建变量声明将会因变量提升而起作用。\n// 注意: 真正的值 `true` 不会被提升。\nfunction example() {\n  console.log(declaredButNotAssigned); // =&gt; undefined\n  var declaredButNotAssigned = true;\n}\n\n// 解释器将变量提升到函数的顶部\n// 这意味着我们可以将上边的例子重写为：\nfunction example() {\n  let declaredButNotAssigned;\n  console.log(declaredButNotAssigned); // =&gt; undefined\n  declaredButNotAssigned = true;\n}\n\n// 使用 const 和 let\nfunction example() {\n  console.log(declaredButNotAssigned); // =&gt; throws a ReferenceError\n  console.log(typeof declaredButNotAssigned); // =&gt; throws a ReferenceError\n  const declaredButNotAssigned = true;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--anon-expressions\">14.2</a> 匿名函数表达式提升变量名，而不是函数赋值。\n<pre data-lang=\"javascript\"><code>function example() {\n  console.log(anonymous); // =&gt; undefined\n\n  anonymous(); // =&gt; TypeError anonymous is not a function\n\n  var anonymous = function () {\n    console.log('anonymous function expression');\n  };\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--named-expressions\">14.3</a> 命名函数表达式提升的是变量名，而不是函数名或者函数体。\n<pre data-lang=\"javascript\"><code>function example() {\n  console.log(named); // =&gt; undefined\n\n  named(); // =&gt; TypeError named is not a function\n\n  superPower(); // =&gt; ReferenceError superPower is not defined\n\n  var named = function superPower() {\n    console.log('Flying');\n  };\n}\n\n// 当函数名和变量名相同时也是如此。\nfunction example() {\n  console.log(named); // =&gt; undefined\n\n  named(); // =&gt; TypeError named is not a function\n\n  var named = function named() {\n    console.log('named');\n  };\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--declarations\">14.4</a> 函数声明提升其名称和函数体。\n<pre data-lang=\"javascript\"><code>function example() {\n  superPower(); // =&gt; Flying\n\n  function superPower() {\n    console.log('Flying');\n  }\n}</code></pre></li></ul><ul><li>更多信息请参考 <a href=\"http://www.adequatelygood.com/\" target=\"_blank\">Ben Cherry</a> 的 <a href=\"http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting/\" target=\"_blank\">JavaScript Scoping &amp; Hoisting</a>。</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"d6cfcb92\"><a>比较运算符和等号</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--eqeqeq\">15.1</a> 使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code>。 eslint: <a href=\"https://eslint.org/docs/rules/eqeqeq.html\" target=\"_blank\"><code>eqeqeq</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--if\">15.2</a> 条件语句，例如 <code>if</code> 语句使用 <code>ToBoolean</code> 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：</li></ul><ul data-lake-indent=\"1\"><li><strong>Objects</strong> 的取值为： <strong>true</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Undefined</strong> 的取值为： <strong>false</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Null</strong> 的取值为： <strong>false</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Booleans</strong> 的取值为： <strong>布尔值的取值</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Numbers</strong> 的取值为：如果为 <strong>+0, -0, or NaN</strong> 值为 <strong>false</strong> 否则为 <strong>true</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Strings</strong> 的取值为: 如果是一个空字符串 <code>''</code> 值为 <strong>false</strong> 否则为 <strong>true</strong></li></ul><pre data-lang=\"javascript\"><code>if ([0] &amp;&amp; []) {\n  // true\n  // 一个数组（即使是空的）是一个对象，对象的取值为 true\n}</code></pre><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--shortcuts\">15.3</a> 对于布尔值使用简写，但是对于字符串和数字进行显式比较。\n<pre data-lang=\"javascript\"><code>// bad\nif (isValid === true) {\n  // ...\n}\n\n// good\nif (isValid) {\n  // ...\n}\n\n// bad\nif (name) {\n  // ...\n}\n\n// good\nif (name !== '') {\n  // ...\n}\n\n// bad\nif (collection.length) {\n  // ...\n}\n\n// good\nif (collection.length &gt; 0) {\n  // ...\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--moreinfo\">15.4</a> 获取更多信息请查看 Angus Croll 的 <a href=\"https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108\" target=\"_blank\">Truth Equality and JavaScript</a> 。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--switch-blocks\">15.5</a> 在 <code>case</code> 和 <code>default</code> 的子句中，如果存在声明 (例如. <code>let</code>, <code>const</code>, <code>function</code>, 和 <code>class</code>)，使用大括号来创建块 。 eslint: <a href=\"https://eslint.org/docs/rules/no-case-declarations.html\" target=\"_blank\"><code>no-case-declarations</code></a>\n<blockquote><p>为什么? 语法声明在整个 <code>switch</code> 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 <code>case</code> 条件达到才会发生。 当多个 <code>case</code> 语句定义相同的东西是，这会导致问题问题。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nswitch (foo) {\n  case 1:\n    let x = 1;\n    break;\n  case 2:\n    const y = 2;\n    break;\n  case 3:\n    function f() {\n      // ...\n    }\n    break;\n  default:\n    class C {}\n}\n\n// good\nswitch (foo) {\n  case 1: {\n    let x = 1;\n    break;\n  }\n  case 2: {\n    const y = 2;\n    break;\n  }\n  case 3: {\n    function f() {\n      // ...\n    }\n    break;\n  }\n  case 4:\n    bar();\n    break;\n  default: {\n    class C {}\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--nested-ternaries\">15.6</a> 三目表达式不应该嵌套，通常是单行表达式。 eslint: <a href=\"https://eslint.org/docs/rules/no-nested-ternary.html\" target=\"_blank\"><code>no-nested-ternary</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst foo = maybe1 &gt; maybe2\n  ? &quot;bar&quot;\n  : value1 &gt; value2 ? &quot;baz&quot; : null;\n\n// 分离为两个三目表达式\nconst maybeNull = value1 &gt; value2 ? 'baz' : null;\n\n// better\nconst foo = maybe1 &gt; maybe2\n  ? 'bar'\n  : maybeNull;\n\n// best\nconst foo = maybe1 &gt; maybe2 ? 'bar' : maybeNull;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--unneeded-ternary\">15.7</a> 避免不必要的三目表达式。 eslint: <a href=\"https://eslint.org/docs/rules/no-unneeded-ternary.html\" target=\"_blank\"><code>no-unneeded-ternary</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst foo = a ? a : b;\nconst bar = c ? true : false;\nconst baz = c ? false : true;\n\n// good\nconst foo = a || b;\nconst bar = !!c;\nconst baz = !c;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--no-mixed-operators\">15.8</a> 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (<code>+</code>, <code>-</code>, <code>*</code>, &amp; <code>/</code>) 因为他们的优先级被广泛理解。 eslint: <a href=\"https://eslint.org/docs/rules/no-mixed-operators.html\" target=\"_blank\"><code>no-mixed-operators</code></a>\n<blockquote><p>为什么? 这能提高可读性并且表明开发人员的意图。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst foo = a &amp;&amp; b &lt; 0 || c &gt; 0 || d + 1 === 0;\n\n// bad\nconst bar = a ** b - 5 % d;\n\n// bad\n// 可能陷入一种 (a || b) &amp;&amp; c 的思考\nif (a || b &amp;&amp; c) {\n  return d;\n}\n\n// good\nconst foo = (a &amp;&amp; b &lt; 0) || c &gt; 0 || (d + 1 === 0);\n\n// good\nconst bar = (a ** b) - (5 % d);\n\n// good\nif (a || (b &amp;&amp; c)) {\n  return d;\n}\n\n// good\nconst bar = a + b / c * d;</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"7084eb1b\"><a>块</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#blocks--braces\">16.1</a> 当有多行代码块的时候，使用大括号包裹。 eslint: <a href=\"https://eslint.org/docs/rules/nonblock-statement-body-position\" target=\"_blank\"><code>nonblock-statement-body-position</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nif (test)\n  return false;\n\n// good\nif (test) return false;\n\n// good\nif (test) {\n  return false;\n}\n\n// bad\nfunction foo() { return false; }\n\n// good\nfunction bar() {\n  return false;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#blocks--cuddled-elses\">16.2</a> 如果你使用的是 <code>if</code> 和 <code>else</code> 的多行代码块，则将 <code>else</code> 语句放在 <code>if</code> 块闭括号同一行的位置。 eslint: <a href=\"https://eslint.org/docs/rules/brace-style.html\" target=\"_blank\"><code>brace-style</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nif (test) {\n  thing1();\n  thing2();\n}\nelse {\n  thing3();\n}\n\n// good\nif (test) {\n  thing1();\n  thing2();\n} else {\n  thing3();\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#blocks--no-else-return\">16.3</a> 如果一个 <code>if</code> 块总是执行一个 <code>return</code> 语句，那么接下来的 <code>else</code> 块就没有必要了。 如果一个包含 <code>return</code> 语句的 <code>else if</code> 块，在一个包含了 <code>return</code> 语句的 <code>if</code> 块之后，那么可以拆成多个 <code>if</code> 块。 eslint: <a href=\"https://eslint.org/docs/rules/no-else-return\" target=\"_blank\"><code>no-else-return</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction foo() {\n  if (x) {\n    return x;\n  } else {\n    return y;\n  }\n}\n\n// bad\nfunction cats() {\n  if (x) {\n    return x;\n  } else if (y) {\n    return y;\n  }\n}\n\n// bad\nfunction dogs() {\n  if (x) {\n    return x;\n  } else {\n    if (y) {\n      return y;\n    }\n  }\n}\n\n// good\nfunction foo() {\n  if (x) {\n    return x;\n  }\n\n  return y;\n}\n\n// good\nfunction cats() {\n  if (x) {\n    return x;\n  }\n\n  if (y) {\n    return y;\n  }\n}\n\n// good\nfunction dogs(x) {\n  if (x) {\n    if (z) {\n      return y;\n    }\n  } else {\n    return z;\n  }\n}</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ea5302a4\"><a>控制语句</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#control-statements\">17.1</a> 如果你的控制语句 (<code>if</code>, <code>while</code> 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。\n<blockquote><p>为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nif ((foo === 123 || bar === 'abc') &amp;&amp; doesItLookGoodWhenItBecomesThatLong() &amp;&amp; isThisReallyHappening()) {\n  thing1();\n}\n\n// bad\nif (foo === 123 &amp;&amp;\n  bar === 'abc') {\n  thing1();\n}\n\n// bad\nif (foo === 123\n  &amp;&amp; bar === 'abc') {\n  thing1();\n}\n\n// bad\nif (\n  foo === 123 &amp;&amp;\n  bar === 'abc'\n) {\n  thing1();\n}\n\n// good\nif (\n  foo === 123\n  &amp;&amp; bar === 'abc'\n) {\n  thing1();\n}\n\n// good\nif (\n  (foo === 123 || bar === 'abc')\n  &amp;&amp; doesItLookGoodWhenItBecomesThatLong()\n  &amp;&amp; isThisReallyHappening()\n) {\n  thing1();\n}\n\n// good\nif (foo === 123 &amp;&amp; bar === 'abc') {\n  thing1();\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#control-statements--value-selection\">17.2</a> 不要使用选择操作符代替控制语句。\n<pre data-lang=\"javascript\"><code>// bad\n!isRunning &amp;&amp; startRunning();\n\n// good\nif (!isRunning) {\n  startRunning();\n}</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ee656aa1\"><a>注释</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#comments--multiline\">18.1</a> 使用 <code>/** ... */</code> 来进行多行注释。\n<pre data-lang=\"javascript\"><code>// bad\n// make() returns a new element\n// based on the passed in tag name\n//\n// @param {String} tag\n// @return {Element} element\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n\n// good\n/**\n * make() returns a new element\n * based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--singleline\">18.2</a> 使用 <code>//</code> 进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。\n<pre data-lang=\"javascript\"><code>// bad\nconst active = true;  // is current tab\n\n// good\n// is current tab\nconst active = true;\n\n// bad\nfunction getType() {\n  console.log('fetching type...');\n  // set the default type to 'no type'\n  const type = this.type || 'no type';\n\n  return type;\n}\n\n// good\nfunction getType() {\n  console.log('fetching type...');\n\n  // set the default type to 'no type'\n  const type = this.type || 'no type';\n\n  return type;\n}\n\n// also good\nfunction getType() {\n  // set the default type to 'no type'\n  const type = this.type || 'no type';\n\n  return type;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--spaces\">18.3</a> 用一个空格开始所有的注释，使它更容易阅读。 eslint: <a href=\"https://eslint.org/docs/rules/spaced-comment\" target=\"_blank\"><code>spaced-comment</code></a>\n<pre data-lang=\"javascript\"><code>// bad\n//is current tab\nconst active = true;\n\n// good\n// is current tab\nconst active = true;\n\n// bad\n/**\n *make() returns a new element\n *based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}\n\n// good\n/**\n * make() returns a new element\n * based on the passed-in tag name\n */\nfunction make(tag) {\n\n  // ...\n\n  return element;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--actionitems\">18.4</a> 使用 <code>FIXME</code> 或者 <code>TODO</code> 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 <code>FIXME: -- 需要解决这个问题</code> 或者 <code>TODO: -- 需要被实现</code>。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--fixme\">18.5</a> 使用 <code>// FIXME:</code> 注释一个问题。\n<pre data-lang=\"javascript\"><code>class Calculator extends Abacus {\n  constructor() {\n    super();\n\n    // FIXME: 这里不应该使用全局变量\n    total = 0;\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--todo\">18.6</a> 使用 <code>// TODO:</code> 注释解决问题的方法。\n<pre data-lang=\"javascript\"><code>class Calculator extends Abacus {\n  constructor() {\n    super();\n\n    // TODO: total 应该由一个 param 的选项配置\n    this.total = 0;\n  }\n}</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"6874c973\"><a>空白</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--spaces\">19.1</a> 使用 tabs (空格字符) 设置为 2 个空格。 eslint: <a href=\"https://eslint.org/docs/rules/indent.html\" target=\"_blank\"><code>indent</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction foo() {\n∙∙∙∙let name;\n}\n\n// bad\nfunction bar() {\n∙let name;\n}\n\n// good\nfunction baz() {\n∙∙let name;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--before-blocks\">19.2</a> 在主体前放置一个空格。 eslint: <a href=\"https://eslint.org/docs/rules/space-before-blocks.html\" target=\"_blank\"><code>space-before-blocks</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction test(){\n  console.log('test');\n}\n\n// good\nfunction test() {\n  console.log('test');\n}\n\n// bad\ndog.set('attr',{\n  age: '1 year',\n  breed: 'Bernese Mountain Dog',\n});\n\n// good\ndog.set('attr', {\n  age: '1 year',\n  breed: 'Bernese Mountain Dog',\n});</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--around-keywords\">19.3</a> 在控制语句（<code>if</code>, <code>while</code> 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: <a href=\"https://eslint.org/docs/rules/keyword-spacing.html\" target=\"_blank\"><code>keyword-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nif(isJedi) {\n  fight ();\n}\n\n// good\nif (isJedi) {\n  fight();\n}\n\n// bad\nfunction fight () {\n  console.log ('Swooosh!');\n}\n\n// good\nfunction fight() {\n  console.log('Swooosh!');\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--infix-ops\">19.4</a> 用空格分离操作符。 eslint: <a href=\"https://eslint.org/docs/rules/space-infix-ops.html\" target=\"_blank\"><code>space-infix-ops</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst x=y+5;\n\n// good\nconst x = y + 5;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--newline-at-end\">19.5</a> 使用单个换行符结束文件。 eslint: <a href=\"https://github.com/eslint/eslint/blob/master/docs/rules/eol-last.md\" target=\"_blank\"><code>eol-last</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;</code></pre><pre data-lang=\"javascript\"><code>// bad\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;↵\n↵</code></pre><pre data-lang=\"javascript\"><code>// good\nimport { es6 } from './AirbnbStyleGuide';\n  // ...\nexport default es6;↵</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--chains\">19.6</a> 在使用链式方法调用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: <a href=\"https://eslint.org/docs/rules/newline-per-chained-call\" target=\"_blank\"><code>newline-per-chained-call</code></a> <a href=\"https://eslint.org/docs/rules/no-whitespace-before-property\" target=\"_blank\"><code>no-whitespace-before-property</code></a>\n<pre data-lang=\"javascript\"><code>// bad\n$('#items').find('.selected').highlight().end().find('.open').updateCount();\n\n// bad\n$('#items').\n  find('.selected').\n    highlight().\n    end().\n  find('.open').\n    updateCount();\n\n// good\n$('#items')\n  .find('.selected')\n    .highlight()\n    .end()\n  .find('.open')\n    .updateCount();\n\n// bad\nconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true)\n    .attr('width', (radius + margin) * 2).append('svg:g')\n    .attr('transform', `translate(${radius + margin},${radius + margin})`)\n    .call(tron.led);\n\n// good\nconst leds = stage.selectAll('.led')\n    .data(data)\n  .enter().append('svg:svg')\n    .classed('led', true)\n    .attr('width', (radius + margin) * 2)\n  .append('svg:g')\n    .attr('transform', `translate(${radius + margin},${radius + margin})`)\n    .call(tron.led);\n\n// good\nconst leds = stage.selectAll('.led').data(data);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--after-blocks\">19.7</a> 在块和下一个语句之前留下一空白行。\n<pre data-lang=\"javascript\"><code>// bad\nif (foo) {\n  return bar;\n}\nreturn baz;\n\n// good\nif (foo) {\n  return bar;\n}\n\nreturn baz;\n\n// bad\nconst obj = {\n  foo() {\n  },\n  bar() {\n  },\n};\nreturn obj;\n\n// good\nconst obj = {\n  foo() {\n  },\n\n  bar() {\n  },\n};\n\nreturn obj;\n\n// bad\nconst arr = [\n  function foo() {\n  },\n  function bar() {\n  },\n];\nreturn arr;\n\n// good\nconst arr = [\n  function foo() {\n  },\n\n  function bar() {\n  },\n];\n\nreturn arr;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--padded-blocks\">19.8</a> 不要在块的开头使用空白行。 eslint: <a href=\"https://eslint.org/docs/rules/padded-blocks.html\" target=\"_blank\"><code>padded-blocks</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction bar() {\n\n  console.log(foo);\n\n}\n\n// bad\nif (baz) {\n\n  console.log(qux);\n} else {\n  console.log(foo);\n\n}\n\n// bad\nclass Foo {\n\n  constructor(bar) {\n    this.bar = bar;\n  }\n}\n\n// good\nfunction bar() {\n  console.log(foo);\n}\n\n// good\nif (baz) {\n  console.log(qux);\n} else {\n  console.log(foo);\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--in-parens\">19.9</a> 不要在括号内添加空格。 eslint: <a href=\"https://eslint.org/docs/rules/space-in-parens.html\" target=\"_blank\"><code>space-in-parens</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction bar( foo ) {\n  return foo;\n}\n\n// good\nfunction bar(foo) {\n  return foo;\n}\n\n// bad\nif ( foo ) {\n  console.log(foo);\n}\n\n// good\nif (foo) {\n  console.log(foo);\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--in-brackets\">19.10</a> 不要在中括号中添加空格。 eslint: <a href=\"https://eslint.org/docs/rules/array-bracket-spacing.html\" target=\"_blank\"><code>array-bracket-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst foo = [ 1, 2, 3 ];\nconsole.log(foo[ 0 ]);\n\n// good\nconst foo = [1, 2, 3];\nconsole.log(foo[0]);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--in-braces\">19.11</a> 在花括号内添加空格。 eslint: <a href=\"https://eslint.org/docs/rules/object-curly-spacing.html\" target=\"_blank\"><code>object-curly-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst foo = {clark: 'kent'};\n\n// good\nconst foo = { clark: 'kent' };</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--max-len\">19.12</a> 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 <a href=\"#strings--line-length\">约束</a>，长字符串可免除此规定，不应分解。 eslint: <a href=\"https://eslint.org/docs/rules/max-len.html\" target=\"_blank\"><code>max-len</code></a>\n<blockquote><p>为什么? 这样能够确保可读性和可维护性。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;\n\n// bad\n$.ajax({ method: 'POST', url: 'https://airbnb.com/', data: { name: 'John' } }).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.'));\n\n// good\nconst foo = jsonData\n  &amp;&amp; jsonData.foo\n  &amp;&amp; jsonData.foo.bar\n  &amp;&amp; jsonData.foo.bar.baz\n  &amp;&amp; jsonData.foo.bar.baz.quux\n  &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy;\n\n// good\n$.ajax({\n  method: 'POST',\n  url: 'https://airbnb.com/',\n  data: { name: 'John' },\n})\n  .done(() =&gt; console.log('Congratulations!'))\n  .fail(() =&gt; console.log('You have failed this city.'));</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--block-spacing\">19.13</a> 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: <a href=\"https://eslint.org/docs/rules/block-spacing\" target=\"_blank\"><code>block-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction foo() {return true;}\nif (foo) { bar = 0;}\n\n// good\nfunction foo() { return true; }\nif (foo) { bar = 0; }</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--comma-spacing\">19.14</a> 逗号之前避免使用空格，逗号之后需要使用空格。eslint: <a href=\"https://eslint.org/docs/rules/comma-spacing\" target=\"_blank\"><code>comma-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nvar foo = 1,bar = 2;\nvar arr = [1 , 2];\n\n// good\nvar foo = 1, bar = 2;\nvar arr = [1, 2];</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--computed-property-spacing\">19.15</a> 在计算属性之间强化间距。eslint: <a href=\"https://eslint.org/docs/rules/computed-property-spacing\" target=\"_blank\"><code>computed-property-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nobj[foo ]\nobj[ 'foo']\nvar x = {[ b ]: a}\nobj[foo[ bar ]]\n\n// good\nobj[foo]\nobj['foo']\nvar x = { [b]: a }\nobj[foo[bar]]</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--func-call-spacing\">19.16</a> 在函数和它的调用之间强化间距。 eslint: <a href=\"https://eslint.org/docs/rules/func-call-spacing\" target=\"_blank\"><code>func-call-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunc ();\n\nfunc\n();\n\n// good\nfunc();</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--key-spacing\">19.17</a> 在对象的属性和值之间强化间距。 eslint: <a href=\"https://eslint.org/docs/rules/key-spacing\" target=\"_blank\"><code>key-spacing</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nvar obj = { &quot;foo&quot; : 42 };\nvar obj2 = { &quot;foo&quot;:42 };\n\n// good\nvar obj = { &quot;foo&quot;: 42 };</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--no-trailing-spaces\">19.18</a> 在行的末尾避免使用空格。 eslint: <a href=\"https://eslint.org/docs/rules/no-trailing-spaces\" target=\"_blank\"><code>no-trailing-spaces</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--no-multiple-empty-lines\">19.19</a> 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: <a href=\"https://eslint.org/docs/rules/no-multiple-empty-lines\" target=\"_blank\"><code>no-multiple-empty-lines</code></a>\n\n<pre data-lang=\"javascript\"><code>// bad\nvar x = 1;\n\n\n\nvar y = 2;\n\n// good\nvar x = 1;\n\nvar y = 2;</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"c2d5517a\"><a>逗号</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#commas--leading-trailing\">20.1</a> 逗号前置： <strong>不行</strong> eslint: <a href=\"https://eslint.org/docs/rules/comma-style.html\" target=\"_blank\"><code>comma-style</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst story = [\n    once\n  , upon\n  , aTime\n];\n\n// good\nconst story = [\n  once,\n  upon,\n  aTime,\n];\n\n// bad\nconst hero = {\n    firstName: 'Ada'\n  , lastName: 'Lovelace'\n  , birthYear: 1815\n  , superPower: 'computers'\n};\n\n// good\nconst hero = {\n  firstName: 'Ada',\n  lastName: 'Lovelace',\n  birthYear: 1815,\n  superPower: 'computers',\n};</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#commas--dangling\">20.2</a> 添加尾随逗号： <strong>可以</strong> eslint: <a href=\"https://eslint.org/docs/rules/comma-dangle.html\" target=\"_blank\"><code>comma-dangle</code></a>\n<blockquote><p>为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 <a href=\"https://github.com/airbnb/javascript/blob/es5-deprecated/es5/README.md#commas\" target=\"_blank\">尾随逗号问题</a> 。</p></blockquote><pre data-lang=\"diff\"><code>// bad - 没有尾随逗号的 git 差异\nconst hero = {\n     firstName: 'Florence',\n-    lastName: 'Nightingale'\n+    lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing']\n};\n\n// good - 有尾随逗号的 git 差异\nconst hero = {\n     firstName: 'Florence',\n     lastName: 'Nightingale',\n+    inventorOf: ['coxcomb chart', 'modern nursing'],\n};</code></pre><pre data-lang=\"javascript\"><code>// bad\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully'\n};\n\nconst heroes = [\n  'Batman',\n  'Superman'\n];\n\n// good\nconst hero = {\n  firstName: 'Dana',\n  lastName: 'Scully',\n};\n\nconst heroes = [\n  'Batman',\n  'Superman',\n];\n\n// bad\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf\n) {\n  // does nothing\n}\n\n// good\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf,\n) {\n  // does nothing\n}\n\n// good (注意逗号不能出现在 &quot;rest&quot; 元素后边)\nfunction createHero(\n  firstName,\n  lastName,\n  inventorOf,\n  ...heroArgs\n) {\n  // does nothing\n}\n\n// bad\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf\n);\n\n// good\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf,\n);\n\n// good (注意逗号不能出现在 &quot;rest&quot; 元素后边)\ncreateHero(\n  firstName,\n  lastName,\n  inventorOf,\n  ...heroArgs\n);</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"cb368833\"><a>分号</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#semicolons--required\">21.1</a> <strong>对</strong> eslint: <a href=\"https://eslint.org/docs/rules/semi.html\" target=\"_blank\"><code>semi</code></a>\n<blockquote><p>为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 <a href=\"https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion\" target=\"_blank\">Automatic Semicolon Insertion</a> 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。</p></blockquote><pre data-lang=\"javascript\"><code>// bad - 可能异常\nconst luke = {}\nconst leia = {}\n[luke, leia].forEach(jedi =&gt; jedi.father = 'vader')\n\n// bad - 可能异常\nconst reaction = &quot;No! That's impossible!&quot;\n(async function meanwhileOnTheFalcon() {\n  // handle `leia`, `lando`, `chewie`, `r2`, `c3p0`\n  // ...\n}())\n\n// bad - 返回 `undefined` 而不是下一行的值 - 当 `return` 单独一行的时候 ASI 总是会发生\nfunction foo() {\n  return\n    'search your feelings, you know it to be foo'\n}\n\n// good\nconst luke = {};\nconst leia = {};\n[luke, leia].forEach((jedi) =&gt; {\n  jedi.father = 'vader';\n});\n\n// good\nconst reaction = &quot;No! That's impossible!&quot;;\n(async function meanwhileOnTheFalcon() {\n  // handle `leia`, `lando`, `chewie`, `r2`, `c3p0`\n  // ...\n}());\n\n// good\nfunction foo() {\n  return 'search your feelings, you know it to be foo';\n}</code></pre>\n<br /><a href=\"https://stackoverflow.com/questions/7365172/semicolon-before-self-invoking-function/7365214#7365214\" target=\"_blank\">更多信息</a>.</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"bf7d863e\"><a>类型转换和强制类型转换</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--explicit\">22.1</a> 在语句开始前进行类型转换。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--strings\">22.2</a>  字符类型： eslint: <a href=\"https://eslint.org/docs/rules/no-new-wrappers\" target=\"_blank\"><code>no-new-wrappers</code></a>\n<pre data-lang=\"javascript\"><code>// =&gt; this.reviewScore = 9;\n\n// bad\nconst totalScore = new String(this.reviewScore); // typeof totalScore is &quot;object&quot; not &quot;string&quot;\n\n// bad\nconst totalScore = this.reviewScore + ''; // invokes this.reviewScore.valueOf()\n\n// bad\nconst totalScore = this.reviewScore.toString(); // isn’t guaranteed to return a string\n\n// good\nconst totalScore = String(this.reviewScore);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--numbers\">22.3</a> 数字类型：使用 <code>Number</code> 进行类型铸造和 <code>parseInt</code> 总是通过一个基数来解析一个字符串。 eslint: <a href=\"https://eslint.org/docs/rules/radix\" target=\"_blank\"><code>radix</code></a> <a href=\"https://eslint.org/docs/rules/no-new-wrappers\" target=\"_blank\"><code>no-new-wrappers</code></a>\n<pre data-lang=\"javascript\"><code>const inputValue = '4';\n\n// bad\nconst val = new Number(inputValue);\n\n// bad\nconst val = +inputValue;\n\n// bad\nconst val = inputValue &gt;&gt; 0;\n\n// bad\nconst val = parseInt(inputValue);\n\n// good\nconst val = Number(inputValue);\n\n// good\nconst val = parseInt(inputValue, 10);</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--comment-deviations\">22.4</a> 如果出于某种原因，你正在做一些疯狂的事情，而 <code>parseInt</code> 是你的瓶颈，并且出于 <a href=\"https://jsperf.com/coercion-vs-casting/3\" target=\"_blank\">性能问题</a> 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。\n<pre data-lang=\"javascript\"><code>// good\n/**\n * parseInt 使我的代码变慢。\n * 位运算将一个字符串转换成数字更快。\n */\nconst val = inputValue &gt;&gt; 0;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--bitwise\">22.5</a> <strong>注意：</strong> 当你使用位运算的时候要小心。 数字总是被以 <a href=\"https://es5.github.io/#x4.3.19\" target=\"_blank\">64-bit 值</a> 的形式表示，但是位运算总是返回一个 32-bit 的整数 (<a href=\"https://es5.github.io/#x11.7\" target=\"_blank\">来源</a>)。 对于大于 32 位的整数值，位运算可能会导致意外行为。<a href=\"https://github.com/airbnb/javascript/issues/109\" target=\"_blank\">讨论</a>。 最大的 32 位整数是： 2,147,483,647。\n<pre data-lang=\"javascript\"><code>2147483647 &gt;&gt; 0; // =&gt; 2147483647\n2147483648 &gt;&gt; 0; // =&gt; -2147483648\n2147483649 &gt;&gt; 0; // =&gt; -2147483647</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--booleans\">22.6</a> 布尔类型： eslint: <a href=\"https://eslint.org/docs/rules/no-new-wrappers\" target=\"_blank\"><code>no-new-wrappers</code></a>\n<pre data-lang=\"javascript\"><code>const age = 0;\n\n// bad\nconst hasAge = new Boolean(age);\n\n// good\nconst hasAge = Boolean(age);\n\n// best\nconst hasAge = !!age;</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"a3d10465\"><a>命名规范</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#naming--descriptive\">23.1</a> 避免单字母的名字。用你的命名来描述功能。 eslint: <a href=\"https://eslint.org/docs/rules/id-length\" target=\"_blank\"><code>id-length</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction q() {\n  // ...\n}\n\n// good\nfunction query() {\n  // ...\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--camelCase\">23.2</a> 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: <a href=\"https://eslint.org/docs/rules/camelcase.html\" target=\"_blank\"><code>camelcase</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nconst OBJEcttsssss = {};\nconst this_is_my_object = {};\nfunction c() {}\n\n// good\nconst thisIsMyObject = {};\nfunction thisIsMyFunction() {}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--PascalCase\">23.3</a> 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: <a href=\"https://eslint.org/docs/rules/new-cap.html\" target=\"_blank\"><code>new-cap</code></a>\n<pre data-lang=\"javascript\"><code>// bad\nfunction user(options) {\n  this.name = options.name;\n}\n\nconst bad = new user({\n  name: 'nope',\n});\n\n// good\nclass User {\n  constructor(options) {\n    this.name = options.name;\n  }\n}\n\nconst good = new User({\n  name: 'yup',\n});</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--leading-underscore\">23.4</a> 不要使用前置或者后置下划线。 eslint: <a href=\"https://eslint.org/docs/rules/no-underscore-dangle.html\" target=\"_blank\"><code>no-underscore-dangle</code></a>\n<blockquote><p>为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nthis.__firstName__ = 'Panda';\nthis.firstName_ = 'Panda';\nthis._firstName = 'Panda';\n\n// good\nthis.firstName = 'Panda';\n\n// 好，在 WeakMapx 可用的环境中\n// see https://kangax.github.io/compat-table/es6/#test-WeakMap\nconst firstNames = new WeakMap();\nfirstNames.set(this, 'Panda');</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--self-this\">23.5</a> 不要保存 <code>this</code> 的引用。 使用箭头函数或者 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">函数#bind</a>。\n<pre data-lang=\"javascript\"><code>// bad\nfunction foo() {\n  const self = this;\n  return function () {\n    console.log(self);\n  };\n}\n\n// bad\nfunction foo() {\n  const that = this;\n  return function () {\n    console.log(that);\n  };\n}\n\n// good\nfunction foo() {\n  return () =&gt; {\n    console.log(this);\n  };\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--filename-matches-export\">23.6</a> 文件名应该和默认导出的名称完全匹配。\n<pre data-lang=\"javascript\"><code>// file 1 contents\nclass CheckBox {\n  // ...\n}\nexport default CheckBox;\n\n// file 2 contents\nexport default function fortyTwo() { return 42; }\n\n// file 3 contents\nexport default function insideDirectory() {}\n\n// in some other file\n// bad\nimport CheckBox from './checkBox'; // PascalCase import/export, camelCase filename\nimport FortyTwo from './FortyTwo'; // PascalCase import/filename, camelCase export\nimport InsideDirectory from './InsideDirectory'; // PascalCase import/filename, camelCase export\n\n// bad\nimport CheckBox from './check_box'; // PascalCase import/export, snake_case filename\nimport forty_two from './forty_two'; // snake_case import/filename, camelCase export\nimport inside_directory from './inside_directory'; // snake_case import, camelCase export\nimport index from './inside_directory/index'; // requiring the index file explicitly\nimport insideDirectory from './insideDirectory/index'; // requiring the index file explicitly\n\n// good\nimport CheckBox from './CheckBox'; // PascalCase export/import/filename\nimport fortyTwo from './fortyTwo'; // camelCase export/import/filename\nimport insideDirectory from './insideDirectory'; // camelCase export/import/directory name/implicit &quot;index&quot;\n// ^ supports both insideDirectory.js and insideDirectory/index.js</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--camelCase-default-export\">23.7</a> 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。\n<pre data-lang=\"javascript\"><code>function makeStyleGuide() {\n  // ...\n}\n\nexport default makeStyleGuide;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--PascalCase-singleton\">23.8</a> 当你导出一个构造器 / 类 / 单例 / 函数库 / 暴露的对象时应该使用帕斯卡命名法。\n<pre data-lang=\"javascript\"><code>const AirbnbStyleGuide = {\n  es6: {\n  },\n};\n\nexport default AirbnbStyleGuide;</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--Acronyms-and-Initialisms\">23.9</a> 缩略词和缩写都必须是全部大写或者全部小写。\n<blockquote><p>为什么? 名字是为了可读性，不是为了满足计算机算法。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nimport SmsContainer from './containers/SmsContainer';\n\n// bad\nconst HttpRequests = [\n  // ...\n];\n\n// good\nimport SMSContainer from './containers/SMSContainer';\n\n// good\nconst HTTPRequests = [\n  // ...\n];\n\n// also good\nconst httpRequests = [\n  // ...\n];\n\n// best\nimport TextMessageContainer from './containers/TextMessageContainer';\n\n// best\nconst requests = [\n  // ...\n];</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--uppercase\">23.10</a> 你可以大写一个常量，如果它：（1）被导出，（2）使用 <code>const</code> 定义（不能被重新赋值），（3）程序员可以信任它（以及其嵌套的属性）是不变的。\n<blockquote><p>为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。</p></blockquote></li></ul><ul data-lake-indent=\"1\"><li>是否是对所有的 <code>const</code> 定义的变量？ - 这个是没有必要的，不应该在文件中使用大写。但是，它应该用于导出常量。</li></ul><ul data-lake-indent=\"1\"><li>导出对象呢？ - 在顶级导出属性 (e.g. <code>EXPORTED_OBJECT.key</code>) 并且保持所有嵌套属性不变。</li></ul><pre data-lang=\"javascript\"><code>// bad\nconst PRIVATE_VARIABLE = 'should not be unnecessarily uppercased within a file';\n\n// bad\nexport const THING_TO_BE_CHANGED = 'should obviously not be uppercased';\n\n// bad\nexport let REASSIGNABLE_VARIABLE = 'do not use let with uppercase variables';\n\n// ---\n\n// 允许，但是不提供语义值\nexport const apiKey = 'SOMEKEY';\n\n// 多数情况下，很好\nexport const API_KEY = 'SOMEKEY';\n\n// ---\n\n// bad - 不必要大写 key 没有增加语义值\nexport const MAPPING = {\n  KEY: 'value'\n};\n\n// good\nexport const MAPPING = {\n  key: 'value'\n};</code></pre><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"cd92de2a\"><a>存取器</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--not-required\">24.1</a> 对于属性的的存取函数不是必须的。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--no-getters-setters\">24.2</a> 不要使用 JavaScript 的 getters/setters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 <code>getVal()</code> 和 <code>setVal('hello')</code>。\n<pre data-lang=\"javascript\"><code>// bad\nclass Dragon {\n  get age() {\n    // ...\n  }\n\n  set age(value) {\n    // ...\n  }\n}\n\n// good\nclass Dragon {\n  getAge() {\n    // ...\n  }\n\n  setAge(value) {\n    // ...\n  }\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--boolean-prefix\">24.3</a> 如果属性/方法是一个 <code>boolean</code> 值，使用 <code>isVal()</code> 或者 <code>hasVal()</code>。\n<pre data-lang=\"javascript\"><code>// bad\nif (!dragon.age()) {\n  return false;\n}\n\n// good\nif (!dragon.hasAge()) {\n  return false;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--consistent\">24.4</a> 可以创建 <code>get()</code> 和 <code>set()</code> 方法，但是要保证一致性。\n<pre data-lang=\"javascript\"><code>class Jedi {\n  constructor(options = {}) {\n    const lightsaber = options.lightsaber || 'blue';\n    this.set('lightsaber', lightsaber);\n  }\n\n  set(key, val) {\n    this[key] = val;\n  }\n\n  get(key) {\n    return this[key];\n  }\n}</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"10b2761d\"><a>事件</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#events--hash\">25.1</a> 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法：\n<pre data-lang=\"javascript\"><code>// bad\n$(this).trigger('listingUpdated', listing.id);\n\n// ...\n\n$(this).on('listingUpdated', (e, listingID) =&gt; {\n  // do something with listingID\n});</code></pre>\n<br />更好的写法：\n<pre data-lang=\"javascript\"><code>// good\n$(this).trigger('listingUpdated', { listingID: listing.id });\n\n// ...\n\n$(this).on('listingUpdated', (e, data) =&gt; {\n  // do something with data.listingID\n});</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"jQuery\">jQuery</h2><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--dollar-prefix\">26.1</a> 对于 jQuery 对象的变量使用 <code>$</code> 作为前缀。\n<pre data-lang=\"javascript\"><code>// bad\nconst sidebar = $('.sidebar');\n\n// good\nconst $sidebar = $('.sidebar');\n\n// good\nconst $sidebarBtn = $('.sidebar-btn');</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--cache\">26.2</a> 缓存 jQuery 查询。\n<pre data-lang=\"javascript\"><code>// bad\nfunction setSidebar() {\n  $('.sidebar').hide();\n\n  // ...\n\n  $('.sidebar').css({\n    'background-color': 'pink',\n  });\n}\n\n// good\nfunction setSidebar() {\n  const $sidebar = $('.sidebar');\n  $sidebar.hide();\n\n  // ...\n\n  $sidebar.css({\n    'background-color': 'pink',\n  });\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--queries\">26.3</a> 对于 DOM 查询使用层叠 <code>$('.sidebar ul')</code> 或 父元素 &gt; 子元素 <code>$('.sidebar &gt; ul')</code> 的格式。 <a href=\"http://jsperf.com/jquery-find-vs-context-sel/16\" target=\"_blank\">jsPerf</a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--find\">26.4</a> 对于有作用域的 jQuery 对象查询使用 <code>find</code> 。\n<pre data-lang=\"javascript\"><code>// bad\n$('ul', '.sidebar').hide();\n\n// bad\n$('.sidebar').find('ul').hide();\n\n// good\n$('.sidebar ul').hide();\n\n// good\n$('.sidebar &gt; ul').hide();\n\n// good\n$sidebar.find('ul').hide();</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"b59ab4d6\"><a>ECMAScript 5 兼容性</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#es5-compat--kangax\">27.1</a> 参考 <a href=\"https://twitter.com/kangax/\" target=\"_blank\">Kangax</a>的 ES5 <a href=\"https://kangax.github.io/es5-compat-table/\" target=\"_blank\">兼容性表格</a>。</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><p><br /></p><h2 id=\"c64dfd7d\">ECMAScript 6+ (ES 2015+) Styles</h2><p><br /></p><p><br /></p><ul><li><a href=\"#es6-styles\">28.1</a> 这是一个链接到各种 ES6+ 特性的集合。</li></ul><p><br /></p><ol start=\"1\"><li><a href=\"#arrow-functions\">箭头函数</a></li></ol><ol start=\"2\"><li><a href=\"#classes--constructors\">类</a></li></ol><ol start=\"3\"><li><a href=\"#es6-object-shorthand\">对象简写</a></li></ol><ol start=\"4\"><li><a href=\"#es6-object-concise\">对象简洁</a></li></ol><ol start=\"5\"><li><a href=\"#es6-computed-properties\">对象计算属性</a></li></ol><ol start=\"6\"><li><a href=\"#es6-template-literals\">字符串模板</a></li></ol><ol start=\"7\"><li><a href=\"#destructuring\">解构</a></li></ol><ol start=\"8\"><li><a href=\"#es6-default-parameters\">默认参数</a></li></ol><ol start=\"9\"><li><a href=\"#es6-rest\">Rest</a></li></ol><ol start=\"10\"><li><a href=\"#es6-array-spreads\">数组展开</a></li></ol><ol start=\"11\"><li><a href=\"#references\">Let 和 Const</a></li></ol><ol start=\"12\"><li><a href=\"#es2016-properties--exponentiation-operator\">求幂运算符</a></li></ol><ol start=\"13\"><li><a href=\"#iterators-and-generators\">迭代器和发生器</a></li></ol><ol start=\"14\"><li><a href=\"#modules\">模块</a></li></ol><p><br /></p><p><br /></p><ul><li><a href=\"#tc39-proposals\">28.2</a> 不要使用尚未达到第3阶段的 <a href=\"https://github.com/tc39/proposals\" target=\"_blank\">TC39 建议</a>。\n<blockquote><p>为什么? <a href=\"https://tc39.github.io/process-document/\" target=\"_blank\">它们没有最终确定</a>， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。</p></blockquote></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"dd970a1f\"><a>标准库</a></h2><p><br /></p><p><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects\" target=\"_blank\">标准库</a><br />\n包含功能已损坏的实用工具，但因为遗留原因而保留。</p><p><br /></p><p><br /></p><ul><li><a href=\"#standard-library--isnan\">29.1</a> 使用 <code>Number.isNaN</code> 代替全局的 <code>isNaN</code>.<br />\neslint: <a href=\"https://eslint.org/docs/rules/no-restricted-globals\" target=\"_blank\"><code>no-restricted-globals</code></a>\n<blockquote><p>为什么? 全局的 <code>isNaN</code> 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。</p></blockquote><blockquote><p>如果需要这种行为，请明确说明。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nisNaN('1.2'); // false\nisNaN('1.2.3'); // true\n\n// good\nNumber.isNaN('1.2.3'); // false\nNumber.isNaN(Number('1.2.3')); // true</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#standard-library--isfinite\">29.2</a> 使用 <code>Number.isFinite</code> 代替全局的 <code>isFinite</code>.<br />\neslint: <a href=\"https://eslint.org/docs/rules/no-restricted-globals\" target=\"_blank\"><code>no-restricted-globals</code></a>\n<blockquote><p>为什么? 全局的 <code>isFinite</code> 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。</p></blockquote><blockquote><p>如果需要这种行为，请明确说明。</p></blockquote><pre data-lang=\"javascript\"><code>// bad\nisFinite('2e3'); // true\n\n// good\nNumber.isFinite('2e3'); // false\nNumber.isFinite(parseInt('2e3', 10)); // true</code></pre></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"Testing\">Testing</h2><p><br /></p><p><br /></p><ul><li><a href=\"#testing--yup\">30.1</a> <strong>是的.</strong>\n<pre data-lang=\"javascript\"><code>function foo() {\n  return true;\n}</code></pre></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#testing--for-real\">30.2</a> <strong>没有，但是认真</strong>:</li></ul><ul data-lake-indent=\"1\"><li>无论你使用那种测试框架，都应该编写测试！</li></ul><ul data-lake-indent=\"1\"><li>努力写出许多小的纯函数，并尽量减少发生错误的地方。</li></ul><ul data-lake-indent=\"1\"><li>对于静态方法和 mock 要小心----它们会使你的测试更加脆弱。</li></ul><ul data-lake-indent=\"1\"><li>我们主要在 Airbnb 上使用 <a href=\"https://www.npmjs.com/package/mocha\" target=\"_blank\"><code>mocha</code></a> 和 <a href=\"https://www.npmjs.com/package/jest\" target=\"_blank\"><code>jest</code></a> 。 <a href=\"https://www.npmjs.com/package/tape\" target=\"_blank\"><code>tape</code></a> 也会用在一些小的独立模块上。</li></ul><ul data-lake-indent=\"1\"><li>100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。</li></ul><ul data-lake-indent=\"1\"><li>无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"c3318eaa\"><a>性能</a></h2><p><br /></p><ul><li><a href=\"https://www.kellegous.com/j/2013/01/26/layout-performance/\" target=\"_blank\">On Layout &amp; Web Performance</a></li></ul><ul><li><a href=\"https://jsperf.com/string-vs-array-concat/2\" target=\"_blank\">String vs Array Concat</a></li></ul><ul><li><a href=\"https://jsperf.com/try-catch-in-loop-cost\" target=\"_blank\">Try/Catch Cost In a Loop</a></li></ul><ul><li><a href=\"https://jsperf.com/bang-function\" target=\"_blank\">Bang Function</a></li></ul><ul><li><a href=\"https://jsperf.com/jquery-find-vs-context-sel/13\" target=\"_blank\">jQuery Find vs Context, Selector</a></li></ul><ul><li><a href=\"https://jsperf.com/innerhtml-vs-textcontent-for-script-text\" target=\"_blank\">innerHTML vs textContent for script text</a></li></ul><ul><li><a href=\"https://jsperf.com/ya-string-concat\" target=\"_blank\">Long String Concatenation</a></li></ul><ul><li><a href=\"https://www.quora.com/JavaScript-programming-language-Are-Javascript-functions-like-map-reduce-and-filter-already-optimized-for-traversing-array/answer/Quildreen-Motta\" target=\"_blank\">Are Javascript functions like <code>map()</code>, <code>reduce()</code>, and <code>filter()</code> optimized for traversing arrays?</a></li></ul><ul><li>Loading...</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"eee83a92\"><a>资源</a></h2><p><br /></p><p><strong>学习 ES6+</strong></p><p><br /></p><ul><li><a href=\"https://tc39.github.io/ecma262/\" target=\"_blank\">Latest ECMA spec</a></li></ul><ul><li><a href=\"http://exploringjs.com/\" target=\"_blank\">ExploringJS</a></li></ul><ul><li><a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\">ES6 Compatibility Table</a></li></ul><ul><li><a href=\"http://es6-features.org/\" target=\"_blank\">Comprehensive Overview of ES6 Features</a></li></ul><p><br /></p><p><strong>读这个</strong></p><p><br /></p><ul><li><a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html\" target=\"_blank\">Standard ECMA-262</a></li></ul><p><br /></p><p><strong>工具</strong></p><p><br /></p><ul><li>Code Style Linters</li></ul><ul data-lake-indent=\"1\"><li><a href=\"https://eslint.org/\" target=\"_blank\">ESlint</a> - <a href=\"https://github.com/airbnb/javascript/blob/master/linters/.eslintrc\" target=\"_blank\">Airbnb Style .eslintrc</a></li></ul><ul data-lake-indent=\"1\"><li><a href=\"http://jshint.com/\" target=\"_blank\">JSHint</a> - <a href=\"https://github.com/airbnb/javascript/blob/master/linters/.jshintrc\" target=\"_blank\">Airbnb Style .jshintrc</a></li></ul><ul><li>Neutrino preset - <a href=\"https://neutrino.js.org/presets/neutrino-preset-airbnb-base/\" target=\"_blank\">neutrino-preset-airbnb-base</a></li></ul><p><br /></p><p><strong>其他编码规范</strong></p><p><br /></p><ul><li><a href=\"https://google.github.io/styleguide/javascriptguide.xml\" target=\"_blank\">Google JavaScript Style Guide</a></li></ul><ul><li><a href=\"https://contribute.jquery.org/style-guide/js/\" target=\"_blank\">jQuery Core Style Guidelines</a></li></ul><ul><li><a href=\"https://github.com/rwaldron/idiomatic.js\" target=\"_blank\">Principles of Writing Consistent, Idiomatic JavaScript</a></li></ul><ul><li><a href=\"https://standardjs.com\" target=\"_blank\">StandardJS</a></li></ul><p><br /></p><p><strong>其他风格</strong></p><p><br /></p><ul><li><a href=\"https://gist.github.com/cjohansen/4135065\" target=\"_blank\">Naming this in nested functions</a> - Christian Johansen</li></ul><ul><li><a href=\"https://github.com/airbnb/javascript/issues/52\" target=\"_blank\">Conditional Callbacks</a> - Ross Allen</li></ul><ul><li><a href=\"http://sideeffect.kr/popularconvention/#javascript\" target=\"_blank\">Popular JavaScript Coding Conventions on GitHub</a> - JeongHoon Byun</li></ul><ul><li><a href=\"http://benalman.com/news/2012/05/multiple-var-statements-javascript/\" target=\"_blank\">Multiple var statements in JavaScript, not superfluous</a> - Ben Alman</li></ul><p><br /></p><p><strong>进一步阅读</strong></p><p><br /></p><ul><li><a href=\"https://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/\" target=\"_blank\">Understanding JavaScript Closures</a> - Angus Croll</li></ul><ul><li><a href=\"http://www.2ality.com/2013/06/basic-javascript.html\" target=\"_blank\">Basic JavaScript for the impatient programmer</a> - Dr. Axel Rauschmayer</li></ul><ul><li><a href=\"http://youmightnotneedjquery.com/\" target=\"_blank\">You Might Not Need jQuery</a> - Zack Bloom &amp; Adam Schwartz</li></ul><ul><li><a href=\"https://github.com/lukehoban/es6features\" target=\"_blank\">ES6 Features</a> - Luke Hoban</li></ul><ul><li><a href=\"https://github.com/bendc/frontend-guidelines\" target=\"_blank\">Frontend Guidelines</a> - Benjamin De Cock</li></ul><p><br /></p><p><strong>书籍</strong></p><p><br /></p><ul><li><a href=\"https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742\" target=\"_blank\">JavaScript: The Good Parts</a> - Douglas Crockford</li></ul><ul><li><a href=\"https://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752\" target=\"_blank\">JavaScript Patterns</a> - Stoyan Stefanov</li></ul><ul><li><a href=\"https://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X\" target=\"_blank\">Pro JavaScript Design Patterns</a>  - Ross Harmes and Dustin Diaz</li></ul><ul><li><a href=\"https://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309\" target=\"_blank\">High Performance Web Sites: Essential Knowledge for Front-End Engineers</a> - Steve Souders</li></ul><ul><li><a href=\"https://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680\" target=\"_blank\">Maintainable JavaScript</a> - Nicholas C. Zakas</li></ul><ul><li><a href=\"https://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X\" target=\"_blank\">JavaScript Web Applications</a> - Alex MacCaw</li></ul><ul><li><a href=\"https://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273\" target=\"_blank\">Pro JavaScript Techniques</a> - John Resig</li></ul><ul><li><a href=\"https://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595\" target=\"_blank\">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li></ul><ul><li><a href=\"https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X\" target=\"_blank\">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li></ul><ul><li><a href=\"http://humanjavascript.com/\" target=\"_blank\">Human JavaScript</a> - Henrik Joreteg</li></ul><ul><li><a href=\"http://superherojs.com/\" target=\"_blank\">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li></ul><ul><li><a href=\"http://jsbooks.revolunet.com/\" target=\"_blank\">JSBooks</a> - Julien Bouquillon</li></ul><ul><li><a href=\"https://www.manning.com/books/third-party-javascript\" target=\"_blank\">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li></ul><ul><li><a href=\"http://amzn.com/0321812182\" target=\"_blank\">Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript</a> - David Herman</li></ul><ul><li><a href=\"http://eloquentjavascript.net/\" target=\"_blank\">Eloquent JavaScript</a> - Marijn Haverbeke</li></ul><ul><li><a href=\"http://shop.oreilly.com/product/0636920033769.do\" target=\"_blank\">You Don’t Know JS: ES6 &amp; Beyond</a> - Kyle Simpson</li></ul><p><br /></p><p><strong>博客</strong></p><p><br /></p><ul><li><a href=\"http://javascriptweekly.com/\" target=\"_blank\">JavaScript Weekly</a></li></ul><ul><li><a href=\"https://javascriptweblog.wordpress.com/\" target=\"_blank\">JavaScript, JavaScript...</a></li></ul><ul><li><a href=\"https://bocoup.com/weblog\" target=\"_blank\">Bocoup Weblog</a></li></ul><ul><li><a href=\"http://www.adequatelygood.com/\" target=\"_blank\">Adequately Good</a></li></ul><ul><li><a href=\"https://www.nczonline.net/\" target=\"_blank\">NCZOnline</a></li></ul><ul><li><a href=\"http://perfectionkills.com/\" target=\"_blank\">Perfection Kills</a></li></ul><ul><li><a href=\"http://benalman.com/\" target=\"_blank\">Ben Alman</a></li></ul><ul><li><a href=\"http://dmitry.baranovskiy.com/\" target=\"_blank\">Dmitry Baranovskiy</a></li></ul><ul><li><a href=\"http://code.tutsplus.com/?s=javascript\" target=\"_blank\">nettuts</a></li></ul><p><br /></p><p><strong>播客</strong></p><p><br /></p><ul><li><a href=\"https://javascriptair.com/\" target=\"_blank\">JavaScript Air</a></li></ul><ul><li><a href=\"https://devchat.tv/js-jabber/\" target=\"_blank\">JavaScript Jabber</a></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"935a8bc4\"><a>JavaScript风格指南的指南</a></h2><p><br /></p><ul><li><a href=\"https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide\" target=\"_blank\">Reference</a></li></ul><p><br /></p><h2 id=\"20a28457\"><a>许可证</a></h2><p><br /></p><p>(The MIT License)</p><p><br /></p><p>Copyright (c) 2012 康兵奎</p><p><br /></p><p>Permission is hereby granted, free of charge, to any person obtaining<br />\na copy of this software and associated documentation files (the<br />\n'Software'), to deal in the Software without restriction, including<br />\nwithout limitation the rights to use, copy, modify, merge, publish,<br />\ndistribute, sublicense, and/or sell copies of the Software, and to<br />\npermit persons to whom the Software is furnished to do so, subject to<br />\nthe following conditions:</p><p><br /></p><p>The above copyright notice and this permission notice shall be<br />\nincluded in all copies or substantial portions of the Software.</p><p><br /></p><p>THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,<br />\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF<br />\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.<br />\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY<br />\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<br />\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE<br />\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><h2 id=\"d41d8cd9\"><br /></h2>",
    "body_lake": "<!doctype lake><p><u>转自 https://github.com/BingKui/javascript-zh</u></p><p><br /></p><p><em>一种写JavaScript更合理的代码风格。</em></p><p><br /></p><blockquote><p><strong>Note</strong>: 本指南假设你使用了 <a href=\"https://babeljs.io\" target=\"_blank\">Babel</a>, 并且要求你使用 <a href=\"https://npmjs.com/babel-preset-airbnb\" target=\"_blank\">babel-preset-airbnb</a> 或者其他同等资源。 并且假设你在你的应用中安装了 shims/polyfills ，使用<a href=\"https://npmjs.com/airbnb-browser-shims\" target=\"_blank\">airbnb-browser-shims</a> 或者相同功能。</p></blockquote><p>其他代码风格指南</p><p><br /></p><ul><li><a href=\"https://github.com/airbnb/javascript/tree/es5-deprecated/es5\" target=\"_blank\">ES5 (Deprecated)</a></li></ul><ul><li><a href=\"react/\">React</a></li></ul><ul><li><a href=\"css-in-javascript/\">CSS-in-JavaScript</a></li></ul><ul><li><a href=\"https://github.com/airbnb/css\" target=\"_blank\">CSS &amp; Sass</a></li></ul><ul><li><a href=\"https://github.com/airbnb/ruby\" target=\"_blank\">Ruby</a></li></ul><p><br /></p><h2 id=\"767fa455\"><a>目录</a></h2><p><br /></p><ol start=\"1\"><li><a href=\"#types\">类型</a></li></ol><ol start=\"2\"><li><a href=\"#references\">引用</a></li></ol><ol start=\"3\"><li><a href=\"#objects\">对象</a></li></ol><ol start=\"4\"><li><a href=\"#arrays\">数组</a></li></ol><ol start=\"5\"><li><a href=\"#destructuring\">解构</a></li></ol><ol start=\"6\"><li><a href=\"#strings\">字符</a></li></ol><ol start=\"7\"><li><a href=\"#functions\">方法</a></li></ol><ol start=\"8\"><li><a href=\"#arrow-functions\">箭头函数</a></li></ol><ol start=\"9\"><li><a href=\"#classes--constructors\">类和构造器</a></li></ol><ol start=\"10\"><li><a href=\"#modules\">模块</a></li></ol><ol start=\"11\"><li><a href=\"#iterators-and-generators\">迭代器和发生器</a></li></ol><ol start=\"12\"><li><a href=\"#properties\">属性</a></li></ol><ol start=\"13\"><li><a href=\"#variables\">变量</a></li></ol><ol start=\"14\"><li><a href=\"#hoisting\">提升</a></li></ol><ol start=\"15\"><li><a href=\"#comparison-operators--equality\">比较运算符和等号</a></li></ol><ol start=\"16\"><li><a href=\"#blocks\">块</a></li></ol><ol start=\"17\"><li><a href=\"#control-statements\">控制语句</a></li></ol><ol start=\"18\"><li><a href=\"#comments\">注释</a></li></ol><ol start=\"19\"><li><a href=\"#whitespace\">空白</a></li></ol><ol start=\"20\"><li><a href=\"#commas\">逗号</a></li></ol><ol start=\"21\"><li><a href=\"#semicolons\">分号</a></li></ol><ol start=\"22\"><li><a href=\"#type-casting--coercion\">类型转换和强制类型转换</a></li></ol><ol start=\"23\"><li><a href=\"#naming-conventions\">命名规范</a></li></ol><ol start=\"24\"><li><a href=\"#accessors\">存取器</a></li></ol><ol start=\"25\"><li><a href=\"#events\">事件</a></li></ol><ol start=\"26\"><li><a href=\"#jquery\">jQuery</a></li></ol><ol start=\"27\"><li><a href=\"#ecmascript-5-compatibility\">ECMAScript 5 兼容性</a></li></ol><ol start=\"28\"><li><a href=\"#ecmascript-6-es-2015-styles\">ECMAScript 6+ (ES 2015+) 风格</a></li></ol><ol start=\"29\"><li><a href=\"#standard-library\">标准库</a></li></ol><ol start=\"30\"><li><a href=\"#testing\">测试</a></li></ol><ol start=\"31\"><li><a href=\"#performance\">性能</a></li></ol><ol start=\"32\"><li><a href=\"#resources\">资源</a></li></ol><ol start=\"33\"><li><a href=\"#the-javascript-style-guide-guide\">JavaScript风格指南的指南</a></li></ol><ol start=\"34\"><li><a href=\"#license\">许可证</a></li></ol><ol start=\"35\"><li><a href=\"#amendments\">修正案</a></li></ol><p><br /></p><h2 id=\"226b0912\"><a>类型</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#types--primitives\">1.1</a> <strong>原始值</strong>: 当你访问一个原始类型的时候，你可以直接使用它的值。</li></ul><ul data-lake-indent=\"1\"><li><code>string</code></li></ul><ul data-lake-indent=\"1\"><li><code>number</code></li></ul><ul data-lake-indent=\"1\"><li><code>boolean</code></li></ul><ul data-lake-indent=\"1\"><li><code>null</code></li></ul><ul data-lake-indent=\"1\"><li><code>undefined</code></li></ul><ul data-lake-indent=\"1\"><li><code>symbol</code></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20foo%20%3D%201%3B%5Cnlet%20bar%20%3D%20foo%3B%5Cn%5Cnbar%20%3D%209%3B%5Cn%5Cnconsole.log(foo%2C%20bar)%3B%20%2F%2F%20%3D%3E%201%2C%209%22%7D\"></card><ul data-lake-indent=\"1\"><li>标识符不能完全被支持，因此在针对不支持的浏览器或者环境时不应该使用它们。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#types--complex\">1.2</a>  <strong>复杂类型</strong>: 当你访问一个复杂类型的时候，你需要一个值得引用。</li></ul><ul data-lake-indent=\"1\"><li><code>object</code></li></ul><ul data-lake-indent=\"1\"><li><code>array</code></li></ul><ul data-lake-indent=\"1\"><li><code>function</code></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20foo%20%3D%20%5B1%2C%202%5D%3B%5Cnconst%20bar%20%3D%20foo%3B%5Cn%5Cnbar%5B0%5D%20%3D%209%3B%5Cn%5Cnconsole.log(foo%5B0%5D%2C%20bar%5B0%5D)%3B%20%2F%2F%20%3D%3E%209%2C%209%22%7D\"></card><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"3b61c966\"><a>引用</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#references--prefer-const\">2.1</a> 使用 <code>const</code> 定义你的所有引用；避免使用 <code>var</code>。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-const.html\" target=\"_blank\"><code>prefer-const</code></a>, <a href=\"https://eslint.org/docs/rules/no-const-assign.html\" target=\"_blank\"><code>no-const-assign</code></a>\n<blockquote><p>为什么? 这样能够确保你不能重新赋值你的引用，否则可能导致错误或者产生难以理解的代码。.</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnvar%20a%20%3D%201%3B%5Cnvar%20b%20%3D%202%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20a%20%3D%201%3B%5Cnconst%20b%20%3D%202%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#references--disallow-var\">2.2</a> 如果你必须重新赋值你的引用， 使用 <code>let</code> 代替 <code>var</code>。 eslint: <a href=\"https://eslint.org/docs/rules/no-var.html\" target=\"_blank\"><code>no-var</code></a>\n<blockquote><p>为什么? <code>let</code> 是块级作用域，而不像 <code>var</code> 是函数作用域.</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnvar%20count%20%3D%201%3B%5Cnif%20(true)%20%7B%5Cn%20%20count%20%2B%3D%201%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%2C%20use%20the%20let.%5Cnlet%20count%20%3D%201%3B%5Cnif%20(true)%20%7B%5Cn%20%20count%20%2B%3D%201%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#references--block-scope\">2.3</a> 注意，let 和 const 都是块级范围的。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20const%20%E5%92%8C%20let%20%E5%8F%AA%E5%AD%98%E5%9C%A8%E4%BA%8E%E4%BB%96%E4%BB%AC%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9D%97%E4%B8%AD%E3%80%82%5Cn%7B%5Cn%20%20let%20a%20%3D%201%3B%5Cn%20%20const%20b%20%3D%201%3B%5Cn%7D%5Cnconsole.log(a)%3B%20%2F%2F%20ReferenceError%5Cnconsole.log(b)%3B%20%2F%2F%20ReferenceError%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"b1449413\"><a>对象</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#objects--no-new\">3.1</a> 使用字面语法来创建对象。 eslint: <a href=\"https://eslint.org/docs/rules/no-new-object.html\" target=\"_blank\"><code>no-new-object</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20item%20%3D%20new%20Object()%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20item%20%3D%20%7B%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-computed-properties\">3.2</a> 在创建具有动态属性名称的对象时使用计算属性名。\n<blockquote><p>为什么? 它允许你在一个地方定义对象的所有属性。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20getKey(k)%20%7B%5Cn%20%20return%20%60a%20key%20named%20%24%7Bk%7D%60%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20id%3A%205%2C%5Cn%20%20name%3A%20'San%20Francisco'%2C%5Cn%7D%3B%5Cnobj%5BgetKey('enabled')%5D%20%3D%20true%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20id%3A%205%2C%5Cn%20%20name%3A%20'San%20Francisco'%2C%5Cn%20%20%5BgetKey('enabled')%5D%3A%20true%2C%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-object-shorthand\">3.3</a> 使用对象方法的缩写。 eslint: <a href=\"https://eslint.org/docs/rules/object-shorthand.html\" target=\"_blank\"><code>object-shorthand</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20atom%20%3D%20%7B%5Cn%20%20value%3A%201%2C%5Cn%5Cn%20%20addValue%3A%20function%20(value)%20%7B%5Cn%20%20%20%20return%20atom.value%20%2B%20value%3B%5Cn%20%20%7D%2C%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20atom%20%3D%20%7B%5Cn%20%20value%3A%201%2C%5Cn%5Cn%20%20addValue(value)%20%7B%5Cn%20%20%20%20return%20atom.value%20%2B%20value%3B%5Cn%20%20%7D%2C%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-object-concise\">3.4</a> 使用属性值的缩写。 eslint: <a href=\"https://eslint.org/docs/rules/object-shorthand.html\" target=\"_blank\"><code>object-shorthand</code></a>\n<blockquote><p>为什么? 它的写法和描述较短。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20lukeSkywalker%20%3D%20'Luke%20Skywalker'%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20lukeSkywalker%3A%20lukeSkywalker%2C%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20lukeSkywalker%2C%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--grouped-shorthand\">3.5</a> 在对象声明的时候将简写的属性进行分组。\n<blockquote><p>为什么? 这样更容易的判断哪些属性使用的简写。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20anakinSkywalker%20%3D%20'Anakin%20Skywalker'%3B%5Cnconst%20lukeSkywalker%20%3D%20'Luke%20Skywalker'%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20episodeOne%3A%201%2C%5Cn%20%20twoJediWalkIntoACantina%3A%202%2C%5Cn%20%20lukeSkywalker%2C%5Cn%20%20episodeThree%3A%203%2C%5Cn%20%20mayTheFourth%3A%204%2C%5Cn%20%20anakinSkywalker%2C%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20lukeSkywalker%2C%5Cn%20%20anakinSkywalker%2C%5Cn%20%20episodeOne%3A%201%2C%5Cn%20%20twoJediWalkIntoACantina%3A%202%2C%5Cn%20%20episodeThree%3A%203%2C%5Cn%20%20mayTheFourth%3A%204%2C%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--quoted-props\">3.6</a> 只使用引号标注无效标识符的属性。 eslint: <a href=\"https://eslint.org/docs/rules/quote-props.html\" target=\"_blank\"><code>quote-props</code></a>\n<blockquote><p>为什么? 总的来说，我们认为这样更容易阅读。 它提升了语法高亮显示，并且更容易通过许多 JS 引擎优化。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20bad%20%3D%20%7B%5Cn%20%20'foo'%3A%203%2C%5Cn%20%20'bar'%3A%204%2C%5Cn%20%20'data-blah'%3A%205%2C%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20good%20%3D%20%7B%5Cn%20%20foo%3A%203%2C%5Cn%20%20bar%3A%204%2C%5Cn%20%20'data-blah'%3A%205%2C%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--prototype-builtins\">3.7</a> 不能直接调用 <code>Object.prototype</code> 的方法，如： <code>hasOwnProperty</code> 、 <code>propertyIsEnumerable</code> 和 <code>isPrototypeOf</code>。\n<blockquote><p>为什么? 这些方法可能被一下问题对象的属性追踪 - 相应的有 <code>{ hasOwnProperty: false }</code> - 或者，对象是一个空对象 (<code>Object.create(null)</code>)。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconsole.log(object.hasOwnProperty(key))%3B%5Cn%5Cn%2F%2F%20good%5Cnconsole.log(Object.prototype.hasOwnProperty.call(object%2C%20key))%3B%5Cn%5Cn%2F%2F%20best%5Cnconst%20has%20%3D%20Object.prototype.hasOwnProperty%3B%20%2F%2F%20%E5%9C%A8%E6%A8%A1%E5%9D%97%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E7%BC%93%E5%AD%98%E4%B8%AD%E6%9F%A5%E6%89%BE%E4%B8%80%E6%AC%A1%5Cn%2F*%20or%20*%2F%5Cnimport%20has%20from%20'has'%3B%20%2F%2F%20https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Fhas%5Cn%2F%2F%20...%5Cnconsole.log(has.call(object%2C%20key))%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#objects--rest-spread\">3.8</a> 更喜欢对象扩展操作符，而不是用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\" target=\"_blank\"><code>Object.assign</code></a> 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20very%20bad%5Cnconst%20original%20%3D%20%7B%20a%3A%201%2C%20b%3A%202%20%7D%3B%5Cnconst%20copy%20%3D%20Object.assign(original%2C%20%7B%20c%3A%203%20%7D)%3B%20%2F%2F%20%E5%8F%98%E5%BC%82%E7%9A%84%20%60original%60%20%E0%B2%A0_%E0%B2%A0%5Cndelete%20copy.a%3B%20%2F%2F%20%E8%BF%99....%5Cn%5Cn%2F%2F%20bad%5Cnconst%20original%20%3D%20%7B%20a%3A%201%2C%20b%3A%202%20%7D%3B%5Cnconst%20copy%20%3D%20Object.assign(%7B%7D%2C%20original%2C%20%7B%20c%3A%203%20%7D)%3B%20%2F%2F%20copy%20%3D%3E%20%7B%20a%3A%201%2C%20b%3A%202%2C%20c%3A%203%20%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20original%20%3D%20%7B%20a%3A%201%2C%20b%3A%202%20%7D%3B%5Cnconst%20copy%20%3D%20%7B%20...original%2C%20c%3A%203%20%7D%3B%20%2F%2F%20copy%20%3D%3E%20%7B%20a%3A%201%2C%20b%3A%202%2C%20c%3A%203%20%7D%5Cn%5Cnconst%20%7B%20a%2C%20...noA%20%7D%20%3D%20copy%3B%20%2F%2F%20noA%20%3D%3E%20%7B%20b%3A%202%2C%20c%3A%203%20%7D%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"0e67d4b0\"><a>数组</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--literals\">4.1</a> 使用字面语法创建数组。 eslint: <a href=\"https://eslint.org/docs/rules/no-array-constructor.html\" target=\"_blank\"><code>no-array-constructor</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20items%20%3D%20new%20Array()%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20items%20%3D%20%5B%5D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--push\">4.2</a> 使用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/push\" target=\"_blank\">Array#push</a> 取代直接赋值来给数组添加项。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20someStack%20%3D%20%5B%5D%3B%5Cn%5Cn%2F%2F%20bad%5CnsomeStack%5BsomeStack.length%5D%20%3D%20'abracadabra'%3B%5Cn%5Cn%2F%2F%20good%5CnsomeStack.push('abracadabra')%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-array-spreads\">4.3</a> 使用数组展开方法 <code>...</code> 来拷贝数组。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20len%20%3D%20items.length%3B%5Cnconst%20itemsCopy%20%3D%20%5B%5D%3B%5Cnlet%20i%3B%5Cn%5Cnfor%20(i%20%3D%200%3B%20i%20%3C%20len%3B%20i%20%2B%3D%201)%20%7B%5Cn%20%20itemsCopy%5Bi%5D%20%3D%20items%5Bi%5D%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20itemsCopy%20%3D%20%5B...items%5D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--from\">4.4</a> 将一个类数组对象转换成一个数组， 使用展开方法 <code>...</code> 代替 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\"><code>Array.from</code></a>。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20foo%20%3D%20document.querySelectorAll('.foo')%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20nodes%20%3D%20Array.from(foo)%3B%5Cn%5Cn%2F%2F%20best%5Cnconst%20nodes%20%3D%20%5B...foo%5D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--mapping\">4.5</a> 对于对迭代器的映射，使用 <a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from\" target=\"_blank\">Array.from</a> 替代展开方法 <code>...</code> ， 因为它避免了创建中间数组。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20baz%20%3D%20%5B...foo%5D.map(bar)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20baz%20%3D%20Array.from(foo%2C%20bar)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--callback-return\">4.6</a> 在数组回调方法中使用 return 语句。 如果函数体由一个返回无副作用的表达式的单个语句组成，那么可以省略返回值， 具体查看 <a href=\"#arrows--implicit-return\">8.2</a>。 eslint: <a href=\"https://eslint.org/docs/rules/array-callback-return\" target=\"_blank\"><code>array-callback-return</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map((x)%20%3D%3E%20%7B%5Cn%20%20const%20y%20%3D%20x%20%2B%201%3B%5Cn%20%20return%20x%20*%20y%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map(x%20%3D%3E%20x%20%2B%201)%3B%5Cn%5Cn%2F%2F%20bad%20-%20%E6%B2%A1%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%EF%BC%8C%E6%84%8F%E5%91%B3%E7%9D%80%E5%9C%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%AD%E4%BB%A3%E5%90%8E%20%60acc%60%20%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%AE%9A%E4%B9%89%5Cn%5B%5B0%2C%201%5D%2C%20%5B2%2C%203%5D%2C%20%5B4%2C%205%5D%5D.reduce((acc%2C%20item%2C%20index)%20%3D%3E%20%7B%5Cn%20%20const%20flatten%20%3D%20acc.concat(item)%3B%5Cn%20%20acc%5Bindex%5D%20%3D%20flatten%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B%5B0%2C%201%5D%2C%20%5B2%2C%203%5D%2C%20%5B4%2C%205%5D%5D.reduce((acc%2C%20item%2C%20index)%20%3D%3E%20%7B%5Cn%20%20const%20flatten%20%3D%20acc.concat(item)%3B%5Cn%20%20acc%5Bindex%5D%20%3D%20flatten%3B%5Cn%20%20return%20flatten%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20bad%5Cninbox.filter((msg)%20%3D%3E%20%7B%5Cn%20%20const%20%7B%20subject%2C%20author%20%7D%20%3D%20msg%3B%5Cn%20%20if%20(subject%20%3D%3D%3D%20'Mockingbird')%20%7B%5Cn%20%20%20%20return%20author%20%3D%3D%3D%20'Harper%20Lee'%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20return%20false%3B%5Cn%20%20%7D%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cninbox.filter((msg)%20%3D%3E%20%7B%5Cn%20%20const%20%7B%20subject%2C%20author%20%7D%20%3D%20msg%3B%5Cn%20%20if%20(subject%20%3D%3D%3D%20'Mockingbird')%20%7B%5Cn%20%20%20%20return%20author%20%3D%3D%3D%20'Harper%20Lee'%3B%5Cn%20%20%7D%5Cn%5Cn%20%20return%20false%3B%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrays--bracket-newline\">4.7</a> 如果数组有多行，则在开始的时候换行，然后在结束的时候换行。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20arr%20%3D%20%5B%5Cn%20%20%5B0%2C%201%5D%2C%20%5B2%2C%203%5D%2C%20%5B4%2C%205%5D%2C%5Cn%5D%3B%5Cn%5Cnconst%20objectInArray%20%3D%20%5B%7B%5Cn%20%20id%3A%201%2C%5Cn%7D%2C%20%7B%5Cn%20%20id%3A%202%2C%5Cn%7D%5D%3B%5Cn%5Cnconst%20numberInArray%20%3D%20%5B%5Cn%20%201%2C%202%2C%5Cn%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20arr%20%3D%20%5B%5B0%2C%201%5D%2C%20%5B2%2C%203%5D%2C%20%5B4%2C%205%5D%5D%3B%5Cn%5Cnconst%20objectInArray%20%3D%20%5B%5Cn%20%20%7B%5Cn%20%20%20%20id%3A%201%2C%5Cn%20%20%7D%2C%5Cn%20%20%7B%5Cn%20%20%20%20id%3A%202%2C%5Cn%20%20%7D%2C%5Cn%5D%3B%5Cn%5Cnconst%20numberInArray%20%3D%20%5B%5Cn%20%201%2C%5Cn%20%202%2C%5Cn%5D%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"2be143d5\"><a>解构</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#destructuring--object\">5.1</a> 在访问和使用对象的多个属性的时候使用对象的解构。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-destructuring\" target=\"_blank\"><code>prefer-destructuring</code></a>\n<blockquote><p>为什么? 解构可以避免为这些属性创建临时引用。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20getFullName(user)%20%7B%5Cn%20%20const%20firstName%20%3D%20user.firstName%3B%5Cn%20%20const%20lastName%20%3D%20user.lastName%3B%5Cn%5Cn%20%20return%20%60%24%7BfirstName%7D%20%24%7BlastName%7D%60%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20getFullName(user)%20%7B%5Cn%20%20const%20%7B%20firstName%2C%20lastName%20%7D%20%3D%20user%3B%5Cn%20%20return%20%60%24%7BfirstName%7D%20%24%7BlastName%7D%60%3B%5Cn%7D%5Cn%5Cn%2F%2F%20best%5Cnfunction%20getFullName(%7B%20firstName%2C%20lastName%20%7D)%20%7B%5Cn%20%20return%20%60%24%7BfirstName%7D%20%24%7BlastName%7D%60%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#destructuring--array\">5.2</a> 使用数组解构。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-destructuring\" target=\"_blank\"><code>prefer-destructuring</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20arr%20%3D%20%5B1%2C%202%2C%203%2C%204%5D%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20first%20%3D%20arr%5B0%5D%3B%5Cnconst%20second%20%3D%20arr%5B1%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20%5Bfirst%2C%20second%5D%20%3D%20arr%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#destructuring--object-over-array\">5.3</a> 对于多个返回值使用对象解构，而不是数组解构。\n<blockquote><p>为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20processInput(input)%20%7B%5Cn%20%20%2F%2F%20%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81...%5Cn%20%20return%20%5Bleft%2C%20right%2C%20top%2C%20bottom%5D%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E8%B0%83%E7%94%A8%E8%80%85%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E8%BF%94%E5%9B%9E%E6%95%B0%E6%8D%AE%E7%9A%84%E9%A1%BA%E5%BA%8F%E3%80%82%5Cnconst%20%5Bleft%2C%20__%2C%20top%5D%20%3D%20processInput(input)%3B%5Cn%5Cn%2F%2F%20good%5Cnfunction%20processInput(input)%20%7B%5Cn%20%20%2F%2F%20%E5%A4%84%E7%90%86%E4%BB%A3%E7%A0%81...%5Cn%20%20return%20%7B%20left%2C%20right%2C%20top%2C%20bottom%20%7D%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E8%B0%83%E7%94%A8%E8%80%85%E5%8F%AA%E9%80%89%E6%8B%A9%E4%BB%96%E4%BB%AC%E9%9C%80%E8%A6%81%E7%9A%84%E6%95%B0%E6%8D%AE%E3%80%82%5Cnconst%20%7B%20left%2C%20top%20%7D%20%3D%20processInput(input)%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"9c07532d\"><a>字符</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#strings--quotes\">6.1</a> 使用单引号 <code>''</code> 定义字符串。 eslint: <a href=\"https://eslint.org/docs/rules/quotes.html\" target=\"_blank\"><code>quotes</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20name%20%3D%20%5C%22Capt.%20Janeway%5C%22%3B%5Cn%5Cn%2F%2F%20bad%20-%20%E6%A8%A1%E6%9D%BF%E6%96%87%E5%AD%97%E5%BA%94%E8%AF%A5%E5%8C%85%E5%90%AB%E6%8F%92%E5%80%BC%E6%88%96%E6%8D%A2%E8%A1%8C%E3%80%82%5Cnconst%20name%20%3D%20%60Capt.%20Janeway%60%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20name%20%3D%20'Capt.%20Janeway'%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#strings--line-length\">6.2</a> 使行超过100个字符的字符串不应使用字符串连接跨多行写入。\n<blockquote><p>为什么? 断开的字符串更加难以工作，并且使代码搜索更加困难。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20errorMessage%20%3D%20'This%20is%20a%20super%20long%20error%20that%20was%20thrown%20because%20%5C%5C%5Cnof%20Batman.%20When%20you%20stop%20to%20think%20about%20how%20Batman%20had%20anything%20to%20do%20%5C%5C%5Cnwith%20this%2C%20you%20would%20get%20nowhere%20%5C%5C%5Cnfast.'%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20errorMessage%20%3D%20'This%20is%20a%20super%20long%20error%20that%20was%20thrown%20because%20'%20%2B%5Cn%20%20'of%20Batman.%20When%20you%20stop%20to%20think%20about%20how%20Batman%20had%20anything%20to%20do%20'%20%2B%5Cn%20%20'with%20this%2C%20you%20would%20get%20nowhere%20fast.'%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20errorMessage%20%3D%20'This%20is%20a%20super%20long%20error%20that%20was%20thrown%20because%20of%20Batman.%20When%20you%20stop%20to%20think%20about%20how%20Batman%20had%20anything%20to%20do%20with%20this%2C%20you%20would%20get%20nowhere%20fast.'%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-template-literals\">6.3</a> 当以编程模式构建字符串时，使用字符串模板代替字符串拼接。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-template.html\" target=\"_blank\"><code>prefer-template</code></a> <a href=\"https://eslint.org/docs/rules/template-curly-spacing\" target=\"_blank\"><code>template-curly-spacing</code></a>\n<blockquote><p>为什么? 字符串模板为您提供了一种可读的、简洁的语法，具有正确的换行和字符串插值特性。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20sayHi(name)%20%7B%5Cn%20%20return%20'How%20are%20you%2C%20'%20%2B%20name%20%2B%20'%3F'%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20sayHi(name)%20%7B%5Cn%20%20return%20%5B'How%20are%20you%2C%20'%2C%20name%2C%20'%3F'%5D.join()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20sayHi(name)%20%7B%5Cn%20%20return%20%60How%20are%20you%2C%20%24%7B%20name%20%7D%3F%60%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20sayHi(name)%20%7B%5Cn%20%20return%20%60How%20are%20you%2C%20%24%7Bname%7D%3F%60%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#strings--eval\">6.4</a> 不要在字符串上使用 <code>eval()</code> ，它打开了太多漏洞。 eslint: <a href=\"https://eslint.org/docs/rules/no-eval\" target=\"_blank\"><code>no-eval</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#strings--escaping\">6.5</a> 不要转义字符串中不必要的字符。 eslint: <a href=\"https://eslint.org/docs/rules/no-useless-escape\" target=\"_blank\"><code>no-useless-escape</code></a>\n<blockquote><p>为什么? 反斜杠损害了可读性，因此只有在必要的时候才会出现。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20'%5C%5C'this%5C%5C'%20%5C%5Ci%5C%5Cs%20%5C%5C%5C%22quoted%5C%5C%5C%22'%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20'%5C%5C'this%5C%5C'%20is%20%5C%22quoted%5C%22'%3B%5Cnconst%20foo%20%3D%20%60my%20name%20is%20'%24%7Bname%7D'%60%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ea340b9d\"><a>方法</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#functions--declarations\">7.1</a> 使用命名的函数表达式代替函数声明。 eslint: <a href=\"https://eslint.org/docs/rules/func-style\" target=\"_blank\"><code>func-style</code></a>\n<blockquote><p>为什么? 函数声明是挂起的，这意味着在它在文件中定义之前，很容易引用函数。这会损害可读性和可维护性。如果您发现函数的定义是大的或复杂的，以至于它干扰了对文件的其余部分的理解，那么也许是时候将它提取到它自己的模块中了!不要忘记显式地命名这个表达式，不管它的名称是否从包含变量(在现代浏览器中经常是这样，或者在使用诸如Babel之类的编译器时)。这消除了对错误的调用堆栈的任何假设。 (<a href=\"https://github.com/airbnb/javascript/issues/794\" target=\"_blank\">Discussion</a>)</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnconst%20foo%20%3D%20function%20()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cn%2F%2F%20%E4%BB%8E%E5%8F%98%E9%87%8F%E5%BC%95%E7%94%A8%E8%B0%83%E7%94%A8%E4%B8%AD%E5%8C%BA%E5%88%86%E7%9A%84%E8%AF%8D%E6%B1%87%E5%90%8D%E7%A7%B0%5Cnconst%20short%20%3D%20function%20longUniqueMoreDescriptiveLexicalFoo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--iife\">7.2</a> Wrap立即调用函数表达式。 eslint: <a href=\"https://eslint.org/docs/rules/wrap-iife.html\" target=\"_blank\"><code>wrap-iife</code></a>\n<blockquote><p>为什么? 立即调用的函数表达式是单个单元 - 包装， 并且拥有括号调用, 在括号内, 清晰的表达式。 请注意，在一个到处都是模块的世界中，您几乎不需要一个 IIFE 。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20immediately-invoked%20function%20expression%20(IIFE)%20%E7%AB%8B%E5%8D%B3%E8%B0%83%E7%94%A8%E7%9A%84%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%5Cn(function%20()%20%7B%5Cn%20%20console.log('Welcome%20to%20the%20Internet.%20Please%20follow%20me.')%3B%5Cn%7D())%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--in-blocks\">7.3</a> 切记不要在非功能块中声明函数 (<code>if</code>, <code>while</code>, 等)。 将函数赋值给变量。 浏览器允许你这样做，但是他们都有不同的解释，这是个坏消息。 eslint: <a href=\"https://eslint.org/docs/rules/no-loop-func.html\" target=\"_blank\"><code>no-loop-func</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--note-on-blocks\">7.4</a> <strong>注意:</strong> ECMA-262 将 <code>block</code> 定义为语句列表。 函数声明不是语句。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20(currentUser)%20%7B%5Cn%20%20function%20test()%20%7B%5Cn%20%20%20%20console.log('Nope.')%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnlet%20test%3B%5Cnif%20(currentUser)%20%7B%5Cn%20%20test%20%3D%20()%20%3D%3E%20%7B%5Cn%20%20%20%20console.log('Yup.')%3B%5Cn%20%20%7D%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--arguments-shadow\">7.5</a> 永远不要定义一个参数为 <code>arguments</code>。 这将会优先于每个函数给定范围的 <code>arguments</code> 对象。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo(name%2C%20options%2C%20arguments)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20foo(name%2C%20options%2C%20args)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-rest\">7.6</a> 不要使用 <code>arguments</code>, 选择使用 rest 语法 <code>...</code> 代替。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-rest-params\" target=\"_blank\"><code>prefer-rest-params</code></a>\n<blockquote><p>为什么? <code>...</code> 明确了你想要拉取什么参数。 更甚, rest 参数是一个真正的数组，而不仅仅是类数组的 <code>arguments</code> 。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20concatenateAll()%20%7B%5Cn%20%20const%20args%20%3D%20Array.prototype.slice.call(arguments)%3B%5Cn%20%20return%20args.join('')%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20concatenateAll(...args)%20%7B%5Cn%20%20return%20args.join('')%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es6-default-parameters\">7.7</a> 使用默认的参数语法，而不是改变函数参数。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20really%20bad%5Cnfunction%20handleThings(opts)%20%7B%5Cn%20%20%2F%2F%20No!%20We%20shouldn%E2%80%99t%20mutate%20function%20arguments.%5Cn%20%20%2F%2F%20Double%20bad%3A%20if%20opts%20is%20falsy%20it'll%20be%20set%20to%20an%20object%20which%20may%5Cn%20%20%2F%2F%20be%20what%20you%20want%20but%20it%20can%20introduce%20subtle%20bugs.%5Cn%20%20opts%20%3D%20opts%20%7C%7C%20%7B%7D%3B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20still%20bad%5Cnfunction%20handleThings(opts)%20%7B%5Cn%20%20if%20(opts%20%3D%3D%3D%20void%200)%20%7B%5Cn%20%20%20%20opts%20%3D%20%7B%7D%3B%5Cn%20%20%7D%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20handleThings(opts%20%3D%20%7B%7D)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--default-side-effects\">7.8</a> 避免使用默认参数的副作用。\n<blockquote><p>为什么? 他们很容易混淆。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20b%20%3D%201%3B%5Cn%2F%2F%20bad%5Cnfunction%20count(a%20%3D%20b%2B%2B)%20%7B%5Cn%20%20console.log(a)%3B%5Cn%7D%5Cncount()%3B%20%20%2F%2F%201%5Cncount()%3B%20%20%2F%2F%202%5Cncount(3)%3B%20%2F%2F%203%5Cncount()%3B%20%20%2F%2F%203%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--defaults-last\">7.9</a> 总是把默认参数放在最后。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20handleThings(opts%20%3D%20%7B%7D%2C%20name)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20handleThings(name%2C%20opts%20%3D%20%7B%7D)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--constructor\">7.10</a> 永远不要使用函数构造器来创建一个新函数。 eslint: <a href=\"https://eslint.org/docs/rules/no-new-func\" target=\"_blank\"><code>no-new-func</code></a>\n<blockquote><p>为什么? 以这种方式创建一个函数将对一个类似于 <code>eval()</code> 的字符串进行计算，这将打开漏洞。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnvar%20add%20%3D%20new%20Function('a'%2C%20'b'%2C%20'return%20a%20%2B%20b')%3B%5Cn%5Cn%2F%2F%20still%20bad%5Cnvar%20subtract%20%3D%20Function('a'%2C%20'b'%2C%20'return%20a%20-%20b')%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--signature-spacing\">7.11</a> 函数签名中的间距。 eslint: <a href=\"https://eslint.org/docs/rules/space-before-function-paren\" target=\"_blank\"><code>space-before-function-paren</code></a> <a href=\"https://eslint.org/docs/rules/space-before-blocks\" target=\"_blank\"><code>space-before-blocks</code></a>\n<blockquote><p>为什么? 一致性很好，在删除或添加名称时不需要添加或删除空格。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20f%20%3D%20function()%7B%7D%3B%5Cnconst%20g%20%3D%20function%20()%7B%7D%3B%5Cnconst%20h%20%3D%20function()%20%7B%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20x%20%3D%20function%20()%20%7B%7D%3B%5Cnconst%20y%20%3D%20function%20a()%20%7B%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--mutate-params\">7.12</a> 没用变异参数。 eslint: <a href=\"https://eslint.org/docs/rules/no-param-reassign.html\" target=\"_blank\"><code>no-param-reassign</code></a>\n<blockquote><p>为什么? 将传入的对象作为参数进行操作可能会在原始调用程序中造成不必要的变量副作用。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20f1(obj)%20%7B%5Cn%20%20obj.key%20%3D%201%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20f2(obj)%20%7B%5Cn%20%20const%20key%20%3D%20Object.prototype.hasOwnProperty.call(obj%2C%20'key')%20%3F%20obj.key%20%3A%201%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--reassign-params\">7.13</a> 不要再赋值参数。 eslint: <a href=\"https://eslint.org/docs/rules/no-param-reassign.html\" target=\"_blank\"><code>no-param-reassign</code></a>\n<blockquote><p>为什么? 重新赋值参数会导致意外的行为，尤其是在访问 <code>arguments</code> 对象的时候。 它还可能导致性能优化问题，尤其是在 V8 中。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20f1(a)%20%7B%5Cn%20%20a%20%3D%201%3B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cnfunction%20f2(a)%20%7B%5Cn%20%20if%20(!a)%20%7B%20a%20%3D%201%3B%20%7D%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20f3(a)%20%7B%5Cn%20%20const%20b%20%3D%20a%20%7C%7C%201%3B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cnfunction%20f4(a%20%3D%201)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--spread-vs-apply\">7.14</a> 优先使用扩展运算符 <code>...</code> 来调用可变参数函数。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-spread\" target=\"_blank\"><code>prefer-spread</code></a>\n<blockquote><p>为什么? 它更加干净，你不需要提供上下文，并且你不能轻易的使用 <code>apply</code> 来 <code>new</code> 。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20x%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%5Cnconsole.log.apply(console%2C%20x)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20x%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%5Cnconsole.log(...x)%3B%5Cn%5Cn%2F%2F%20bad%5Cnnew%20(Function.prototype.bind.apply(Date%2C%20%5Bnull%2C%202016%2C%208%2C%205%5D))%3B%5Cn%5Cn%2F%2F%20good%5Cnnew%20Date(...%5B2016%2C%208%2C%205%5D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#functions--signature-invocation-indentation\">7.15</a> 具有多行签名或者调用的函数应该像本指南中的其他多行列表一样缩进：在一行上只有一个条目，并且每个条目最后加上逗号。 eslint: <a href=\"https://eslint.org/docs/rules/function-paren-newline\" target=\"_blank\"><code>function-paren-newline</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo(bar%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20baz%2C%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20quux)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20foo(%5Cn%20%20bar%2C%5Cn%20%20baz%2C%5Cn%20%20quux%2C%5Cn)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnconsole.log(foo%2C%5Cn%20%20bar%2C%5Cn%20%20baz)%3B%5Cn%5Cn%2F%2F%20good%5Cnconsole.log(%5Cn%20%20foo%2C%5Cn%20%20bar%2C%5Cn%20%20baz%2C%5Cn)%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"d86f8699\"><a>箭头函数</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--use-them\">8.1</a> 当你必须使用匿名函数时 (当传递内联函数时)， 使用箭头函数。 eslint: <a href=\"https://eslint.org/docs/rules/prefer-arrow-callback.html\" target=\"_blank\"><code>prefer-arrow-callback</code></a>, <a href=\"https://eslint.org/docs/rules/arrow-spacing.html\" target=\"_blank\"><code>arrow-spacing</code></a>\n<blockquote><p>为什么? 它创建了一个在 <code>this</code> 上下文中执行的函数版本，它通常是你想要的，并且是一个更简洁的语法。</p></blockquote><blockquote><p>为什么不? 如果你有一个相当复杂的函数，你可以把这个逻辑转移到它自己的命名函数表达式中。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%5B1%2C%202%2C%203%5D.map(function%20(x)%20%7B%5Cn%20%20const%20y%20%3D%20x%20%2B%201%3B%5Cn%20%20return%20x%20*%20y%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map((x)%20%3D%3E%20%7B%5Cn%20%20const%20y%20%3D%20x%20%2B%201%3B%5Cn%20%20return%20x%20*%20y%3B%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--implicit-return\">8.2</a> 如果函数体包含一个单独的语句，返回一个没有副作用的 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions\" target=\"_blank\">expression</a> ， 省略括号并使用隐式返回。否则，保留括号并使用 <code>return</code> 语句。 eslint: <a href=\"https://eslint.org/docs/rules/arrow-parens.html\" target=\"_blank\"><code>arrow-parens</code></a>, <a href=\"https://eslint.org/docs/rules/arrow-body-style.html\" target=\"_blank\"><code>arrow-body-style</code></a>\n<blockquote><p>为什么? 语法糖。 多个函数被链接在一起时，提高可读性。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%5B1%2C%202%2C%203%5D.map(number%20%3D%3E%20%7B%5Cn%20%20const%20nextNumber%20%3D%20number%20%2B%201%3B%5Cn%20%20%60A%20string%20containing%20the%20%24%7BnextNumber%7D.%60%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map(number%20%3D%3E%20%60A%20string%20containing%20the%20%24%7Bnumber%7D.%60)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map((number)%20%3D%3E%20%7B%5Cn%20%20const%20nextNumber%20%3D%20number%20%2B%201%3B%5Cn%20%20return%20%60A%20string%20containing%20the%20%24%7BnextNumber%7D.%60%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map((number%2C%20index)%20%3D%3E%20(%7B%5Cn%20%20%5Bindex%5D%3A%20number%2C%5Cn%7D))%3B%5Cn%5Cn%2F%2F%20%E6%B2%A1%E6%9C%89%E5%89%AF%E4%BD%9C%E7%94%A8%E7%9A%84%E9%9A%90%E5%BC%8F%E8%BF%94%E5%9B%9E%5Cnfunction%20foo(callback)%20%7B%5Cn%20%20const%20val%20%3D%20callback()%3B%5Cn%20%20if%20(val%20%3D%3D%3D%20true)%20%7B%5Cn%20%20%20%20%2F%2F%20%E5%A6%82%E6%9E%9C%E5%9B%9E%E8%B0%83%E8%BF%94%E5%9B%9E%20true%20%E6%89%A7%E8%A1%8C%5Cn%20%20%7D%5Cn%7D%5Cn%5Cnlet%20bool%20%3D%20false%3B%5Cn%5Cn%2F%2F%20bad%5Cnfoo(()%20%3D%3E%20bool%20%3D%20true)%3B%5Cn%5Cn%2F%2F%20good%5Cnfoo(()%20%3D%3E%20%7B%5Cn%20%20bool%20%3D%20true%3B%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--paren-wrap\">8.3</a> 如果表达式跨越多个行，用括号将其括起来，以获得更好的可读性。\n<blockquote><p>为什么? 它清楚地显示了函数的起点和终点。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%5B'get'%2C%20'post'%2C%20'put'%5D.map(httpMethod%20%3D%3E%20Object.prototype.hasOwnProperty.call(%5Cn%20%20%20%20httpMagicObjectWithAVeryLongName%2C%5Cn%20%20%20%20httpMethod%2C%5Cn%20%20)%5Cn)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B'get'%2C%20'post'%2C%20'put'%5D.map(httpMethod%20%3D%3E%20(%5Cn%20%20Object.prototype.hasOwnProperty.call(%5Cn%20%20%20%20httpMagicObjectWithAVeryLongName%2C%5Cn%20%20%20%20httpMethod%2C%5Cn%20%20)%5Cn))%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--one-arg-parens\">8.4</a> 如果你的函数接收一个参数，则可以不用括号，省略括号。 否则，为了保证清晰和一致性，需要在参数周围加上括号。 注意：总是使用括号是可以接受的，在这种情况下，我们使用 <a href=\"https://eslint.org/docs/rules/arrow-parens#always\" target=\"_blank\">“always” option</a> 来配置 eslint. eslint: <a href=\"https://eslint.org/docs/rules/arrow-parens.html\" target=\"_blank\"><code>arrow-parens</code></a>\n<blockquote><p>为什么? 减少视觉上的混乱。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%5B1%2C%202%2C%203%5D.map((x)%20%3D%3E%20x%20*%20x)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map(x%20%3D%3E%20x%20*%20x)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map(number%20%3D%3E%20(%5Cn%20%20%60A%20long%20string%20with%20the%20%24%7Bnumber%7D.%20It%E2%80%99s%20so%20long%20that%20we%20don%E2%80%99t%20want%20it%20to%20take%20up%20space%20on%20the%20.map%20line!%60%5Cn))%3B%5Cn%5Cn%2F%2F%20bad%5Cn%5B1%2C%202%2C%203%5D.map(x%20%3D%3E%20%7B%5Cn%20%20const%20y%20%3D%20x%20%2B%201%3B%5Cn%20%20return%20x%20*%20y%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cn%5B1%2C%202%2C%203%5D.map((x)%20%3D%3E%20%7B%5Cn%20%20const%20y%20%3D%20x%20%2B%201%3B%5Cn%20%20return%20x%20*%20y%3B%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#arrows--confusing\">8.5</a> 避免箭头函数符号 (<code>=&gt;</code>) 和比较运算符 (<code>&lt;=</code>, <code>&gt;=</code>) 的混淆。 eslint: <a href=\"https://eslint.org/docs/rules/no-confusing-arrow\" target=\"_blank\"><code>no-confusing-arrow</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20itemHeight%20%3D%20item%20%3D%3E%20item.height%20%3E%20256%20%3F%20item.largeSize%20%3A%20item.smallSize%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20itemHeight%20%3D%20(item)%20%3D%3E%20item.height%20%3E%20256%20%3F%20item.largeSize%20%3A%20item.smallSize%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20itemHeight%20%3D%20item%20%3D%3E%20(item.height%20%3E%20256%20%3F%20item.largeSize%20%3A%20item.smallSize)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20itemHeight%20%3D%20(item)%20%3D%3E%20%7B%5Cn%20%20const%20%7B%20height%2C%20largeSize%2C%20smallSize%20%7D%20%3D%20item%3B%5Cn%20%20return%20height%20%3E%20256%20%3F%20largeSize%20%3A%20smallSize%3B%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--implicit-arrow-linebreak\">8.6</a> 注意带有隐式返回的箭头函数函数体的位置。 eslint: <a href=\"https://eslint.org/docs/rules/implicit-arrow-linebreak\" target=\"_blank\"><code>implicit-arrow-linebreak</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn(foo)%20%3D%3E%5Cn%20%20bar%3B%5Cn%5Cn(foo)%20%3D%3E%5Cn%20%20(bar)%3B%5Cn%5Cn%2F%2F%20good%5Cn(foo)%20%3D%3E%20bar%3B%5Cn(foo)%20%3D%3E%20(bar)%3B%5Cn(foo)%20%3D%3E%20(%5Cn%20%20%20bar%5Cn)%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"93d5dc10\"><a>类和构造器</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--use-class\">9.1</a> 尽量使用 <code>class</code>. 避免直接操作 <code>prototype</code> .\n<blockquote><p>为什么? <code>class</code> 语法更简洁，更容易推理。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20Queue(contents%20%3D%20%5B%5D)%20%7B%5Cn%20%20this.queue%20%3D%20%5B...contents%5D%3B%5Cn%7D%5CnQueue.prototype.pop%20%3D%20function%20()%20%7B%5Cn%20%20const%20value%20%3D%20this.queue%5B0%5D%3B%5Cn%20%20this.queue.splice(0%2C%201)%3B%5Cn%20%20return%20value%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnclass%20Queue%20%7B%5Cn%20%20constructor(contents%20%3D%20%5B%5D)%20%7B%5Cn%20%20%20%20this.queue%20%3D%20%5B...contents%5D%3B%5Cn%20%20%7D%5Cn%20%20pop()%20%7B%5Cn%20%20%20%20const%20value%20%3D%20this.queue%5B0%5D%3B%5Cn%20%20%20%20this.queue.splice(0%2C%201)%3B%5Cn%20%20%20%20return%20value%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--extends\">9.2</a> 使用 <code>extends</code> 来扩展继承。\n<blockquote><p>为什么? 它是一个内置的方法，可以在不破坏 <code>instanceof</code> 的情况下继承原型功能。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20inherits%20%3D%20require('inherits')%3B%5Cnfunction%20PeekableQueue(contents)%20%7B%5Cn%20%20Queue.apply(this%2C%20contents)%3B%5Cn%7D%5Cninherits(PeekableQueue%2C%20Queue)%3B%5CnPeekableQueue.prototype.peek%20%3D%20function%20()%20%7B%5Cn%20%20return%20this.queue%5B0%5D%3B%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnclass%20PeekableQueue%20extends%20Queue%20%7B%5Cn%20%20peek()%20%7B%5Cn%20%20%20%20return%20this.queue%5B0%5D%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--chaining\">9.3</a> 方法返回了 <code>this</code> 来供其内部方法调用。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5CnJedi.prototype.jump%20%3D%20function%20()%20%7B%5Cn%20%20this.jumping%20%3D%20true%3B%5Cn%20%20return%20true%3B%5Cn%7D%3B%5Cn%5CnJedi.prototype.setHeight%20%3D%20function%20(height)%20%7B%5Cn%20%20this.height%20%3D%20height%3B%5Cn%7D%3B%5Cn%5Cnconst%20luke%20%3D%20new%20Jedi()%3B%5Cnluke.jump()%3B%20%2F%2F%20%3D%3E%20true%5Cnluke.setHeight(20)%3B%20%2F%2F%20%3D%3E%20undefined%5Cn%5Cn%2F%2F%20good%5Cnclass%20Jedi%20%7B%5Cn%20%20jump()%20%7B%5Cn%20%20%20%20this.jumping%20%3D%20true%3B%5Cn%20%20%20%20return%20this%3B%5Cn%20%20%7D%5Cn%5Cn%20%20setHeight(height)%20%7B%5Cn%20%20%20%20this.height%20%3D%20height%3B%5Cn%20%20%20%20return%20this%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cnconst%20luke%20%3D%20new%20Jedi()%3B%5Cn%5Cnluke.jump()%5Cn%20%20.setHeight(20)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--tostring\">9.4</a> 只要在确保能正常工作并且不产生任何副作用的情况下，编写一个自定义的 <code>toString()</code> 方法也是可以的。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Jedi%20%7B%5Cn%20%20constructor(options%20%3D%20%7B%7D)%20%7B%5Cn%20%20%20%20this.name%20%3D%20options.name%20%7C%7C%20'no%20name'%3B%5Cn%20%20%7D%5Cn%5Cn%20%20getName()%20%7B%5Cn%20%20%20%20return%20this.name%3B%5Cn%20%20%7D%5Cn%5Cn%20%20toString()%20%7B%5Cn%20%20%20%20return%20%60Jedi%20-%20%24%7Bthis.getName()%7D%60%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#constructors--no-useless\">9.5</a> 如果没有指定类，则类具有默认的构造器。 一个空的构造器或是一个代表父类的函数是没有必要的。 eslint: <a href=\"https://eslint.org/docs/rules/no-useless-constructor\" target=\"_blank\"><code>no-useless-constructor</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnclass%20Jedi%20%7B%5Cn%20%20constructor()%20%7B%7D%5Cn%5Cn%20%20getName()%20%7B%5Cn%20%20%20%20return%20this.name%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnclass%20Rey%20extends%20Jedi%20%7B%5Cn%20%20constructor(...args)%20%7B%5Cn%20%20%20%20super(...args)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnclass%20Rey%20extends%20Jedi%20%7B%5Cn%20%20constructor(...args)%20%7B%5Cn%20%20%20%20super(...args)%3B%5Cn%20%20%20%20this.name%20%3D%20'Rey'%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#classes--no-duplicate-members\">9.6</a> 避免定义重复的类成员。 eslint: <a href=\"https://eslint.org/docs/rules/no-dupe-class-members\" target=\"_blank\"><code>no-dupe-class-members</code></a>\n<blockquote><p>为什么? 重复的类成员声明将会默认倾向于最后一个 - 具有重复的类成员可以说是一个错误。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnclass%20Foo%20%7B%5Cn%20%20bar()%20%7B%20return%201%3B%20%7D%5Cn%20%20bar()%20%7B%20return%202%3B%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnclass%20Foo%20%7B%5Cn%20%20bar()%20%7B%20return%201%3B%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnclass%20Foo%20%7B%5Cn%20%20bar()%20%7B%20return%202%3B%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"fac54c34\"><a>模块</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#modules--use-them\">10.1</a> 你可能经常使用模块 (<code>import</code>/<code>export</code>) 在一些非标准模块的系统上。 你也可以在你喜欢的模块系统上相互转换。\n<blockquote><p>为什么? 模块是未来的趋势，让我们拥抱未来。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20AirbnbStyleGuide%20%3D%20require('.%2FAirbnbStyleGuide')%3B%5Cnmodule.exports%20%3D%20AirbnbStyleGuide.es6%3B%5Cn%5Cn%2F%2F%20ok%5Cnimport%20AirbnbStyleGuide%20from%20'.%2FAirbnbStyleGuide'%3B%5Cnexport%20default%20AirbnbStyleGuide.es6%3B%5Cn%5Cn%2F%2F%20best%5Cnimport%20%7B%20es6%20%7D%20from%20'.%2FAirbnbStyleGuide'%3B%5Cnexport%20default%20es6%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-wildcard\">10.2</a> 不要使用通配符导入。\n<blockquote><p>为什么? 这确定你有一个单独的默认导出。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20*%20as%20AirbnbStyleGuide%20from%20'.%2FAirbnbStyleGuide'%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20AirbnbStyleGuide%20from%20'.%2FAirbnbStyleGuide'%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-export-from-import\">10.3</a> 不要直接从导入导出。\n<blockquote><p>为什么? 虽然写在一行很简洁，但是有一个明确的导入和一个明确的导出能够保证一致性。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%2F%2F%20filename%20es6.js%5Cnexport%20%7B%20es6%20as%20default%20%7D%20from%20'.%2FAirbnbStyleGuide'%3B%5Cn%5Cn%2F%2F%20good%5Cn%2F%2F%20filename%20es6.js%5Cnimport%20%7B%20es6%20%7D%20from%20'.%2FAirbnbStyleGuide'%3B%5Cnexport%20default%20es6%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-duplicate-imports\">10.4</a> 只从一个路径导入所有需要的东西。<br />\neslint: <a href=\"https://eslint.org/docs/rules/no-duplicate-imports\" target=\"_blank\"><code>no-duplicate-imports</code></a>\n<blockquote><p>为什么? 从同一个路径导入多个行，使代码更难以维护。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20foo%20from%20'foo'%3B%5Cn%2F%2F%20%E2%80%A6%20%E5%85%B6%E4%BB%96%E5%AF%BC%E5%85%A5%20%E2%80%A6%20%2F%2F%5Cnimport%20%7B%20named1%2C%20named2%20%7D%20from%20'foo'%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20foo%2C%20%7B%20named1%2C%20named2%20%7D%20from%20'foo'%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20foo%2C%20%7B%5Cn%20%20named1%2C%5Cn%20%20named2%2C%5Cn%7D%20from%20'foo'%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-mutable-exports\">10.5</a> 不要导出可变的引用。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-mutable-exports.md\" target=\"_blank\"><code>import/no-mutable-exports</code></a>\n<blockquote><p>为什么? 在一般情况下，应该避免发生突变，但是在导出可变引用时及其容易发生突变。虽然在某些特殊情况下，可能需要这样，但是一般情况下只需要导出常量引用。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnlet%20foo%20%3D%203%3B%5Cnexport%20%7B%20foo%20%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%203%3B%5Cnexport%20%7B%20foo%20%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--prefer-default-export\">10.6</a> 在单个导出的模块中，选择默认模块而不是指定的导出。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/prefer-default-export.md\" target=\"_blank\"><code>import/prefer-default-export</code></a>\n<blockquote><p>为什么? 为了鼓励更多的文件只导出一件东西，这样可读性和可维护性更好。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnexport%20function%20foo()%20%7B%7D%5Cn%5Cn%2F%2F%20good%5Cnexport%20default%20function%20foo()%20%7B%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--imports-first\">10.7</a> 将所有的 <code>import</code>s 语句放在所有非导入语句的上边。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/first.md\" target=\"_blank\"><code>import/first</code></a>\n<blockquote><p>为什么? 由于所有的 <code>import</code>s 都被提前，保持他们在顶部是为了防止意外发生。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20foo%20from%20'foo'%3B%5Cnfoo.init()%3B%5Cn%5Cnimport%20bar%20from%20'bar'%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20foo%20from%20'foo'%3B%5Cnimport%20bar%20from%20'bar'%3B%5Cn%5Cnfoo.init()%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--multiline-imports-over-newlines\">10.8</a> 多行导入应该像多行数组和对象一样缩进。\n<blockquote><p>为什么? 花括号和其他规范一样，遵循相同的缩进规则，后边的都好一样。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20%7BlongNameA%2C%20longNameB%2C%20longNameC%2C%20longNameD%2C%20longNameE%7D%20from%20'path'%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20%7B%5Cn%20%20longNameA%2C%5Cn%20%20longNameB%2C%5Cn%20%20longNameC%2C%5Cn%20%20longNameD%2C%5Cn%20%20longNameE%2C%5Cn%7D%20from%20'path'%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#modules--no-webpack-loader-syntax\">10.9</a> 在模块导入语句中禁止使用 Webpack 加载器语法。<br />\neslint: <a href=\"https://github.com/benmosher/eslint-plugin-import/blob/master/docs/rules/no-webpack-loader-syntax.md\" target=\"_blank\"><code>import/no-webpack-loader-syntax</code></a>\n<blockquote><p>为什么? 因为在导入语句中使用 webpack 语法，将代码和模块绑定在一起。应该在 <code>webpack.config.js</code> 中使用加载器语法。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20fooSass%20from%20'css!sass!foo.scss'%3B%5Cnimport%20barCss%20from%20'style!css!bar.css'%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20fooSass%20from%20'foo.scss'%3B%5Cnimport%20barCss%20from%20'bar.css'%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"3caad93c\"><a>迭代器和发生器</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#iterators--nope\">11.1</a> 不要使用迭代器。 你应该使用 JavaScript 的高阶函数代替 <code>for-in</code> 或者 <code>for-of</code>。 eslint: <a href=\"https://eslint.org/docs/rules/no-iterator.html\" target=\"_blank\"><code>no-iterator</code></a> <a href=\"https://eslint.org/docs/rules/no-restricted-syntax\" target=\"_blank\"><code>no-restricted-syntax</code></a>\n<blockquote><p>为什么? 这是我们强制的规则。 拥有返回值得纯函数比这个更容易解释。</p></blockquote><blockquote><p>使用 <code>map()</code> / <code>every()</code> / <code>filter()</code> / <code>find()</code> / <code>findIndex()</code> / <code>reduce()</code> / <code>some()</code> / ... 遍历数组， 和使用 <code>Object.keys()</code> / <code>Object.values()</code> / <code>Object.entries()</code> 迭代你的对象生成数组。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20numbers%20%3D%20%5B1%2C%202%2C%203%2C%204%2C%205%5D%3B%5Cn%5Cn%2F%2F%20bad%5Cnlet%20sum%20%3D%200%3B%5Cnfor%20(let%20num%20of%20numbers)%20%7B%5Cn%20%20sum%20%2B%3D%20num%3B%5Cn%7D%5Cnsum%20%3D%3D%3D%2015%3B%5Cn%5Cn%2F%2F%20good%5Cnlet%20sum%20%3D%200%3B%5Cnnumbers.forEach((num)%20%3D%3E%20%7B%5Cn%20%20sum%20%2B%3D%20num%3B%5Cn%7D)%3B%5Cnsum%20%3D%3D%3D%2015%3B%5Cn%5Cn%2F%2F%20best%20(use%20the%20functional%20force)%5Cnconst%20sum%20%3D%20numbers.reduce((total%2C%20num)%20%3D%3E%20total%20%2B%20num%2C%200)%3B%5Cnsum%20%3D%3D%3D%2015%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20increasedByOne%20%3D%20%5B%5D%3B%5Cnfor%20(let%20i%20%3D%200%3B%20i%20%3C%20numbers.length%3B%20i%2B%2B)%20%7B%5Cn%20%20increasedByOne.push(numbers%5Bi%5D%20%2B%201)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20increasedByOne%20%3D%20%5B%5D%3B%5Cnnumbers.forEach((num)%20%3D%3E%20%7B%5Cn%20%20increasedByOne.push(num%20%2B%201)%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20best%20(keeping%20it%20functional)%5Cnconst%20increasedByOne%20%3D%20numbers.map(num%20%3D%3E%20num%20%2B%201)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#generators--nope\">11.2</a> 不要使用发生器。\n<blockquote><p>为什么? 它们不能很好的适应 ES5。</p></blockquote></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#generators--spacing\">11.3</a> 如果你必须使用发生器或者无视 <a href=\"#generators--nope\">我们的建议</a>，请确保他们的函数签名是正常的间隔。 eslint: <a href=\"https://eslint.org/docs/rules/generator-star-spacing\" target=\"_blank\"><code>generator-star-spacing</code></a>\n<blockquote><p>为什么? <code>function</code> 和 <code>*</code> 是同一个概念关键字的一部分 - <code>*</code> 不是 <code>function</code> 的修饰符， <code>function*</code> 是一个不同于 <code>function</code> 的构造器。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20*%20foo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnconst%20bar%20%3D%20function%20*%20()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20baz%20%3D%20function%20*()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20quux%20%3D%20function*()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%5Cn%5Cn%2F%2F%20bad%5Cnfunction*foo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20*foo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20very%20bad%5Cnfunction%5Cn*%5Cnfoo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20very%20bad%5Cnconst%20wat%20%3D%20function%5Cn*%5Cn()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnfunction*%20foo()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20function*%20()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"24d67862\"><a>属性</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#properties--dot\">12.1</a> 访问属性时使用点符号。 eslint: <a href=\"https://eslint.org/docs/rules/dot-notation.html\" target=\"_blank\"><code>dot-notation</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20luke%20%3D%20%7B%5Cn%20%20jedi%3A%20true%2C%5Cn%20%20age%3A%2028%2C%5Cn%7D%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20isJedi%20%3D%20luke%5B'jedi'%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20isJedi%20%3D%20luke.jedi%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#properties--bracket\">12.2</a> 使用变量访问属性时，使用 <code>[]</code>表示法。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20luke%20%3D%20%7B%5Cn%20%20jedi%3A%20true%2C%5Cn%20%20age%3A%2028%2C%5Cn%7D%3B%5Cn%5Cnfunction%20getProp(prop)%20%7B%5Cn%20%20return%20luke%5Bprop%5D%3B%5Cn%7D%5Cn%5Cnconst%20isJedi%20%3D%20getProp('jedi')%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#es2016-properties--exponentiation-operator\">12.3</a> 计算指数时，可以使用 <code>**</code> 运算符。 eslint: <a href=\"https://eslint.org/docs/rules/no-restricted-properties\" target=\"_blank\"><code>no-restricted-properties</code></a>.\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20binary%20%3D%20Math.pow(2%2C%2010)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20binary%20%3D%202%20**%2010%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ddc7d28b\"><a>变量</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#variables--const\">13.1</a> 使用 <code>const</code> 或者 <code>let</code> 来定义变量。 不这样做将创建一个全局变量。 我们希望避免污染全局命名空间。 Captain Planet 警告过我们。 eslint: <a href=\"https://eslint.org/docs/rules/no-undef\" target=\"_blank\"><code>no-undef</code></a> <a href=\"https://eslint.org/docs/rules/prefer-const\" target=\"_blank\"><code>prefer-const</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5CnsuperPower%20%3D%20new%20SuperPower()%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20superPower%20%3D%20new%20SuperPower()%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--one-const\">13.2</a> 使用 <code>const</code> 或者 <code>let</code> 声明每一个变量。 eslint: <a href=\"https://eslint.org/docs/rules/one-var.html\" target=\"_blank\"><code>one-var</code></a>\n<blockquote><p>为什么? 这样更容易添加新的变量声明，而且你不必担心是使用 <code>;</code> 还是使用 <code>,</code> 或引入标点符号的差别。 你可以通过 debugger 逐步查看每个声明，而不是立即跳过所有声明。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20items%20%3D%20getItems()%2C%5Cn%20%20%20%20goSportsTeam%20%3D%20true%2C%5Cn%20%20%20%20dragonball%20%3D%20'z'%3B%5Cn%5Cn%2F%2F%20bad%5Cn%2F%2F%20(compare%20to%20above%2C%20and%20try%20to%20spot%20the%20mistake)%5Cnconst%20items%20%3D%20getItems()%2C%5Cn%20%20%20%20goSportsTeam%20%3D%20true%3B%5Cn%20%20%20%20dragonball%20%3D%20'z'%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20items%20%3D%20getItems()%3B%5Cnconst%20goSportsTeam%20%3D%20true%3B%5Cnconst%20dragonball%20%3D%20'z'%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--const-let-group\">13.3</a> 把 <code>const</code> 声明的放在一起，把 <code>let</code> 声明的放在一起。.\n<blockquote><p>为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnlet%20i%2C%20len%2C%20dragonball%2C%5Cn%20%20%20%20items%20%3D%20getItems()%2C%5Cn%20%20%20%20goSportsTeam%20%3D%20true%3B%5Cn%5Cn%2F%2F%20bad%5Cnlet%20i%3B%5Cnconst%20items%20%3D%20getItems()%3B%5Cnlet%20dragonball%3B%5Cnconst%20goSportsTeam%20%3D%20true%3B%5Cnlet%20len%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20goSportsTeam%20%3D%20true%3B%5Cnconst%20items%20%3D%20getItems()%3B%5Cnlet%20dragonball%3B%5Cnlet%20i%3B%5Cnlet%20length%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--define-where-used\">13.4</a> 在你需要的使用定义变量，但是要把它们放在一个合理的地方。\n<blockquote><p>为什么? <code>let</code> 和 <code>const</code> 是块级作用域而不是函数作用域。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%20-%20%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%5Cnfunction%20checkName(hasName)%20%7B%5Cn%20%20const%20name%20%3D%20getName()%3B%5Cn%5Cn%20%20if%20(hasName%20%3D%3D%3D%20'test')%20%7B%5Cn%20%20%20%20return%20false%3B%5Cn%20%20%7D%5Cn%5Cn%20%20if%20(name%20%3D%3D%3D%20'test')%20%7B%5Cn%20%20%20%20this.setName('')%3B%5Cn%20%20%20%20return%20false%3B%5Cn%20%20%7D%5Cn%5Cn%20%20return%20name%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20checkName(hasName)%20%7B%5Cn%20%20if%20(hasName%20%3D%3D%3D%20'test')%20%7B%5Cn%20%20%20%20return%20false%3B%5Cn%20%20%7D%5Cn%5Cn%20%20const%20name%20%3D%20getName()%3B%5Cn%5Cn%20%20if%20(name%20%3D%3D%3D%20'test')%20%7B%5Cn%20%20%20%20this.setName('')%3B%5Cn%20%20%20%20return%20false%3B%5Cn%20%20%7D%5Cn%5Cn%20%20return%20name%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--no-chain-assignment\">13.5</a> 不要链式变量赋值。 eslint: <a href=\"https://eslint.org/docs/rules/no-multi-assign\" target=\"_blank\"><code>no-multi-assign</code></a>\n<blockquote><p>为什么? 链式变量赋值会创建隐式全局变量。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn(function%20example()%20%7B%5Cn%20%20%2F%2F%20JavaScript%20%E6%8A%8A%E5%AE%83%E8%A7%A3%E9%87%8A%E4%B8%BA%5Cn%20%20%2F%2F%20let%20a%20%3D%20(%20b%20%3D%20(%20c%20%3D%201%20)%20)%3B%5Cn%20%20%2F%2F%20let%20%E5%85%B3%E9%94%AE%E8%AF%8D%E5%8F%AA%E9%80%82%E7%94%A8%E4%BA%8E%E5%8F%98%E9%87%8F%20a%20%EF%BC%9B%E5%8F%98%E9%87%8F%20b%20%E5%92%8C%E5%8F%98%E9%87%8F%20c%20%E5%88%99%E5%8F%98%E6%88%90%E4%BA%86%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E3%80%82%5Cn%20%20let%20a%20%3D%20b%20%3D%20c%20%3D%201%3B%5Cn%7D())%3B%5Cn%5Cnconsole.log(a)%3B%20%2F%2F%20throws%20ReferenceError%5Cnconsole.log(b)%3B%20%2F%2F%201%5Cnconsole.log(c)%3B%20%2F%2F%201%5Cn%5Cn%2F%2F%20good%5Cn(function%20example()%20%7B%5Cn%20%20let%20a%20%3D%201%3B%5Cn%20%20let%20b%20%3D%20a%3B%5Cn%20%20let%20c%20%3D%20a%3B%5Cn%7D())%3B%5Cn%5Cnconsole.log(a)%3B%20%2F%2F%20throws%20ReferenceError%5Cnconsole.log(b)%3B%20%2F%2F%20throws%20ReferenceError%5Cnconsole.log(c)%3B%20%2F%2F%20throws%20ReferenceError%5Cn%5Cn%2F%2F%20%E5%AF%B9%E4%BA%8E%20%60const%60%20%E4%B9%9F%E4%B8%80%E6%A0%B7%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--unary-increment-decrement\">13.6</a> 避免使用不必要的递增和递减 (<code>++</code>, <code>--</code>)。 eslint <a href=\"https://eslint.org/docs/rules/no-plusplus\" target=\"_blank\"><code>no-plusplus</code></a>\n<blockquote><p>为什么? 在eslint文档中，一元递增和递减语句以自动分号插入为主题，并且在应用程序中可能会导致默认值的递增或递减。它还可以用像 <code>num += 1</code> 这样的语句来改变您的值，而不是使用 <code>num++</code> 或 <code>num ++</code> 。不允许不必要的增量和减量语句也会使您无法预先递增/预递减值，这也会导致程序中的意外行为。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%5Cnconst%20array%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cnlet%20num%20%3D%201%3B%5Cnnum%2B%2B%3B%5Cn--num%3B%5Cn%5Cnlet%20sum%20%3D%200%3B%5Cnlet%20truthyCount%20%3D%200%3B%5Cnfor%20(let%20i%20%3D%200%3B%20i%20%3C%20array.length%3B%20i%2B%2B)%20%7B%5Cn%20%20let%20value%20%3D%20array%5Bi%5D%3B%5Cn%20%20sum%20%2B%3D%20value%3B%5Cn%20%20if%20(value)%20%7B%5Cn%20%20%20%20truthyCount%2B%2B%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cn%5Cnconst%20array%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cnlet%20num%20%3D%201%3B%5Cnnum%20%2B%3D%201%3B%5Cnnum%20-%3D%201%3B%5Cn%5Cnconst%20sum%20%3D%20array.reduce((a%2C%20b)%20%3D%3E%20a%20%2B%20b%2C%200)%3B%5Cnconst%20truthyCount%20%3D%20array.filter(Boolean).length%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#variables--linebreak\">13.7</a> 避免在赋值语句 <code>=</code> 前后换行。如果你的代码违反了 <a href=\"https://eslint.org/docs/rules/max-len.html\" target=\"_blank\"><code>max-len</code></a>， 使用括号包裹。 eslint <a href=\"https://eslint.org/docs/rules/operator-linebreak.html\" target=\"_blank\"><code>operator-linebreak</code></a>.\n<blockquote><p>为什么? 在 <code>=</code> 前后换行，可能混淆赋的值。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%5Cn%20%20superLongLongLongLongLongLongLongLongFunctionName()%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20foo%5Cn%20%20%3D%20'superLongLongLongLongLongLongLongLongString'%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20(%5Cn%20%20superLongLongLongLongLongLongLongLongFunctionName()%5Cn)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20'superLongLongLongLongLongLongLongLongString'%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"c290b27e\"><a>提升</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--about\">14.1</a> <code>var</code> 定义的变量会被提升到函数范围的最顶部，但是它的赋值不会。<code>const</code> 和 <code>let</code> 声明的变量受到一个称之为 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_Dead_Zone_and_errors_with_let\" target=\"_blank\">Temporal Dead Zones (TDZ)</a> 的新概念保护。 知道为什么 <a href=\"http://es-discourse.com/t/why-typeof-is-no-longer-safe/15\" target=\"_blank\">typeof 不再安全</a> 是很重要的。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E6%88%91%E4%BB%AC%E7%9F%A5%E9%81%93%E8%BF%99%E4%B8%AA%E8%A1%8C%E4%B8%8D%E9%80%9A%20(%E5%81%87%E8%AE%BE%E6%B2%A1%E6%9C%89%E6%9C%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F)%5Cnfunction%20example()%20%7B%5Cn%20%20console.log(notDefined)%3B%20%2F%2F%20%3D%3E%20throws%20a%20ReferenceError%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%9C%A8%E5%BC%95%E7%94%A8%E5%8F%98%E9%87%8F%E5%90%8E%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E%E5%B0%86%E4%BC%9A%E5%9B%A0%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E8%80%8C%E8%B5%B7%E4%BD%9C%E7%94%A8%E3%80%82%5Cn%2F%2F%20%E6%B3%A8%E6%84%8F%3A%20%E7%9C%9F%E6%AD%A3%E7%9A%84%E5%80%BC%20%60true%60%20%E4%B8%8D%E4%BC%9A%E8%A2%AB%E6%8F%90%E5%8D%87%E3%80%82%5Cnfunction%20example()%20%7B%5Cn%20%20console.log(declaredButNotAssigned)%3B%20%2F%2F%20%3D%3E%20undefined%5Cn%20%20var%20declaredButNotAssigned%20%3D%20true%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E8%A7%A3%E9%87%8A%E5%99%A8%E5%B0%86%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%88%B0%E5%87%BD%E6%95%B0%E7%9A%84%E9%A1%B6%E9%83%A8%5Cn%2F%2F%20%E8%BF%99%E6%84%8F%E5%91%B3%E7%9D%80%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%B0%86%E4%B8%8A%E8%BE%B9%E7%9A%84%E4%BE%8B%E5%AD%90%E9%87%8D%E5%86%99%E4%B8%BA%EF%BC%9A%5Cnfunction%20example()%20%7B%5Cn%20%20let%20declaredButNotAssigned%3B%5Cn%20%20console.log(declaredButNotAssigned)%3B%20%2F%2F%20%3D%3E%20undefined%5Cn%20%20declaredButNotAssigned%20%3D%20true%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E4%BD%BF%E7%94%A8%20const%20%E5%92%8C%20let%5Cnfunction%20example()%20%7B%5Cn%20%20console.log(declaredButNotAssigned)%3B%20%2F%2F%20%3D%3E%20throws%20a%20ReferenceError%5Cn%20%20console.log(typeof%20declaredButNotAssigned)%3B%20%2F%2F%20%3D%3E%20throws%20a%20ReferenceError%5Cn%20%20const%20declaredButNotAssigned%20%3D%20true%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--anon-expressions\">14.2</a> 匿名函数表达式提升变量名，而不是函数赋值。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20example()%20%7B%5Cn%20%20console.log(anonymous)%3B%20%2F%2F%20%3D%3E%20undefined%5Cn%5Cn%20%20anonymous()%3B%20%2F%2F%20%3D%3E%20TypeError%20anonymous%20is%20not%20a%20function%5Cn%5Cn%20%20var%20anonymous%20%3D%20function%20()%20%7B%5Cn%20%20%20%20console.log('anonymous%20function%20expression')%3B%5Cn%20%20%7D%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--named-expressions\">14.3</a> 命名函数表达式提升的是变量名，而不是函数名或者函数体。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20example()%20%7B%5Cn%20%20console.log(named)%3B%20%2F%2F%20%3D%3E%20undefined%5Cn%5Cn%20%20named()%3B%20%2F%2F%20%3D%3E%20TypeError%20named%20is%20not%20a%20function%5Cn%5Cn%20%20superPower()%3B%20%2F%2F%20%3D%3E%20ReferenceError%20superPower%20is%20not%20defined%5Cn%5Cn%20%20var%20named%20%3D%20function%20superPower()%20%7B%5Cn%20%20%20%20console.log('Flying')%3B%5Cn%20%20%7D%3B%5Cn%7D%5Cn%5Cn%2F%2F%20%E5%BD%93%E5%87%BD%E6%95%B0%E5%90%8D%E5%92%8C%E5%8F%98%E9%87%8F%E5%90%8D%E7%9B%B8%E5%90%8C%E6%97%B6%E4%B9%9F%E6%98%AF%E5%A6%82%E6%AD%A4%E3%80%82%5Cnfunction%20example()%20%7B%5Cn%20%20console.log(named)%3B%20%2F%2F%20%3D%3E%20undefined%5Cn%5Cn%20%20named()%3B%20%2F%2F%20%3D%3E%20TypeError%20named%20is%20not%20a%20function%5Cn%5Cn%20%20var%20named%20%3D%20function%20named()%20%7B%5Cn%20%20%20%20console.log('named')%3B%5Cn%20%20%7D%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#hoisting--declarations\">14.4</a> 函数声明提升其名称和函数体。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20example()%20%7B%5Cn%20%20superPower()%3B%20%2F%2F%20%3D%3E%20Flying%5Cn%5Cn%20%20function%20superPower()%20%7B%5Cn%20%20%20%20console.log('Flying')%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><ul><li>更多信息请参考 <a href=\"http://www.adequatelygood.com/\" target=\"_blank\">Ben Cherry</a> 的 <a href=\"http://www.adequatelygood.com/2010/2/JavaScript-Scoping-and-Hoisting/\" target=\"_blank\">JavaScript Scoping &amp; Hoisting</a>。</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"d6cfcb92\"><a>比较运算符和等号</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--eqeqeq\">15.1</a> 使用 <code>===</code> 和 <code>!==</code> 而不是 <code>==</code> 和 <code>!=</code>。 eslint: <a href=\"https://eslint.org/docs/rules/eqeqeq.html\" target=\"_blank\"><code>eqeqeq</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--if\">15.2</a> 条件语句，例如 <code>if</code> 语句使用 <code>ToBoolean</code> 的抽象方法来计算表达式的结果，并始终遵循以下简单的规则：</li></ul><ul data-lake-indent=\"1\"><li><strong>Objects</strong> 的取值为： <strong>true</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Undefined</strong> 的取值为： <strong>false</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Null</strong> 的取值为： <strong>false</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Booleans</strong> 的取值为： <strong>布尔值的取值</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Numbers</strong> 的取值为：如果为 <strong>+0, -0, or NaN</strong> 值为 <strong>false</strong> 否则为 <strong>true</strong></li></ul><ul data-lake-indent=\"1\"><li><strong>Strings</strong> 的取值为: 如果是一个空字符串 <code>''</code> 值为 <strong>false</strong> 否则为 <strong>true</strong></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22if%20(%5B0%5D%20%26%26%20%5B%5D)%20%7B%5Cn%20%20%2F%2F%20true%5Cn%20%20%2F%2F%20%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%EF%BC%88%E5%8D%B3%E4%BD%BF%E6%98%AF%E7%A9%BA%E7%9A%84%EF%BC%89%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%96%E5%80%BC%E4%B8%BA%20true%5Cn%7D%22%7D\"></card><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--shortcuts\">15.3</a> 对于布尔值使用简写，但是对于字符串和数字进行显式比较。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20(isValid%20%3D%3D%3D%20true)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(isValid)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(name)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(name%20!%3D%3D%20'')%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(collection.length)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(collection.length%20%3E%200)%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--moreinfo\">15.4</a> 获取更多信息请查看 Angus Croll 的 <a href=\"https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/#more-2108\" target=\"_blank\">Truth Equality and JavaScript</a> 。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--switch-blocks\">15.5</a> 在 <code>case</code> 和 <code>default</code> 的子句中，如果存在声明 (例如. <code>let</code>, <code>const</code>, <code>function</code>, 和 <code>class</code>)，使用大括号来创建块 。 eslint: <a href=\"https://eslint.org/docs/rules/no-case-declarations.html\" target=\"_blank\"><code>no-case-declarations</code></a>\n<blockquote><p>为什么? 语法声明在整个 <code>switch</code> 块中都是可见的，但是只有在赋值的时候才会被初始化，这种情况只有在 <code>case</code> 条件达到才会发生。 当多个 <code>case</code> 语句定义相同的东西是，这会导致问题问题。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnswitch%20(foo)%20%7B%5Cn%20%20case%201%3A%5Cn%20%20%20%20let%20x%20%3D%201%3B%5Cn%20%20%20%20break%3B%5Cn%20%20case%202%3A%5Cn%20%20%20%20const%20y%20%3D%202%3B%5Cn%20%20%20%20break%3B%5Cn%20%20case%203%3A%5Cn%20%20%20%20function%20f()%20%7B%5Cn%20%20%20%20%20%20%2F%2F%20...%5Cn%20%20%20%20%7D%5Cn%20%20%20%20break%3B%5Cn%20%20default%3A%5Cn%20%20%20%20class%20C%20%7B%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnswitch%20(foo)%20%7B%5Cn%20%20case%201%3A%20%7B%5Cn%20%20%20%20let%20x%20%3D%201%3B%5Cn%20%20%20%20break%3B%5Cn%20%20%7D%5Cn%20%20case%202%3A%20%7B%5Cn%20%20%20%20const%20y%20%3D%202%3B%5Cn%20%20%20%20break%3B%5Cn%20%20%7D%5Cn%20%20case%203%3A%20%7B%5Cn%20%20%20%20function%20f()%20%7B%5Cn%20%20%20%20%20%20%2F%2F%20...%5Cn%20%20%20%20%7D%5Cn%20%20%20%20break%3B%5Cn%20%20%7D%5Cn%20%20case%204%3A%5Cn%20%20%20%20bar()%3B%5Cn%20%20%20%20break%3B%5Cn%20%20default%3A%20%7B%5Cn%20%20%20%20class%20C%20%7B%7D%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--nested-ternaries\">15.6</a> 三目表达式不应该嵌套，通常是单行表达式。 eslint: <a href=\"https://eslint.org/docs/rules/no-nested-ternary.html\" target=\"_blank\"><code>no-nested-ternary</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20maybe1%20%3E%20maybe2%5Cn%20%20%3F%20%5C%22bar%5C%22%5Cn%20%20%3A%20value1%20%3E%20value2%20%3F%20%5C%22baz%5C%22%20%3A%20null%3B%5Cn%5Cn%2F%2F%20%E5%88%86%E7%A6%BB%E4%B8%BA%E4%B8%A4%E4%B8%AA%E4%B8%89%E7%9B%AE%E8%A1%A8%E8%BE%BE%E5%BC%8F%5Cnconst%20maybeNull%20%3D%20value1%20%3E%20value2%20%3F%20'baz'%20%3A%20null%3B%5Cn%5Cn%2F%2F%20better%5Cnconst%20foo%20%3D%20maybe1%20%3E%20maybe2%5Cn%20%20%3F%20'bar'%5Cn%20%20%3A%20maybeNull%3B%5Cn%5Cn%2F%2F%20best%5Cnconst%20foo%20%3D%20maybe1%20%3E%20maybe2%20%3F%20'bar'%20%3A%20maybeNull%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--unneeded-ternary\">15.7</a> 避免不必要的三目表达式。 eslint: <a href=\"https://eslint.org/docs/rules/no-unneeded-ternary.html\" target=\"_blank\"><code>no-unneeded-ternary</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20a%20%3F%20a%20%3A%20b%3B%5Cnconst%20bar%20%3D%20c%20%3F%20true%20%3A%20false%3B%5Cnconst%20baz%20%3D%20c%20%3F%20false%20%3A%20true%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20a%20%7C%7C%20b%3B%5Cnconst%20bar%20%3D%20!!c%3B%5Cnconst%20baz%20%3D%20!c%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comparison--no-mixed-operators\">15.8</a> 使用该混合运算符时，使用括号括起来。 唯一例外的是标准算数运算符 (<code>+</code>, <code>-</code>, <code>*</code>, &amp; <code>/</code>) 因为他们的优先级被广泛理解。 eslint: <a href=\"https://eslint.org/docs/rules/no-mixed-operators.html\" target=\"_blank\"><code>no-mixed-operators</code></a>\n<blockquote><p>为什么? 这能提高可读性并且表明开发人员的意图。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20a%20%26%26%20b%20%3C%200%20%7C%7C%20c%20%3E%200%20%7C%7C%20d%20%2B%201%20%3D%3D%3D%200%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20bar%20%3D%20a%20**%20b%20-%205%20%25%20d%3B%5Cn%5Cn%2F%2F%20bad%5Cn%2F%2F%20%E5%8F%AF%E8%83%BD%E9%99%B7%E5%85%A5%E4%B8%80%E7%A7%8D%20(a%20%7C%7C%20b)%20%26%26%20c%20%E7%9A%84%E6%80%9D%E8%80%83%5Cnif%20(a%20%7C%7C%20b%20%26%26%20c)%20%7B%5Cn%20%20return%20d%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20(a%20%26%26%20b%20%3C%200)%20%7C%7C%20c%20%3E%200%20%7C%7C%20(d%20%2B%201%20%3D%3D%3D%200)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20bar%20%3D%20(a%20**%20b)%20-%20(5%20%25%20d)%3B%5Cn%5Cn%2F%2F%20good%5Cnif%20(a%20%7C%7C%20(b%20%26%26%20c))%20%7B%5Cn%20%20return%20d%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20bar%20%3D%20a%20%2B%20b%20%2F%20c%20*%20d%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"7084eb1b\"><a>块</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#blocks--braces\">16.1</a> 当有多行代码块的时候，使用大括号包裹。 eslint: <a href=\"https://eslint.org/docs/rules/nonblock-statement-body-position\" target=\"_blank\"><code>nonblock-statement-body-position</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20(test)%5Cn%20%20return%20false%3B%5Cn%5Cn%2F%2F%20good%5Cnif%20(test)%20return%20false%3B%5Cn%5Cn%2F%2F%20good%5Cnif%20(test)%20%7B%5Cn%20%20return%20false%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20foo()%20%7B%20return%20false%3B%20%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20bar()%20%7B%5Cn%20%20return%20false%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#blocks--cuddled-elses\">16.2</a> 如果你使用的是 <code>if</code> 和 <code>else</code> 的多行代码块，则将 <code>else</code> 语句放在 <code>if</code> 块闭括号同一行的位置。 eslint: <a href=\"https://eslint.org/docs/rules/brace-style.html\" target=\"_blank\"><code>brace-style</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20(test)%20%7B%5Cn%20%20thing1()%3B%5Cn%20%20thing2()%3B%5Cn%7D%5Cnelse%20%7B%5Cn%20%20thing3()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(test)%20%7B%5Cn%20%20thing1()%3B%5Cn%20%20thing2()%3B%5Cn%7D%20else%20%7B%5Cn%20%20thing3()%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#blocks--no-else-return\">16.3</a> 如果一个 <code>if</code> 块总是执行一个 <code>return</code> 语句，那么接下来的 <code>else</code> 块就没有必要了。 如果一个包含 <code>return</code> 语句的 <code>else if</code> 块，在一个包含了 <code>return</code> 语句的 <code>if</code> 块之后，那么可以拆成多个 <code>if</code> 块。 eslint: <a href=\"https://eslint.org/docs/rules/no-else-return\" target=\"_blank\"><code>no-else-return</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo()%20%7B%5Cn%20%20if%20(x)%20%7B%5Cn%20%20%20%20return%20x%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20return%20y%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20cats()%20%7B%5Cn%20%20if%20(x)%20%7B%5Cn%20%20%20%20return%20x%3B%5Cn%20%20%7D%20else%20if%20(y)%20%7B%5Cn%20%20%20%20return%20y%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20dogs()%20%7B%5Cn%20%20if%20(x)%20%7B%5Cn%20%20%20%20return%20x%3B%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20if%20(y)%20%7B%5Cn%20%20%20%20%20%20return%20y%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20foo()%20%7B%5Cn%20%20if%20(x)%20%7B%5Cn%20%20%20%20return%20x%3B%5Cn%20%20%7D%5Cn%5Cn%20%20return%20y%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20cats()%20%7B%5Cn%20%20if%20(x)%20%7B%5Cn%20%20%20%20return%20x%3B%5Cn%20%20%7D%5Cn%5Cn%20%20if%20(y)%20%7B%5Cn%20%20%20%20return%20y%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20dogs(x)%20%7B%5Cn%20%20if%20(x)%20%7B%5Cn%20%20%20%20if%20(z)%20%7B%5Cn%20%20%20%20%20%20return%20y%3B%5Cn%20%20%20%20%7D%5Cn%20%20%7D%20else%20%7B%5Cn%20%20%20%20return%20z%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ea5302a4\"><a>控制语句</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#control-statements\">17.1</a> 如果你的控制语句 (<code>if</code>, <code>while</code> 等) 太长或者超过了一行最大长度的限制，则可以将每个条件（或组）放入一个新的行。 逻辑运算符应该在行的开始。\n<blockquote><p>为什么? 要求操作符在行的开始保持对齐并遵循类似方法衔接的模式。 这提高了可读性，并且使更复杂的逻辑更容易直观的被理解。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20((foo%20%3D%3D%3D%20123%20%7C%7C%20bar%20%3D%3D%3D%20'abc')%20%26%26%20doesItLookGoodWhenItBecomesThatLong()%20%26%26%20isThisReallyHappening())%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(foo%20%3D%3D%3D%20123%20%26%26%5Cn%20%20bar%20%3D%3D%3D%20'abc')%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(foo%20%3D%3D%3D%20123%5Cn%20%20%26%26%20bar%20%3D%3D%3D%20'abc')%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(%5Cn%20%20foo%20%3D%3D%3D%20123%20%26%26%5Cn%20%20bar%20%3D%3D%3D%20'abc'%5Cn)%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(%5Cn%20%20foo%20%3D%3D%3D%20123%5Cn%20%20%26%26%20bar%20%3D%3D%3D%20'abc'%5Cn)%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(%5Cn%20%20(foo%20%3D%3D%3D%20123%20%7C%7C%20bar%20%3D%3D%3D%20'abc')%5Cn%20%20%26%26%20doesItLookGoodWhenItBecomesThatLong()%5Cn%20%20%26%26%20isThisReallyHappening()%5Cn)%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(foo%20%3D%3D%3D%20123%20%26%26%20bar%20%3D%3D%3D%20'abc')%20%7B%5Cn%20%20thing1()%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#control-statements--value-selection\">17.2</a> 不要使用选择操作符代替控制语句。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn!isRunning%20%26%26%20startRunning()%3B%5Cn%5Cn%2F%2F%20good%5Cnif%20(!isRunning)%20%7B%5Cn%20%20startRunning()%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"ee656aa1\"><a>注释</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#comments--multiline\">18.1</a> 使用 <code>/** ... */</code> 来进行多行注释。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%2F%2F%20make()%20returns%20a%20new%20element%5Cn%2F%2F%20based%20on%20the%20passed%20in%20tag%20name%5Cn%2F%2F%5Cn%2F%2F%20%40param%20%7BString%7D%20tag%5Cn%2F%2F%20%40return%20%7BElement%7D%20element%5Cnfunction%20make(tag)%20%7B%5Cn%5Cn%20%20%2F%2F%20...%5Cn%5Cn%20%20return%20element%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cn%2F**%5Cn%20*%20make()%20returns%20a%20new%20element%5Cn%20*%20based%20on%20the%20passed-in%20tag%20name%5Cn%20*%2F%5Cnfunction%20make(tag)%20%7B%5Cn%5Cn%20%20%2F%2F%20...%5Cn%5Cn%20%20return%20element%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--singleline\">18.2</a> 使用 <code>//</code> 进行单行注释。 将单行注释放在需要注释的行的上方新行。 在注释之前放一个空行，除非它在块的第一行。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20active%20%3D%20true%3B%20%20%2F%2F%20is%20current%20tab%5Cn%5Cn%2F%2F%20good%5Cn%2F%2F%20is%20current%20tab%5Cnconst%20active%20%3D%20true%3B%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20getType()%20%7B%5Cn%20%20console.log('fetching%20type...')%3B%5Cn%20%20%2F%2F%20set%20the%20default%20type%20to%20'no%20type'%5Cn%20%20const%20type%20%3D%20this.type%20%7C%7C%20'no%20type'%3B%5Cn%5Cn%20%20return%20type%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20getType()%20%7B%5Cn%20%20console.log('fetching%20type...')%3B%5Cn%5Cn%20%20%2F%2F%20set%20the%20default%20type%20to%20'no%20type'%5Cn%20%20const%20type%20%3D%20this.type%20%7C%7C%20'no%20type'%3B%5Cn%5Cn%20%20return%20type%3B%5Cn%7D%5Cn%5Cn%2F%2F%20also%20good%5Cnfunction%20getType()%20%7B%5Cn%20%20%2F%2F%20set%20the%20default%20type%20to%20'no%20type'%5Cn%20%20const%20type%20%3D%20this.type%20%7C%7C%20'no%20type'%3B%5Cn%5Cn%20%20return%20type%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--spaces\">18.3</a> 用一个空格开始所有的注释，使它更容易阅读。 eslint: <a href=\"https://eslint.org/docs/rules/spaced-comment\" target=\"_blank\"><code>spaced-comment</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%2F%2Fis%20current%20tab%5Cnconst%20active%20%3D%20true%3B%5Cn%5Cn%2F%2F%20good%5Cn%2F%2F%20is%20current%20tab%5Cnconst%20active%20%3D%20true%3B%5Cn%5Cn%2F%2F%20bad%5Cn%2F**%5Cn%20*make()%20returns%20a%20new%20element%5Cn%20*based%20on%20the%20passed-in%20tag%20name%5Cn%20*%2F%5Cnfunction%20make(tag)%20%7B%5Cn%5Cn%20%20%2F%2F%20...%5Cn%5Cn%20%20return%20element%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cn%2F**%5Cn%20*%20make()%20returns%20a%20new%20element%5Cn%20*%20based%20on%20the%20passed-in%20tag%20name%5Cn%20*%2F%5Cnfunction%20make(tag)%20%7B%5Cn%5Cn%20%20%2F%2F%20...%5Cn%5Cn%20%20return%20element%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--actionitems\">18.4</a> 使用 <code>FIXME</code> 或者 <code>TODO</code> 开始你的注释可以帮助其他开发人员快速了解，如果你提出了一个需要重新审视的问题，或者你对需要实现的问题提出的解决方案。 这些不同于其他评论，因为他们是可操作的。 这些行为是 <code>FIXME: -- 需要解决这个问题</code> 或者 <code>TODO: -- 需要被实现</code>。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--fixme\">18.5</a> 使用 <code>// FIXME:</code> 注释一个问题。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Calculator%20extends%20Abacus%20%7B%5Cn%20%20constructor()%20%7B%5Cn%20%20%20%20super()%3B%5Cn%5Cn%20%20%20%20%2F%2F%20FIXME%3A%20%E8%BF%99%E9%87%8C%E4%B8%8D%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%5Cn%20%20%20%20total%20%3D%200%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#comments--todo\">18.6</a> 使用 <code>// TODO:</code> 注释解决问题的方法。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Calculator%20extends%20Abacus%20%7B%5Cn%20%20constructor()%20%7B%5Cn%20%20%20%20super()%3B%5Cn%5Cn%20%20%20%20%2F%2F%20TODO%3A%20total%20%E5%BA%94%E8%AF%A5%E7%94%B1%E4%B8%80%E4%B8%AA%20param%20%E7%9A%84%E9%80%89%E9%A1%B9%E9%85%8D%E7%BD%AE%5Cn%20%20%20%20this.total%20%3D%200%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"6874c973\"><a>空白</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--spaces\">19.1</a> 使用 tabs (空格字符) 设置为 2 个空格。 eslint: <a href=\"https://eslint.org/docs/rules/indent.html\" target=\"_blank\"><code>indent</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo()%20%7B%5Cn%E2%88%99%E2%88%99%E2%88%99%E2%88%99let%20name%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20bar()%20%7B%5Cn%E2%88%99let%20name%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20baz()%20%7B%5Cn%E2%88%99%E2%88%99let%20name%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--before-blocks\">19.2</a> 在主体前放置一个空格。 eslint: <a href=\"https://eslint.org/docs/rules/space-before-blocks.html\" target=\"_blank\"><code>space-before-blocks</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20test()%7B%5Cn%20%20console.log('test')%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20test()%20%7B%5Cn%20%20console.log('test')%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cndog.set('attr'%2C%7B%5Cn%20%20age%3A%20'1%20year'%2C%5Cn%20%20breed%3A%20'Bernese%20Mountain%20Dog'%2C%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cndog.set('attr'%2C%20%7B%5Cn%20%20age%3A%20'1%20year'%2C%5Cn%20%20breed%3A%20'Bernese%20Mountain%20Dog'%2C%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--around-keywords\">19.3</a> 在控制语句（<code>if</code>, <code>while</code> 等）开始括号之前放置一个空格。 在函数调用和是声明中，在参数列表和函数名之间没有空格。 eslint: <a href=\"https://eslint.org/docs/rules/keyword-spacing.html\" target=\"_blank\"><code>keyword-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif(isJedi)%20%7B%5Cn%20%20fight%20()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(isJedi)%20%7B%5Cn%20%20fight()%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20fight%20()%20%7B%5Cn%20%20console.log%20('Swooosh!')%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20fight()%20%7B%5Cn%20%20console.log('Swooosh!')%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--infix-ops\">19.4</a> 用空格分离操作符。 eslint: <a href=\"https://eslint.org/docs/rules/space-infix-ops.html\" target=\"_blank\"><code>space-infix-ops</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20x%3Dy%2B5%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20x%20%3D%20y%20%2B%205%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--newline-at-end\">19.5</a> 使用单个换行符结束文件。 eslint: <a href=\"https://github.com/eslint/eslint/blob/master/docs/rules/eol-last.md\" target=\"_blank\"><code>eol-last</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20%7B%20es6%20%7D%20from%20'.%2FAirbnbStyleGuide'%3B%5Cn%20%20%2F%2F%20...%5Cnexport%20default%20es6%3B%22%7D\"></card><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20%7B%20es6%20%7D%20from%20'.%2FAirbnbStyleGuide'%3B%5Cn%20%20%2F%2F%20...%5Cnexport%20default%20es6%3B%E2%86%B5%5Cn%E2%86%B5%22%7D\"></card><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20good%5Cnimport%20%7B%20es6%20%7D%20from%20'.%2FAirbnbStyleGuide'%3B%5Cn%20%20%2F%2F%20...%5Cnexport%20default%20es6%3B%E2%86%B5%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--chains\">19.6</a> 在使用链式方法调用的时候使用缩进(超过两个方法链)。 使用一个引导点，强调该行是方法调用，而不是新的语句。 eslint: <a href=\"https://eslint.org/docs/rules/newline-per-chained-call\" target=\"_blank\"><code>newline-per-chained-call</code></a> <a href=\"https://eslint.org/docs/rules/no-whitespace-before-property\" target=\"_blank\"><code>no-whitespace-before-property</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%24('%23items').find('.selected').highlight().end().find('.open').updateCount()%3B%5Cn%5Cn%2F%2F%20bad%5Cn%24('%23items').%5Cn%20%20find('.selected').%5Cn%20%20%20%20highlight().%5Cn%20%20%20%20end().%5Cn%20%20find('.open').%5Cn%20%20%20%20updateCount()%3B%5Cn%5Cn%2F%2F%20good%5Cn%24('%23items')%5Cn%20%20.find('.selected')%5Cn%20%20%20%20.highlight()%5Cn%20%20%20%20.end()%5Cn%20%20.find('.open')%5Cn%20%20%20%20.updateCount()%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20leds%20%3D%20stage.selectAll('.led').data(data).enter().append('svg%3Asvg').classed('led'%2C%20true)%5Cn%20%20%20%20.attr('width'%2C%20(radius%20%2B%20margin)%20*%202).append('svg%3Ag')%5Cn%20%20%20%20.attr('transform'%2C%20%60translate(%24%7Bradius%20%2B%20margin%7D%2C%24%7Bradius%20%2B%20margin%7D)%60)%5Cn%20%20%20%20.call(tron.led)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20leds%20%3D%20stage.selectAll('.led')%5Cn%20%20%20%20.data(data)%5Cn%20%20.enter().append('svg%3Asvg')%5Cn%20%20%20%20.classed('led'%2C%20true)%5Cn%20%20%20%20.attr('width'%2C%20(radius%20%2B%20margin)%20*%202)%5Cn%20%20.append('svg%3Ag')%5Cn%20%20%20%20.attr('transform'%2C%20%60translate(%24%7Bradius%20%2B%20margin%7D%2C%24%7Bradius%20%2B%20margin%7D)%60)%5Cn%20%20%20%20.call(tron.led)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20leds%20%3D%20stage.selectAll('.led').data(data)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--after-blocks\">19.7</a> 在块和下一个语句之前留下一空白行。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20(foo)%20%7B%5Cn%20%20return%20bar%3B%5Cn%7D%5Cnreturn%20baz%3B%5Cn%5Cn%2F%2F%20good%5Cnif%20(foo)%20%7B%5Cn%20%20return%20bar%3B%5Cn%7D%5Cn%5Cnreturn%20baz%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20foo()%20%7B%5Cn%20%20%7D%2C%5Cn%20%20bar()%20%7B%5Cn%20%20%7D%2C%5Cn%7D%3B%5Cnreturn%20obj%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20obj%20%3D%20%7B%5Cn%20%20foo()%20%7B%5Cn%20%20%7D%2C%5Cn%5Cn%20%20bar()%20%7B%5Cn%20%20%7D%2C%5Cn%7D%3B%5Cn%5Cnreturn%20obj%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20arr%20%3D%20%5B%5Cn%20%20function%20foo()%20%7B%5Cn%20%20%7D%2C%5Cn%20%20function%20bar()%20%7B%5Cn%20%20%7D%2C%5Cn%5D%3B%5Cnreturn%20arr%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20arr%20%3D%20%5B%5Cn%20%20function%20foo()%20%7B%5Cn%20%20%7D%2C%5Cn%5Cn%20%20function%20bar()%20%7B%5Cn%20%20%7D%2C%5Cn%5D%3B%5Cn%5Cnreturn%20arr%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--padded-blocks\">19.8</a> 不要在块的开头使用空白行。 eslint: <a href=\"https://eslint.org/docs/rules/padded-blocks.html\" target=\"_blank\"><code>padded-blocks</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20bar()%20%7B%5Cn%5Cn%20%20console.log(foo)%3B%5Cn%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(baz)%20%7B%5Cn%5Cn%20%20console.log(qux)%3B%5Cn%7D%20else%20%7B%5Cn%20%20console.log(foo)%3B%5Cn%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnclass%20Foo%20%7B%5Cn%5Cn%20%20constructor(bar)%20%7B%5Cn%20%20%20%20this.bar%20%3D%20bar%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20bar()%20%7B%5Cn%20%20console.log(foo)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(baz)%20%7B%5Cn%20%20console.log(qux)%3B%5Cn%7D%20else%20%7B%5Cn%20%20console.log(foo)%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--in-parens\">19.9</a> 不要在括号内添加空格。 eslint: <a href=\"https://eslint.org/docs/rules/space-in-parens.html\" target=\"_blank\"><code>space-in-parens</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20bar(%20foo%20)%20%7B%5Cn%20%20return%20foo%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20bar(foo)%20%7B%5Cn%20%20return%20foo%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnif%20(%20foo%20)%20%7B%5Cn%20%20console.log(foo)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(foo)%20%7B%5Cn%20%20console.log(foo)%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--in-brackets\">19.10</a> 不要在中括号中添加空格。 eslint: <a href=\"https://eslint.org/docs/rules/array-bracket-spacing.html\" target=\"_blank\"><code>array-bracket-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20%5B%201%2C%202%2C%203%20%5D%3B%5Cnconsole.log(foo%5B%200%20%5D)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20%5B1%2C%202%2C%203%5D%3B%5Cnconsole.log(foo%5B0%5D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--in-braces\">19.11</a> 在花括号内添加空格。 eslint: <a href=\"https://eslint.org/docs/rules/object-curly-spacing.html\" target=\"_blank\"><code>object-curly-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20%7Bclark%3A%20'kent'%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20%7B%20clark%3A%20'kent'%20%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--max-len\">19.12</a> 避免让你的代码行超过100个字符（包括空格）。 注意：根据上边的 <a href=\"#strings--line-length\">约束</a>，长字符串可免除此规定，不应分解。 eslint: <a href=\"https://eslint.org/docs/rules/max-len.html\" target=\"_blank\"><code>max-len</code></a>\n<blockquote><p>为什么? 这样能够确保可读性和可维护性。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20foo%20%3D%20jsonData%20%26%26%20jsonData.foo%20%26%26%20jsonData.foo.bar%20%26%26%20jsonData.foo.bar.baz%20%26%26%20jsonData.foo.bar.baz.quux%20%26%26%20jsonData.foo.bar.baz.quux.xyzzy%3B%5Cn%5Cn%2F%2F%20bad%5Cn%24.ajax(%7B%20method%3A%20'POST'%2C%20url%3A%20'https%3A%2F%2Fairbnb.com%2F'%2C%20data%3A%20%7B%20name%3A%20'John'%20%7D%20%7D).done(()%20%3D%3E%20console.log('Congratulations!')).fail(()%20%3D%3E%20console.log('You%20have%20failed%20this%20city.'))%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20foo%20%3D%20jsonData%5Cn%20%20%26%26%20jsonData.foo%5Cn%20%20%26%26%20jsonData.foo.bar%5Cn%20%20%26%26%20jsonData.foo.bar.baz%5Cn%20%20%26%26%20jsonData.foo.bar.baz.quux%5Cn%20%20%26%26%20jsonData.foo.bar.baz.quux.xyzzy%3B%5Cn%5Cn%2F%2F%20good%5Cn%24.ajax(%7B%5Cn%20%20method%3A%20'POST'%2C%5Cn%20%20url%3A%20'https%3A%2F%2Fairbnb.com%2F'%2C%5Cn%20%20data%3A%20%7B%20name%3A%20'John'%20%7D%2C%5Cn%7D)%5Cn%20%20.done(()%20%3D%3E%20console.log('Congratulations!'))%5Cn%20%20.fail(()%20%3D%3E%20console.log('You%20have%20failed%20this%20city.'))%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--block-spacing\">19.13</a> 要求打开的块标志和同一行上的标志拥有一致的间距。此规则还会在同一行关闭的块标记和前边的标记强制实施一致的间距。 eslint: <a href=\"https://eslint.org/docs/rules/block-spacing\" target=\"_blank\"><code>block-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo()%20%7Breturn%20true%3B%7D%5Cnif%20(foo)%20%7B%20bar%20%3D%200%3B%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20foo()%20%7B%20return%20true%3B%20%7D%5Cnif%20(foo)%20%7B%20bar%20%3D%200%3B%20%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--comma-spacing\">19.14</a> 逗号之前避免使用空格，逗号之后需要使用空格。eslint: <a href=\"https://eslint.org/docs/rules/comma-spacing\" target=\"_blank\"><code>comma-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnvar%20foo%20%3D%201%2Cbar%20%3D%202%3B%5Cnvar%20arr%20%3D%20%5B1%20%2C%202%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnvar%20foo%20%3D%201%2C%20bar%20%3D%202%3B%5Cnvar%20arr%20%3D%20%5B1%2C%202%5D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--computed-property-spacing\">19.15</a> 在计算属性之间强化间距。eslint: <a href=\"https://eslint.org/docs/rules/computed-property-spacing\" target=\"_blank\"><code>computed-property-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnobj%5Bfoo%20%5D%5Cnobj%5B%20'foo'%5D%5Cnvar%20x%20%3D%20%7B%5B%20b%20%5D%3A%20a%7D%5Cnobj%5Bfoo%5B%20bar%20%5D%5D%5Cn%5Cn%2F%2F%20good%5Cnobj%5Bfoo%5D%5Cnobj%5B'foo'%5D%5Cnvar%20x%20%3D%20%7B%20%5Bb%5D%3A%20a%20%7D%5Cnobj%5Bfoo%5Bbar%5D%5D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--func-call-spacing\">19.16</a> 在函数和它的调用之间强化间距。 eslint: <a href=\"https://eslint.org/docs/rules/func-call-spacing\" target=\"_blank\"><code>func-call-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunc%20()%3B%5Cn%5Cnfunc%5Cn()%3B%5Cn%5Cn%2F%2F%20good%5Cnfunc()%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--key-spacing\">19.17</a> 在对象的属性和值之间强化间距。 eslint: <a href=\"https://eslint.org/docs/rules/key-spacing\" target=\"_blank\"><code>key-spacing</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnvar%20obj%20%3D%20%7B%20%5C%22foo%5C%22%20%3A%2042%20%7D%3B%5Cnvar%20obj2%20%3D%20%7B%20%5C%22foo%5C%22%3A42%20%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnvar%20obj%20%3D%20%7B%20%5C%22foo%5C%22%3A%2042%20%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--no-trailing-spaces\">19.18</a> 在行的末尾避免使用空格。 eslint: <a href=\"https://eslint.org/docs/rules/no-trailing-spaces\" target=\"_blank\"><code>no-trailing-spaces</code></a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#whitespace--no-multiple-empty-lines\">19.19</a> 避免多个空行，并且只允许在文件末尾添加一个换行符。 eslint: <a href=\"https://eslint.org/docs/rules/no-multiple-empty-lines\" target=\"_blank\"><code>no-multiple-empty-lines</code></a>\n\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnvar%20x%20%3D%201%3B%5Cn%5Cn%5Cn%5Cnvar%20y%20%3D%202%3B%5Cn%5Cn%2F%2F%20good%5Cnvar%20x%20%3D%201%3B%5Cn%5Cnvar%20y%20%3D%202%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"c2d5517a\"><a>逗号</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#commas--leading-trailing\">20.1</a> 逗号前置： <strong>不行</strong> eslint: <a href=\"https://eslint.org/docs/rules/comma-style.html\" target=\"_blank\"><code>comma-style</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20story%20%3D%20%5B%5Cn%20%20%20%20once%5Cn%20%20%2C%20upon%5Cn%20%20%2C%20aTime%5Cn%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20story%20%3D%20%5B%5Cn%20%20once%2C%5Cn%20%20upon%2C%5Cn%20%20aTime%2C%5Cn%5D%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20hero%20%3D%20%7B%5Cn%20%20%20%20firstName%3A%20'Ada'%5Cn%20%20%2C%20lastName%3A%20'Lovelace'%5Cn%20%20%2C%20birthYear%3A%201815%5Cn%20%20%2C%20superPower%3A%20'computers'%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20hero%20%3D%20%7B%5Cn%20%20firstName%3A%20'Ada'%2C%5Cn%20%20lastName%3A%20'Lovelace'%2C%5Cn%20%20birthYear%3A%201815%2C%5Cn%20%20superPower%3A%20'computers'%2C%5Cn%7D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#commas--dangling\">20.2</a> 添加尾随逗号： <strong>可以</strong> eslint: <a href=\"https://eslint.org/docs/rules/comma-dangle.html\" target=\"_blank\"><code>comma-dangle</code></a>\n<blockquote><p>为什么? 这个将造成更清洁的 git 扩展差异。 另外，像 Babel 这样的编译器，会在转换后的代码中删除额外的尾随逗号，这意味着你不必担心在浏览器中后面的 <a href=\"https://github.com/airbnb/javascript/blob/es5-deprecated/es5/README.md#commas\" target=\"_blank\">尾随逗号问题</a> 。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22diff%22%2C%22code%22%3A%22%2F%2F%20bad%20-%20%E6%B2%A1%E6%9C%89%E5%B0%BE%E9%9A%8F%E9%80%97%E5%8F%B7%E7%9A%84%20git%20%E5%B7%AE%E5%BC%82%5Cnconst%20hero%20%3D%20%7B%5Cn%20%20%20%20%20firstName%3A%20'Florence'%2C%5Cn-%20%20%20%20lastName%3A%20'Nightingale'%5Cn%2B%20%20%20%20lastName%3A%20'Nightingale'%2C%5Cn%2B%20%20%20%20inventorOf%3A%20%5B'coxcomb%20chart'%2C%20'modern%20nursing'%5D%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%20-%20%E6%9C%89%E5%B0%BE%E9%9A%8F%E9%80%97%E5%8F%B7%E7%9A%84%20git%20%E5%B7%AE%E5%BC%82%5Cnconst%20hero%20%3D%20%7B%5Cn%20%20%20%20%20firstName%3A%20'Florence'%2C%5Cn%20%20%20%20%20lastName%3A%20'Nightingale'%2C%5Cn%2B%20%20%20%20inventorOf%3A%20%5B'coxcomb%20chart'%2C%20'modern%20nursing'%5D%2C%5Cn%7D%3B%22%7D\"></card><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20hero%20%3D%20%7B%5Cn%20%20firstName%3A%20'Dana'%2C%5Cn%20%20lastName%3A%20'Scully'%5Cn%7D%3B%5Cn%5Cnconst%20heroes%20%3D%20%5B%5Cn%20%20'Batman'%2C%5Cn%20%20'Superman'%5Cn%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20hero%20%3D%20%7B%5Cn%20%20firstName%3A%20'Dana'%2C%5Cn%20%20lastName%3A%20'Scully'%2C%5Cn%7D%3B%5Cn%5Cnconst%20heroes%20%3D%20%5B%5Cn%20%20'Batman'%2C%5Cn%20%20'Superman'%2C%5Cn%5D%3B%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20createHero(%5Cn%20%20firstName%2C%5Cn%20%20lastName%2C%5Cn%20%20inventorOf%5Cn)%20%7B%5Cn%20%20%2F%2F%20does%20nothing%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20createHero(%5Cn%20%20firstName%2C%5Cn%20%20lastName%2C%5Cn%20%20inventorOf%2C%5Cn)%20%7B%5Cn%20%20%2F%2F%20does%20nothing%5Cn%7D%5Cn%5Cn%2F%2F%20good%20(%E6%B3%A8%E6%84%8F%E9%80%97%E5%8F%B7%E4%B8%8D%E8%83%BD%E5%87%BA%E7%8E%B0%E5%9C%A8%20%5C%22rest%5C%22%20%E5%85%83%E7%B4%A0%E5%90%8E%E8%BE%B9)%5Cnfunction%20createHero(%5Cn%20%20firstName%2C%5Cn%20%20lastName%2C%5Cn%20%20inventorOf%2C%5Cn%20%20...heroArgs%5Cn)%20%7B%5Cn%20%20%2F%2F%20does%20nothing%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5CncreateHero(%5Cn%20%20firstName%2C%5Cn%20%20lastName%2C%5Cn%20%20inventorOf%5Cn)%3B%5Cn%5Cn%2F%2F%20good%5CncreateHero(%5Cn%20%20firstName%2C%5Cn%20%20lastName%2C%5Cn%20%20inventorOf%2C%5Cn)%3B%5Cn%5Cn%2F%2F%20good%20(%E6%B3%A8%E6%84%8F%E9%80%97%E5%8F%B7%E4%B8%8D%E8%83%BD%E5%87%BA%E7%8E%B0%E5%9C%A8%20%5C%22rest%5C%22%20%E5%85%83%E7%B4%A0%E5%90%8E%E8%BE%B9)%5CncreateHero(%5Cn%20%20firstName%2C%5Cn%20%20lastName%2C%5Cn%20%20inventorOf%2C%5Cn%20%20...heroArgs%5Cn)%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"cb368833\"><a>分号</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#semicolons--required\">21.1</a> <strong>对</strong> eslint: <a href=\"https://eslint.org/docs/rules/semi.html\" target=\"_blank\"><code>semi</code></a>\n<blockquote><p>为什么? 当 JavaScript 遇见一个没有分号的换行符时，它会使用一个叫做 <a href=\"https://tc39.github.io/ecma262/#sec-automatic-semicolon-insertion\" target=\"_blank\">Automatic Semicolon Insertion</a> 的规则来确定是否应该以换行符视为语句的结束，并且如果认为如此，会在代码中断前插入一个分号到代码中。 但是，ASI 包含了一些奇怪的行为，如果 JavaScript 错误的解释了你的换行符，你的代码将会中断。 随着新特性成为 JavaScript 的一部分，这些规则将变得更加复杂。 明确地终止你的语句，并配置你的 linter 以捕获缺少的分号将有助于防止你遇到的问题。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%20-%20%E5%8F%AF%E8%83%BD%E5%BC%82%E5%B8%B8%5Cnconst%20luke%20%3D%20%7B%7D%5Cnconst%20leia%20%3D%20%7B%7D%5Cn%5Bluke%2C%20leia%5D.forEach(jedi%20%3D%3E%20jedi.father%20%3D%20'vader')%5Cn%5Cn%2F%2F%20bad%20-%20%E5%8F%AF%E8%83%BD%E5%BC%82%E5%B8%B8%5Cnconst%20reaction%20%3D%20%5C%22No!%20That's%20impossible!%5C%22%5Cn(async%20function%20meanwhileOnTheFalcon()%20%7B%5Cn%20%20%2F%2F%20handle%20%60leia%60%2C%20%60lando%60%2C%20%60chewie%60%2C%20%60r2%60%2C%20%60c3p0%60%5Cn%20%20%2F%2F%20...%5Cn%7D())%5Cn%5Cn%2F%2F%20bad%20-%20%E8%BF%94%E5%9B%9E%20%60undefined%60%20%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%8B%E4%B8%80%E8%A1%8C%E7%9A%84%E5%80%BC%20-%20%E5%BD%93%20%60return%60%20%E5%8D%95%E7%8B%AC%E4%B8%80%E8%A1%8C%E7%9A%84%E6%97%B6%E5%80%99%20ASI%20%E6%80%BB%E6%98%AF%E4%BC%9A%E5%8F%91%E7%94%9F%5Cnfunction%20foo()%20%7B%5Cn%20%20return%5Cn%20%20%20%20'search%20your%20feelings%2C%20you%20know%20it%20to%20be%20foo'%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20luke%20%3D%20%7B%7D%3B%5Cnconst%20leia%20%3D%20%7B%7D%3B%5Cn%5Bluke%2C%20leia%5D.forEach((jedi)%20%3D%3E%20%7B%5Cn%20%20jedi.father%20%3D%20'vader'%3B%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20reaction%20%3D%20%5C%22No!%20That's%20impossible!%5C%22%3B%5Cn(async%20function%20meanwhileOnTheFalcon()%20%7B%5Cn%20%20%2F%2F%20handle%20%60leia%60%2C%20%60lando%60%2C%20%60chewie%60%2C%20%60r2%60%2C%20%60c3p0%60%5Cn%20%20%2F%2F%20...%5Cn%7D())%3B%5Cn%5Cn%2F%2F%20good%5Cnfunction%20foo()%20%7B%5Cn%20%20return%20'search%20your%20feelings%2C%20you%20know%20it%20to%20be%20foo'%3B%5Cn%7D%22%7D\"></card>\n<br /><a href=\"https://stackoverflow.com/questions/7365172/semicolon-before-self-invoking-function/7365214#7365214\" target=\"_blank\">更多信息</a>.</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"bf7d863e\"><a>类型转换和强制类型转换</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--explicit\">22.1</a> 在语句开始前进行类型转换。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--strings\">22.2</a>  字符类型： eslint: <a href=\"https://eslint.org/docs/rules/no-new-wrappers\" target=\"_blank\"><code>no-new-wrappers</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%3D%3E%20this.reviewScore%20%3D%209%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20totalScore%20%3D%20new%20String(this.reviewScore)%3B%20%2F%2F%20typeof%20totalScore%20is%20%5C%22object%5C%22%20not%20%5C%22string%5C%22%5Cn%5Cn%2F%2F%20bad%5Cnconst%20totalScore%20%3D%20this.reviewScore%20%2B%20''%3B%20%2F%2F%20invokes%20this.reviewScore.valueOf()%5Cn%5Cn%2F%2F%20bad%5Cnconst%20totalScore%20%3D%20this.reviewScore.toString()%3B%20%2F%2F%20isn%E2%80%99t%20guaranteed%20to%20return%20a%20string%5Cn%5Cn%2F%2F%20good%5Cnconst%20totalScore%20%3D%20String(this.reviewScore)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--numbers\">22.3</a> 数字类型：使用 <code>Number</code> 进行类型铸造和 <code>parseInt</code> 总是通过一个基数来解析一个字符串。 eslint: <a href=\"https://eslint.org/docs/rules/radix\" target=\"_blank\"><code>radix</code></a> <a href=\"https://eslint.org/docs/rules/no-new-wrappers\" target=\"_blank\"><code>no-new-wrappers</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20inputValue%20%3D%20'4'%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20val%20%3D%20new%20Number(inputValue)%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20val%20%3D%20%2BinputValue%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20val%20%3D%20inputValue%20%3E%3E%200%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20val%20%3D%20parseInt(inputValue)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20val%20%3D%20Number(inputValue)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20val%20%3D%20parseInt(inputValue%2C%2010)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--comment-deviations\">22.4</a> 如果出于某种原因，你正在做一些疯狂的事情，而 <code>parseInt</code> 是你的瓶颈，并且出于 <a href=\"https://jsperf.com/coercion-vs-casting/3\" target=\"_blank\">性能问题</a> 需要使用位运算， 请写下注释，说明为什么这样做和你做了什么。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20good%5Cn%2F**%5Cn%20*%20parseInt%20%E4%BD%BF%E6%88%91%E7%9A%84%E4%BB%A3%E7%A0%81%E5%8F%98%E6%85%A2%E3%80%82%5Cn%20*%20%E4%BD%8D%E8%BF%90%E7%AE%97%E5%B0%86%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B0%E5%AD%97%E6%9B%B4%E5%BF%AB%E3%80%82%5Cn%20*%2F%5Cnconst%20val%20%3D%20inputValue%20%3E%3E%200%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--bitwise\">22.5</a> <strong>注意：</strong> 当你使用位运算的时候要小心。 数字总是被以 <a href=\"https://es5.github.io/#x4.3.19\" target=\"_blank\">64-bit 值</a> 的形式表示，但是位运算总是返回一个 32-bit 的整数 (<a href=\"https://es5.github.io/#x11.7\" target=\"_blank\">来源</a>)。 对于大于 32 位的整数值，位运算可能会导致意外行为。<a href=\"https://github.com/airbnb/javascript/issues/109\" target=\"_blank\">讨论</a>。 最大的 32 位整数是： 2,147,483,647。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%222147483647%20%3E%3E%200%3B%20%2F%2F%20%3D%3E%202147483647%5Cn2147483648%20%3E%3E%200%3B%20%2F%2F%20%3D%3E%20-2147483648%5Cn2147483649%20%3E%3E%200%3B%20%2F%2F%20%3D%3E%20-2147483647%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#coercion--booleans\">22.6</a> 布尔类型： eslint: <a href=\"https://eslint.org/docs/rules/no-new-wrappers\" target=\"_blank\"><code>no-new-wrappers</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20age%20%3D%200%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20hasAge%20%3D%20new%20Boolean(age)%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20hasAge%20%3D%20Boolean(age)%3B%5Cn%5Cn%2F%2F%20best%5Cnconst%20hasAge%20%3D%20!!age%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"a3d10465\"><a>命名规范</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#naming--descriptive\">23.1</a> 避免单字母的名字。用你的命名来描述功能。 eslint: <a href=\"https://eslint.org/docs/rules/id-length\" target=\"_blank\"><code>id-length</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20q()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20query()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--camelCase\">23.2</a> 在命名对象、函数和实例时使用驼峰命名法（camelCase）。 eslint: <a href=\"https://eslint.org/docs/rules/camelcase.html\" target=\"_blank\"><code>camelcase</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20OBJEcttsssss%20%3D%20%7B%7D%3B%5Cnconst%20this_is_my_object%20%3D%20%7B%7D%3B%5Cnfunction%20c()%20%7B%7D%5Cn%5Cn%2F%2F%20good%5Cnconst%20thisIsMyObject%20%3D%20%7B%7D%3B%5Cnfunction%20thisIsMyFunction()%20%7B%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--PascalCase\">23.3</a> 只有在命名构造器或者类的时候才用帕斯卡拼命名法（PascalCase）。 eslint: <a href=\"https://eslint.org/docs/rules/new-cap.html\" target=\"_blank\"><code>new-cap</code></a>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20user(options)%20%7B%5Cn%20%20this.name%20%3D%20options.name%3B%5Cn%7D%5Cn%5Cnconst%20bad%20%3D%20new%20user(%7B%5Cn%20%20name%3A%20'nope'%2C%5Cn%7D)%3B%5Cn%5Cn%2F%2F%20good%5Cnclass%20User%20%7B%5Cn%20%20constructor(options)%20%7B%5Cn%20%20%20%20this.name%20%3D%20options.name%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cnconst%20good%20%3D%20new%20User(%7B%5Cn%20%20name%3A%20'yup'%2C%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--leading-underscore\">23.4</a> 不要使用前置或者后置下划线。 eslint: <a href=\"https://eslint.org/docs/rules/no-underscore-dangle.html\" target=\"_blank\"><code>no-underscore-dangle</code></a>\n<blockquote><p>为什么? JavaScript 在属性和方法方面没有隐私设置。 虽然前置的下划线是一种常见的惯例，意思是 “private” ，事实上，这些属性时公开的，因此，它们也是你公共 API 的一部分。 这种约定可能导致开发人员错误的认为更改不会被视为中断，或者不需要测试。建议：如果你想要什么东西是 “private” ， 那就一定不能有明显的表现。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnthis.__firstName__%20%3D%20'Panda'%3B%5Cnthis.firstName_%20%3D%20'Panda'%3B%5Cnthis._firstName%20%3D%20'Panda'%3B%5Cn%5Cn%2F%2F%20good%5Cnthis.firstName%20%3D%20'Panda'%3B%5Cn%5Cn%2F%2F%20%E5%A5%BD%EF%BC%8C%E5%9C%A8%20WeakMapx%20%E5%8F%AF%E7%94%A8%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%AD%5Cn%2F%2F%20see%20https%3A%2F%2Fkangax.github.io%2Fcompat-table%2Fes6%2F%23test-WeakMap%5Cnconst%20firstNames%20%3D%20new%20WeakMap()%3B%5CnfirstNames.set(this%2C%20'Panda')%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--self-this\">23.5</a> 不要保存 <code>this</code> 的引用。 使用箭头函数或者 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\" target=\"_blank\">函数#bind</a>。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20foo()%20%7B%5Cn%20%20const%20self%20%3D%20this%3B%5Cn%20%20return%20function%20()%20%7B%5Cn%20%20%20%20console.log(self)%3B%5Cn%20%20%7D%3B%5Cn%7D%5Cn%5Cn%2F%2F%20bad%5Cnfunction%20foo()%20%7B%5Cn%20%20const%20that%20%3D%20this%3B%5Cn%20%20return%20function%20()%20%7B%5Cn%20%20%20%20console.log(that)%3B%5Cn%20%20%7D%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20foo()%20%7B%5Cn%20%20return%20()%20%3D%3E%20%7B%5Cn%20%20%20%20console.log(this)%3B%5Cn%20%20%7D%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--filename-matches-export\">23.6</a> 文件名应该和默认导出的名称完全匹配。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20file%201%20contents%5Cnclass%20CheckBox%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cnexport%20default%20CheckBox%3B%5Cn%5Cn%2F%2F%20file%202%20contents%5Cnexport%20default%20function%20fortyTwo()%20%7B%20return%2042%3B%20%7D%5Cn%5Cn%2F%2F%20file%203%20contents%5Cnexport%20default%20function%20insideDirectory()%20%7B%7D%5Cn%5Cn%2F%2F%20in%20some%20other%20file%5Cn%2F%2F%20bad%5Cnimport%20CheckBox%20from%20'.%2FcheckBox'%3B%20%2F%2F%20PascalCase%20import%2Fexport%2C%20camelCase%20filename%5Cnimport%20FortyTwo%20from%20'.%2FFortyTwo'%3B%20%2F%2F%20PascalCase%20import%2Ffilename%2C%20camelCase%20export%5Cnimport%20InsideDirectory%20from%20'.%2FInsideDirectory'%3B%20%2F%2F%20PascalCase%20import%2Ffilename%2C%20camelCase%20export%5Cn%5Cn%2F%2F%20bad%5Cnimport%20CheckBox%20from%20'.%2Fcheck_box'%3B%20%2F%2F%20PascalCase%20import%2Fexport%2C%20snake_case%20filename%5Cnimport%20forty_two%20from%20'.%2Fforty_two'%3B%20%2F%2F%20snake_case%20import%2Ffilename%2C%20camelCase%20export%5Cnimport%20inside_directory%20from%20'.%2Finside_directory'%3B%20%2F%2F%20snake_case%20import%2C%20camelCase%20export%5Cnimport%20index%20from%20'.%2Finside_directory%2Findex'%3B%20%2F%2F%20requiring%20the%20index%20file%20explicitly%5Cnimport%20insideDirectory%20from%20'.%2FinsideDirectory%2Findex'%3B%20%2F%2F%20requiring%20the%20index%20file%20explicitly%5Cn%5Cn%2F%2F%20good%5Cnimport%20CheckBox%20from%20'.%2FCheckBox'%3B%20%2F%2F%20PascalCase%20export%2Fimport%2Ffilename%5Cnimport%20fortyTwo%20from%20'.%2FfortyTwo'%3B%20%2F%2F%20camelCase%20export%2Fimport%2Ffilename%5Cnimport%20insideDirectory%20from%20'.%2FinsideDirectory'%3B%20%2F%2F%20camelCase%20export%2Fimport%2Fdirectory%20name%2Fimplicit%20%5C%22index%5C%22%5Cn%2F%2F%20%5E%20supports%20both%20insideDirectory.js%20and%20insideDirectory%2Findex.js%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--camelCase-default-export\">23.7</a> 当你导出默认函数时使用驼峰命名法。 你的文件名应该和方法名相同。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20makeStyleGuide()%20%7B%5Cn%20%20%2F%2F%20...%5Cn%7D%5Cn%5Cnexport%20default%20makeStyleGuide%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--PascalCase-singleton\">23.8</a> 当你导出一个构造器 / 类 / 单例 / 函数库 / 暴露的对象时应该使用帕斯卡命名法。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22const%20AirbnbStyleGuide%20%3D%20%7B%5Cn%20%20es6%3A%20%7B%5Cn%20%20%7D%2C%5Cn%7D%3B%5Cn%5Cnexport%20default%20AirbnbStyleGuide%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--Acronyms-and-Initialisms\">23.9</a> 缩略词和缩写都必须是全部大写或者全部小写。\n<blockquote><p>为什么? 名字是为了可读性，不是为了满足计算机算法。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnimport%20SmsContainer%20from%20'.%2Fcontainers%2FSmsContainer'%3B%5Cn%5Cn%2F%2F%20bad%5Cnconst%20HttpRequests%20%3D%20%5B%5Cn%20%20%2F%2F%20...%5Cn%5D%3B%5Cn%5Cn%2F%2F%20good%5Cnimport%20SMSContainer%20from%20'.%2Fcontainers%2FSMSContainer'%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20HTTPRequests%20%3D%20%5B%5Cn%20%20%2F%2F%20...%5Cn%5D%3B%5Cn%5Cn%2F%2F%20also%20good%5Cnconst%20httpRequests%20%3D%20%5B%5Cn%20%20%2F%2F%20...%5Cn%5D%3B%5Cn%5Cn%2F%2F%20best%5Cnimport%20TextMessageContainer%20from%20'.%2Fcontainers%2FTextMessageContainer'%3B%5Cn%5Cn%2F%2F%20best%5Cnconst%20requests%20%3D%20%5B%5Cn%20%20%2F%2F%20...%5Cn%5D%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#naming--uppercase\">23.10</a> 你可以大写一个常量，如果它：（1）被导出，（2）使用 <code>const</code> 定义（不能被重新赋值），（3）程序员可以信任它（以及其嵌套的属性）是不变的。\n<blockquote><p>为什么? 这是一个可以帮助程序员确定变量是否会发生变化的辅助工具。UPPERCASE_VARIABLES 可以让程序员知道他们可以相信变量（及其属性）不会改变。</p></blockquote></li></ul><ul data-lake-indent=\"1\"><li>是否是对所有的 <code>const</code> 定义的变量？ - 这个是没有必要的，不应该在文件中使用大写。但是，它应该用于导出常量。</li></ul><ul data-lake-indent=\"1\"><li>导出对象呢？ - 在顶级导出属性 (e.g. <code>EXPORTED_OBJECT.key</code>) 并且保持所有嵌套属性不变。</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20PRIVATE_VARIABLE%20%3D%20'should%20not%20be%20unnecessarily%20uppercased%20within%20a%20file'%3B%5Cn%5Cn%2F%2F%20bad%5Cnexport%20const%20THING_TO_BE_CHANGED%20%3D%20'should%20obviously%20not%20be%20uppercased'%3B%5Cn%5Cn%2F%2F%20bad%5Cnexport%20let%20REASSIGNABLE_VARIABLE%20%3D%20'do%20not%20use%20let%20with%20uppercase%20variables'%3B%5Cn%5Cn%2F%2F%20---%5Cn%5Cn%2F%2F%20%E5%85%81%E8%AE%B8%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E6%8F%90%E4%BE%9B%E8%AF%AD%E4%B9%89%E5%80%BC%5Cnexport%20const%20apiKey%20%3D%20'SOMEKEY'%3B%5Cn%5Cn%2F%2F%20%E5%A4%9A%E6%95%B0%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%BE%88%E5%A5%BD%5Cnexport%20const%20API_KEY%20%3D%20'SOMEKEY'%3B%5Cn%5Cn%2F%2F%20---%5Cn%5Cn%2F%2F%20bad%20-%20%E4%B8%8D%E5%BF%85%E8%A6%81%E5%A4%A7%E5%86%99%20key%20%E6%B2%A1%E6%9C%89%E5%A2%9E%E5%8A%A0%E8%AF%AD%E4%B9%89%E5%80%BC%5Cnexport%20const%20MAPPING%20%3D%20%7B%5Cn%20%20KEY%3A%20'value'%5Cn%7D%3B%5Cn%5Cn%2F%2F%20good%5Cnexport%20const%20MAPPING%20%3D%20%7B%5Cn%20%20key%3A%20'value'%5Cn%7D%3B%22%7D\"></card><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"cd92de2a\"><a>存取器</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--not-required\">24.1</a> 对于属性的的存取函数不是必须的。</li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--no-getters-setters\">24.2</a> 不要使用 JavaScript 的 getters/setters 方法，因为它们会导致意外的副作用，并且更加难以测试、维护和推敲。 相应的，如果你需要存取函数的时候使用 <code>getVal()</code> 和 <code>setVal('hello')</code>。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnclass%20Dragon%20%7B%5Cn%20%20get%20age()%20%7B%5Cn%20%20%20%20%2F%2F%20...%5Cn%20%20%7D%5Cn%5Cn%20%20set%20age(value)%20%7B%5Cn%20%20%20%20%2F%2F%20...%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnclass%20Dragon%20%7B%5Cn%20%20getAge()%20%7B%5Cn%20%20%20%20%2F%2F%20...%5Cn%20%20%7D%5Cn%5Cn%20%20setAge(value)%20%7B%5Cn%20%20%20%20%2F%2F%20...%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--boolean-prefix\">24.3</a> 如果属性/方法是一个 <code>boolean</code> 值，使用 <code>isVal()</code> 或者 <code>hasVal()</code>。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnif%20(!dragon.age())%20%7B%5Cn%20%20return%20false%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnif%20(!dragon.hasAge())%20%7B%5Cn%20%20return%20false%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#accessors--consistent\">24.4</a> 可以创建 <code>get()</code> 和 <code>set()</code> 方法，但是要保证一致性。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22class%20Jedi%20%7B%5Cn%20%20constructor(options%20%3D%20%7B%7D)%20%7B%5Cn%20%20%20%20const%20lightsaber%20%3D%20options.lightsaber%20%7C%7C%20'blue'%3B%5Cn%20%20%20%20this.set('lightsaber'%2C%20lightsaber)%3B%5Cn%20%20%7D%5Cn%5Cn%20%20set(key%2C%20val)%20%7B%5Cn%20%20%20%20this%5Bkey%5D%20%3D%20val%3B%5Cn%20%20%7D%5Cn%5Cn%20%20get(key)%20%7B%5Cn%20%20%20%20return%20this%5Bkey%5D%3B%5Cn%20%20%7D%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"10b2761d\"><a>事件</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#events--hash\">25.1</a> 当给事件（无论是 DOM 事件还是更加私有的事件）附加数据时，传入一个对象（通畅也叫做 “hash” ） 而不是原始值。 这样可以让后边的贡献者向事件数据添加更多的数据，而不用找出更新事件的每个处理器。 例如，不好的写法：\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%24(this).trigger('listingUpdated'%2C%20listing.id)%3B%5Cn%5Cn%2F%2F%20...%5Cn%5Cn%24(this).on('listingUpdated'%2C%20(e%2C%20listingID)%20%3D%3E%20%7B%5Cn%20%20%2F%2F%20do%20something%20with%20listingID%5Cn%7D)%3B%22%7D\"></card>\n<br />更好的写法：\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20good%5Cn%24(this).trigger('listingUpdated'%2C%20%7B%20listingID%3A%20listing.id%20%7D)%3B%5Cn%5Cn%2F%2F%20...%5Cn%5Cn%24(this).on('listingUpdated'%2C%20(e%2C%20data)%20%3D%3E%20%7B%5Cn%20%20%2F%2F%20do%20something%20with%20data.listingID%5Cn%7D)%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"jQuery\">jQuery</h2><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--dollar-prefix\">26.1</a> 对于 jQuery 对象的变量使用 <code>$</code> 作为前缀。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnconst%20sidebar%20%3D%20%24('.sidebar')%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20%24sidebar%20%3D%20%24('.sidebar')%3B%5Cn%5Cn%2F%2F%20good%5Cnconst%20%24sidebarBtn%20%3D%20%24('.sidebar-btn')%3B%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--cache\">26.2</a> 缓存 jQuery 查询。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cnfunction%20setSidebar()%20%7B%5Cn%20%20%24('.sidebar').hide()%3B%5Cn%5Cn%20%20%2F%2F%20...%5Cn%5Cn%20%20%24('.sidebar').css(%7B%5Cn%20%20%20%20'background-color'%3A%20'pink'%2C%5Cn%20%20%7D)%3B%5Cn%7D%5Cn%5Cn%2F%2F%20good%5Cnfunction%20setSidebar()%20%7B%5Cn%20%20const%20%24sidebar%20%3D%20%24('.sidebar')%3B%5Cn%20%20%24sidebar.hide()%3B%5Cn%5Cn%20%20%2F%2F%20...%5Cn%5Cn%20%20%24sidebar.css(%7B%5Cn%20%20%20%20'background-color'%3A%20'pink'%2C%5Cn%20%20%7D)%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--queries\">26.3</a> 对于 DOM 查询使用层叠 <code>$('.sidebar ul')</code> 或 父元素 &gt; 子元素 <code>$('.sidebar &gt; ul')</code> 的格式。 <a href=\"http://jsperf.com/jquery-find-vs-context-sel/16\" target=\"_blank\">jsPerf</a></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#jquery--find\">26.4</a> 对于有作用域的 jQuery 对象查询使用 <code>find</code> 。\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5Cn%24('ul'%2C%20'.sidebar').hide()%3B%5Cn%5Cn%2F%2F%20bad%5Cn%24('.sidebar').find('ul').hide()%3B%5Cn%5Cn%2F%2F%20good%5Cn%24('.sidebar%20ul').hide()%3B%5Cn%5Cn%2F%2F%20good%5Cn%24('.sidebar%20%3E%20ul').hide()%3B%5Cn%5Cn%2F%2F%20good%5Cn%24sidebar.find('ul').hide()%3B%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"b59ab4d6\"><a>ECMAScript 5 兼容性</a></h2><p><br /></p><p><br /></p><ul><li><a href=\"#es5-compat--kangax\">27.1</a> 参考 <a href=\"https://twitter.com/kangax/\" target=\"_blank\">Kangax</a>的 ES5 <a href=\"https://kangax.github.io/es5-compat-table/\" target=\"_blank\">兼容性表格</a>。</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><p><br /></p><h2 id=\"c64dfd7d\">ECMAScript 6+ (ES 2015+) Styles</h2><p><br /></p><p><br /></p><ul><li><a href=\"#es6-styles\">28.1</a> 这是一个链接到各种 ES6+ 特性的集合。</li></ul><p><br /></p><ol start=\"1\"><li><a href=\"#arrow-functions\">箭头函数</a></li></ol><ol start=\"2\"><li><a href=\"#classes--constructors\">类</a></li></ol><ol start=\"3\"><li><a href=\"#es6-object-shorthand\">对象简写</a></li></ol><ol start=\"4\"><li><a href=\"#es6-object-concise\">对象简洁</a></li></ol><ol start=\"5\"><li><a href=\"#es6-computed-properties\">对象计算属性</a></li></ol><ol start=\"6\"><li><a href=\"#es6-template-literals\">字符串模板</a></li></ol><ol start=\"7\"><li><a href=\"#destructuring\">解构</a></li></ol><ol start=\"8\"><li><a href=\"#es6-default-parameters\">默认参数</a></li></ol><ol start=\"9\"><li><a href=\"#es6-rest\">Rest</a></li></ol><ol start=\"10\"><li><a href=\"#es6-array-spreads\">数组展开</a></li></ol><ol start=\"11\"><li><a href=\"#references\">Let 和 Const</a></li></ol><ol start=\"12\"><li><a href=\"#es2016-properties--exponentiation-operator\">求幂运算符</a></li></ol><ol start=\"13\"><li><a href=\"#iterators-and-generators\">迭代器和发生器</a></li></ol><ol start=\"14\"><li><a href=\"#modules\">模块</a></li></ol><p><br /></p><p><br /></p><ul><li><a href=\"#tc39-proposals\">28.2</a> 不要使用尚未达到第3阶段的 <a href=\"https://github.com/tc39/proposals\" target=\"_blank\">TC39 建议</a>。\n<blockquote><p>为什么? <a href=\"https://tc39.github.io/process-document/\" target=\"_blank\">它们没有最终确定</a>， 并且它们可能会被改变或完全撤回。我们希望使用JavaScript，而建议还不是JavaScript。</p></blockquote></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"dd970a1f\"><a>标准库</a></h2><p><br /></p><p><a href=\"https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects\" target=\"_blank\">标准库</a><br />\n包含功能已损坏的实用工具，但因为遗留原因而保留。</p><p><br /></p><p><br /></p><ul><li><a href=\"#standard-library--isnan\">29.1</a> 使用 <code>Number.isNaN</code> 代替全局的 <code>isNaN</code>.<br />\neslint: <a href=\"https://eslint.org/docs/rules/no-restricted-globals\" target=\"_blank\"><code>no-restricted-globals</code></a>\n<blockquote><p>为什么? 全局的 <code>isNaN</code> 强制非数字转化为数字，对任何强制转化为 NaN 的东西都返回 true。</p></blockquote><blockquote><p>如果需要这种行为，请明确说明。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5CnisNaN('1.2')%3B%20%2F%2F%20false%5CnisNaN('1.2.3')%3B%20%2F%2F%20true%5Cn%5Cn%2F%2F%20good%5CnNumber.isNaN('1.2.3')%3B%20%2F%2F%20false%5CnNumber.isNaN(Number('1.2.3'))%3B%20%2F%2F%20true%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#standard-library--isfinite\">29.2</a> 使用 <code>Number.isFinite</code> 代替全局的 <code>isFinite</code>.<br />\neslint: <a href=\"https://eslint.org/docs/rules/no-restricted-globals\" target=\"_blank\"><code>no-restricted-globals</code></a>\n<blockquote><p>为什么? 全局的 <code>isFinite</code> 强制非数字转化为数字，对任何强制转化为有限数字的东西都返回 true。</p></blockquote><blockquote><p>如果需要这种行为，请明确说明。</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20bad%5CnisFinite('2e3')%3B%20%2F%2F%20true%5Cn%5Cn%2F%2F%20good%5CnNumber.isFinite('2e3')%3B%20%2F%2F%20false%5CnNumber.isFinite(parseInt('2e3'%2C%2010))%3B%20%2F%2F%20true%22%7D\"></card></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"Testing\">Testing</h2><p><br /></p><p><br /></p><ul><li><a href=\"#testing--yup\">30.1</a> <strong>是的.</strong>\n<card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20foo()%20%7B%5Cn%20%20return%20true%3B%5Cn%7D%22%7D\"></card></li></ul><p><br /></p><p><br /></p><ul><li><a href=\"#testing--for-real\">30.2</a> <strong>没有，但是认真</strong>:</li></ul><ul data-lake-indent=\"1\"><li>无论你使用那种测试框架，都应该编写测试！</li></ul><ul data-lake-indent=\"1\"><li>努力写出许多小的纯函数，并尽量减少发生错误的地方。</li></ul><ul data-lake-indent=\"1\"><li>对于静态方法和 mock 要小心----它们会使你的测试更加脆弱。</li></ul><ul data-lake-indent=\"1\"><li>我们主要在 Airbnb 上使用 <a href=\"https://www.npmjs.com/package/mocha\" target=\"_blank\"><code>mocha</code></a> 和 <a href=\"https://www.npmjs.com/package/jest\" target=\"_blank\"><code>jest</code></a> 。 <a href=\"https://www.npmjs.com/package/tape\" target=\"_blank\"><code>tape</code></a> 也会用在一些小的独立模块上。</li></ul><ul data-lake-indent=\"1\"><li>100%的测试覆盖率是一个很好的目标，即使它并不总是可行的。</li></ul><ul data-lake-indent=\"1\"><li>无论何时修复bug，都要编写一个回归测试。在没有回归测试的情况下修复的bug在将来几乎肯定会再次崩溃。</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"c3318eaa\"><a>性能</a></h2><p><br /></p><ul><li><a href=\"https://www.kellegous.com/j/2013/01/26/layout-performance/\" target=\"_blank\">On Layout &amp; Web Performance</a></li></ul><ul><li><a href=\"https://jsperf.com/string-vs-array-concat/2\" target=\"_blank\">String vs Array Concat</a></li></ul><ul><li><a href=\"https://jsperf.com/try-catch-in-loop-cost\" target=\"_blank\">Try/Catch Cost In a Loop</a></li></ul><ul><li><a href=\"https://jsperf.com/bang-function\" target=\"_blank\">Bang Function</a></li></ul><ul><li><a href=\"https://jsperf.com/jquery-find-vs-context-sel/13\" target=\"_blank\">jQuery Find vs Context, Selector</a></li></ul><ul><li><a href=\"https://jsperf.com/innerhtml-vs-textcontent-for-script-text\" target=\"_blank\">innerHTML vs textContent for script text</a></li></ul><ul><li><a href=\"https://jsperf.com/ya-string-concat\" target=\"_blank\">Long String Concatenation</a></li></ul><ul><li><a href=\"https://www.quora.com/JavaScript-programming-language-Are-Javascript-functions-like-map-reduce-and-filter-already-optimized-for-traversing-array/answer/Quildreen-Motta\" target=\"_blank\">Are Javascript functions like <code>map()</code>, <code>reduce()</code>, and <code>filter()</code> optimized for traversing arrays?</a></li></ul><ul><li>Loading...</li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"eee83a92\"><a>资源</a></h2><p><br /></p><p><strong>学习 ES6+</strong></p><p><br /></p><ul><li><a href=\"https://tc39.github.io/ecma262/\" target=\"_blank\">Latest ECMA spec</a></li></ul><ul><li><a href=\"http://exploringjs.com/\" target=\"_blank\">ExploringJS</a></li></ul><ul><li><a href=\"https://kangax.github.io/compat-table/es6/\" target=\"_blank\">ES6 Compatibility Table</a></li></ul><ul><li><a href=\"http://es6-features.org/\" target=\"_blank\">Comprehensive Overview of ES6 Features</a></li></ul><p><br /></p><p><strong>读这个</strong></p><p><br /></p><ul><li><a href=\"http://www.ecma-international.org/ecma-262/6.0/index.html\" target=\"_blank\">Standard ECMA-262</a></li></ul><p><br /></p><p><strong>工具</strong></p><p><br /></p><ul><li>Code Style Linters</li></ul><ul data-lake-indent=\"1\"><li><a href=\"https://eslint.org/\" target=\"_blank\">ESlint</a> - <a href=\"https://github.com/airbnb/javascript/blob/master/linters/.eslintrc\" target=\"_blank\">Airbnb Style .eslintrc</a></li></ul><ul data-lake-indent=\"1\"><li><a href=\"http://jshint.com/\" target=\"_blank\">JSHint</a> - <a href=\"https://github.com/airbnb/javascript/blob/master/linters/.jshintrc\" target=\"_blank\">Airbnb Style .jshintrc</a></li></ul><ul><li>Neutrino preset - <a href=\"https://neutrino.js.org/presets/neutrino-preset-airbnb-base/\" target=\"_blank\">neutrino-preset-airbnb-base</a></li></ul><p><br /></p><p><strong>其他编码规范</strong></p><p><br /></p><ul><li><a href=\"https://google.github.io/styleguide/javascriptguide.xml\" target=\"_blank\">Google JavaScript Style Guide</a></li></ul><ul><li><a href=\"https://contribute.jquery.org/style-guide/js/\" target=\"_blank\">jQuery Core Style Guidelines</a></li></ul><ul><li><a href=\"https://github.com/rwaldron/idiomatic.js\" target=\"_blank\">Principles of Writing Consistent, Idiomatic JavaScript</a></li></ul><ul><li><a href=\"https://standardjs.com\" target=\"_blank\">StandardJS</a></li></ul><p><br /></p><p><strong>其他风格</strong></p><p><br /></p><ul><li><a href=\"https://gist.github.com/cjohansen/4135065\" target=\"_blank\">Naming this in nested functions</a> - Christian Johansen</li></ul><ul><li><a href=\"https://github.com/airbnb/javascript/issues/52\" target=\"_blank\">Conditional Callbacks</a> - Ross Allen</li></ul><ul><li><a href=\"http://sideeffect.kr/popularconvention/#javascript\" target=\"_blank\">Popular JavaScript Coding Conventions on GitHub</a> - JeongHoon Byun</li></ul><ul><li><a href=\"http://benalman.com/news/2012/05/multiple-var-statements-javascript/\" target=\"_blank\">Multiple var statements in JavaScript, not superfluous</a> - Ben Alman</li></ul><p><br /></p><p><strong>进一步阅读</strong></p><p><br /></p><ul><li><a href=\"https://javascriptweblog.wordpress.com/2010/10/25/understanding-javascript-closures/\" target=\"_blank\">Understanding JavaScript Closures</a> - Angus Croll</li></ul><ul><li><a href=\"http://www.2ality.com/2013/06/basic-javascript.html\" target=\"_blank\">Basic JavaScript for the impatient programmer</a> - Dr. Axel Rauschmayer</li></ul><ul><li><a href=\"http://youmightnotneedjquery.com/\" target=\"_blank\">You Might Not Need jQuery</a> - Zack Bloom &amp; Adam Schwartz</li></ul><ul><li><a href=\"https://github.com/lukehoban/es6features\" target=\"_blank\">ES6 Features</a> - Luke Hoban</li></ul><ul><li><a href=\"https://github.com/bendc/frontend-guidelines\" target=\"_blank\">Frontend Guidelines</a> - Benjamin De Cock</li></ul><p><br /></p><p><strong>书籍</strong></p><p><br /></p><ul><li><a href=\"https://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742\" target=\"_blank\">JavaScript: The Good Parts</a> - Douglas Crockford</li></ul><ul><li><a href=\"https://www.amazon.com/JavaScript-Patterns-Stoyan-Stefanov/dp/0596806752\" target=\"_blank\">JavaScript Patterns</a> - Stoyan Stefanov</li></ul><ul><li><a href=\"https://www.amazon.com/JavaScript-Design-Patterns-Recipes-Problem-Solution/dp/159059908X\" target=\"_blank\">Pro JavaScript Design Patterns</a>  - Ross Harmes and Dustin Diaz</li></ul><ul><li><a href=\"https://www.amazon.com/High-Performance-Web-Sites-Essential/dp/0596529309\" target=\"_blank\">High Performance Web Sites: Essential Knowledge for Front-End Engineers</a> - Steve Souders</li></ul><ul><li><a href=\"https://www.amazon.com/Maintainable-JavaScript-Nicholas-C-Zakas/dp/1449327680\" target=\"_blank\">Maintainable JavaScript</a> - Nicholas C. Zakas</li></ul><ul><li><a href=\"https://www.amazon.com/JavaScript-Web-Applications-Alex-MacCaw/dp/144930351X\" target=\"_blank\">JavaScript Web Applications</a> - Alex MacCaw</li></ul><ul><li><a href=\"https://www.amazon.com/Pro-JavaScript-Techniques-John-Resig/dp/1590597273\" target=\"_blank\">Pro JavaScript Techniques</a> - John Resig</li></ul><ul><li><a href=\"https://www.amazon.com/Smashing-Node-js-JavaScript-Everywhere-Magazine/dp/1119962595\" target=\"_blank\">Smashing Node.js: JavaScript Everywhere</a> - Guillermo Rauch</li></ul><ul><li><a href=\"https://www.amazon.com/Secrets-JavaScript-Ninja-John-Resig/dp/193398869X\" target=\"_blank\">Secrets of the JavaScript Ninja</a> - John Resig and Bear Bibeault</li></ul><ul><li><a href=\"http://humanjavascript.com/\" target=\"_blank\">Human JavaScript</a> - Henrik Joreteg</li></ul><ul><li><a href=\"http://superherojs.com/\" target=\"_blank\">Superhero.js</a> - Kim Joar Bekkelund, Mads Mobæk, &amp; Olav Bjorkoy</li></ul><ul><li><a href=\"http://jsbooks.revolunet.com/\" target=\"_blank\">JSBooks</a> - Julien Bouquillon</li></ul><ul><li><a href=\"https://www.manning.com/books/third-party-javascript\" target=\"_blank\">Third Party JavaScript</a> - Ben Vinegar and Anton Kovalyov</li></ul><ul><li><a href=\"http://amzn.com/0321812182\" target=\"_blank\">Effective JavaScript: 68 Specific Ways to Harness the Power of JavaScript</a> - David Herman</li></ul><ul><li><a href=\"http://eloquentjavascript.net/\" target=\"_blank\">Eloquent JavaScript</a> - Marijn Haverbeke</li></ul><ul><li><a href=\"http://shop.oreilly.com/product/0636920033769.do\" target=\"_blank\">You Don’t Know JS: ES6 &amp; Beyond</a> - Kyle Simpson</li></ul><p><br /></p><p><strong>博客</strong></p><p><br /></p><ul><li><a href=\"http://javascriptweekly.com/\" target=\"_blank\">JavaScript Weekly</a></li></ul><ul><li><a href=\"https://javascriptweblog.wordpress.com/\" target=\"_blank\">JavaScript, JavaScript...</a></li></ul><ul><li><a href=\"https://bocoup.com/weblog\" target=\"_blank\">Bocoup Weblog</a></li></ul><ul><li><a href=\"http://www.adequatelygood.com/\" target=\"_blank\">Adequately Good</a></li></ul><ul><li><a href=\"https://www.nczonline.net/\" target=\"_blank\">NCZOnline</a></li></ul><ul><li><a href=\"http://perfectionkills.com/\" target=\"_blank\">Perfection Kills</a></li></ul><ul><li><a href=\"http://benalman.com/\" target=\"_blank\">Ben Alman</a></li></ul><ul><li><a href=\"http://dmitry.baranovskiy.com/\" target=\"_blank\">Dmitry Baranovskiy</a></li></ul><ul><li><a href=\"http://code.tutsplus.com/?s=javascript\" target=\"_blank\">nettuts</a></li></ul><p><br /></p><p><strong>播客</strong></p><p><br /></p><ul><li><a href=\"https://javascriptair.com/\" target=\"_blank\">JavaScript Air</a></li></ul><ul><li><a href=\"https://devchat.tv/js-jabber/\" target=\"_blank\">JavaScript Jabber</a></li></ul><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><p><br /></p><h2 id=\"935a8bc4\"><a>JavaScript风格指南的指南</a></h2><p><br /></p><ul><li><a href=\"https://github.com/airbnb/javascript/wiki/The-JavaScript-Style-Guide-Guide\" target=\"_blank\">Reference</a></li></ul><p><br /></p><h2 id=\"20a28457\"><a>许可证</a></h2><p><br /></p><p>(The MIT License)</p><p><br /></p><p>Copyright (c) 2012 康兵奎</p><p><br /></p><p>Permission is hereby granted, free of charge, to any person obtaining<br />\na copy of this software and associated documentation files (the<br />\n'Software'), to deal in the Software without restriction, including<br />\nwithout limitation the rights to use, copy, modify, merge, publish,<br />\ndistribute, sublicense, and/or sell copies of the Software, and to<br />\npermit persons to whom the Software is furnished to do so, subject to<br />\nthe following conditions:</p><p><br /></p><p>The above copyright notice and this permission notice shall be<br />\nincluded in all copies or substantial portions of the Software.</p><p><br /></p><p>THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,<br />\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF<br />\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.<br />\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY<br />\nCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<br />\nTORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE<br />\nSOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p><p><br /></p><p><strong><a href=\"#table-of-contents\">⬆ 返回目录</a></strong></p><h2 id=\"d41d8cd9\"><br /><cursor /></h2>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-05T14:56:10.000Z",
    "deleted_at": null,
    "created_at": "2019-03-05T13:56:15.000Z",
    "updated_at": "2019-03-05T14:56:11.000Z",
    "published_at": "2019-03-05T14:56:10.000Z",
    "first_published_at": "2019-03-05T13:57:33.000Z",
    "word_count": 13341,
    "cover": null,
    "description": "转自 https://github.com/BingKui/javascript-zh一种写JavaScript更合理的代码风格。Note: 本指南假设你使用了 Babel, 并且要求你使用 babel-preset-airbnb 或者其他同等资源。 并且假设你在你的应用中安装了 shims/...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1330062,
    "slug": "wlw0e9",
    "title": "travis-ci加持",
    "book_id": 223480,
    "book": {
      "id": 223480,
      "type": "Book",
      "slug": "lch",
      "name": "Lite Code House",
      "user_id": 273716,
      "description": "share mark",
      "creator_id": 273716,
      "public": 1,
      "items_count": 6,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-05T14:56:11.170Z",
      "updated_at": "2019-03-05T14:56:11.000Z",
      "created_at": "2019-02-23T14:05:16.000Z",
      "namespace": "maclejean/lch",
      "user": {
        "id": 273716,
        "type": "User",
        "login": "maclejean",
        "name": "张杰",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2019-02-23T08:29:39.000Z",
        "updated_at": "2019-02-26T02:38:41.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 273716,
    "creator": {
      "id": 273716,
      "type": "User",
      "login": "maclejean",
      "name": "张杰",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2019-02-23T08:29:39.000Z",
      "updated_at": "2019-02-26T02:38:41.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "<p><span style=\"color: #000000;\">部分内容参考自 天涯明月笙，</span><a href=\"https://blog.csdn.net/qq_23079443/article/details/79015225\" target=\"_blank\"><span style=\"color: #000000;\">《用TravisCI持续集成自动部署Hexo博客的个人实践》</span></a></p><h2 id=\"88210852\">准备工作</h2><ul><li><a href=\"https://travis-ci.org/\" target=\"_blank\">https://travis-ci.org/</a>，用github注册，然后选择一个git项目</li><li>准备Github Personal Access Token。</li><li><a href=\"https://rubyinstaller.org/downloads/\" target=\"_blank\">ruby for windows</a></li><li>gem install travis</li></ul><h2 id=\"7af603bb\">开始配置</h2><ol start=\"1\"><li>登陆你的travis命令行（github 账户与密码）</li></ol><pre><code>travis login</code></pre><ol start=\"2\"><li>加密</li></ol><p><br /></p><p><br /></p>",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-05T14:46:32.000Z",
    "deleted_at": null,
    "created_at": "2019-03-05T13:49:33.000Z",
    "updated_at": "2019-03-05T14:46:32.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "部分内容参考自 天涯明月笙，《用TravisCI持续集成自动部署Hexo博客的个人实践》准备工作https://travis-ci.org/，用github注册，然后选择一个git项目准备Github Personal Access Token。ruby for windowsgem inst...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1330060,
    "slug": "hkf2sl",
    "title": "无标题",
    "book_id": 223480,
    "book": {
      "id": 223480,
      "type": "Book",
      "slug": "lch",
      "name": "Lite Code House",
      "user_id": 273716,
      "description": "share mark",
      "creator_id": 273716,
      "public": 1,
      "items_count": 6,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-05T14:56:11.170Z",
      "updated_at": "2019-03-05T14:56:11.000Z",
      "created_at": "2019-02-23T14:05:16.000Z",
      "namespace": "maclejean/lch",
      "user": {
        "id": 273716,
        "type": "User",
        "login": "maclejean",
        "name": "张杰",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2019-02-23T08:29:39.000Z",
        "updated_at": "2019-02-26T02:38:41.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 273716,
    "creator": {
      "id": 273716,
      "type": "User",
      "login": "maclejean",
      "name": "张杰",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2019-02-23T08:29:39.000Z",
      "updated_at": "2019-02-26T02:38:41.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "<p><br /></p>",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-05T13:49:29.000Z",
    "deleted_at": null,
    "created_at": "2019-03-05T13:49:25.000Z",
    "updated_at": "2019-03-05T13:49:29.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1325233,
    "slug": "yuque",
    "title": "语雀加持",
    "book_id": 223480,
    "book": {
      "id": 223480,
      "type": "Book",
      "slug": "lch",
      "name": "Lite Code House",
      "user_id": 273716,
      "description": "share mark",
      "creator_id": 273716,
      "public": 1,
      "items_count": 6,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-05T14:56:11.170Z",
      "updated_at": "2019-03-05T14:56:11.000Z",
      "created_at": "2019-02-23T14:05:16.000Z",
      "namespace": "maclejean/lch",
      "user": {
        "id": 273716,
        "type": "User",
        "login": "maclejean",
        "name": "张杰",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2019-02-23T08:29:39.000Z",
        "updated_at": "2019-02-26T02:38:41.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 273716,
    "creator": {
      "id": 273716,
      "type": "User",
      "login": "maclejean",
      "name": "张杰",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2019-02-23T08:29:39.000Z",
      "updated_at": "2019-02-26T02:38:41.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"88210852\"></a>\n## 准备工作\n* yuque-hexo （node package）\n* 已经搭建好了hexo博客（可参考上一篇[文章](https://maclejean.github.io/2019/02/26/yuque/config/)）\n* [语雀](https://www.yuque.com/dashboard)注册，并新建**公开**知识库（必须公开，会有个知识库路径**命名**）\n* 文章部分内容参考[乱码](https://luan.ma/post/yuque2blog/)\n<a name=\"224e2ccd\"></a>\n## 配置\n在你的项目根目录的package.json追加一下内容\n```json\n//假设json可以添加注释\n{\n  \"yuqueConfig\": {\n    \"baseUrl\": \"https://www.yuque.com/api/v2\", //api配置，无需更改\n    \"login\": \"maclejean\", //用户名\n    \"repo\": \"luan.ma\",  //知识库的命名\n    \"mdNameFormat\": \"slug\", \n    \"postPath\": \"source/_posts/yuque\" //同步下来，文章的存放路径，这里拷贝默认即可\n  }\n}\n```\n\n<a name=\"6f7e90ea\"></a>\n## 语雀常用命令\n\n```bash\nyuque-hexo sync\n```\n同步上面配置的知识库的文章，到本地目录，并更新yuque.json<br />\n\n```bash\nyuque-hexo clean\n```\n删除**yuque.json，**清理掉上面配置的postPath里面的文章（比如你删除了语雀的文章，重命名等，本地也要相应的删除，要不然会出现重复的文章，我就碰到这个坑）<br /><br /><br />常用的就这两个，其他的我也没用过，没研究过，剩下的就是发布博客，推送到远端什么的，就是hexo那一套了<br />因为clean跟sync 一般是一起执行，这里我是把命令写在scripts配置里面执行的。\n\n```json\n\"scripts\":{\n    \"update\":\"yuque-hexo clean && yuque-hexo sync\",\n}\n```\n下一篇介绍下，搭配ci怎么做到自动化构建，发布等\n",
    "body_draft": "",
    "body_html": "<h2 id=\"88210852\">准备工作</h2><ul><li>yuque-hexo （node package）</li><li>已经搭建好了hexo博客（可参考上一篇<a href=\"https://maclejean.github.io/2019/02/26/yuque/config/\" target=\"_blank\">文章</a>）</li><li><a href=\"https://www.yuque.com/dashboard\" target=\"_blank\">语雀</a>注册，并新建<span style=\"color: #F5222D;\"><strong>公开</strong></span>知识库（必须公开，会有个知识库路径<span style=\"color: #F5222D;\"><strong>命名</strong></span>）</li><li>文章部分内容参考<a href=\"https://luan.ma/post/yuque2blog/\" target=\"_blank\">乱码</a></li></ul><h2 id=\"224e2ccd\">配置</h2><p style=\"text-indent: 2em;\">在你的项目根目录的package.json追加一下内容</p><pre data-lang=\"json\"><code>//假设json可以添加注释\n{\n  &quot;yuqueConfig&quot;: {\n    &quot;baseUrl&quot;: &quot;https://www.yuque.com/api/v2&quot;, //api配置，无需更改\n    &quot;login&quot;: &quot;maclejean&quot;, //用户名\n    &quot;repo&quot;: &quot;luan.ma&quot;,  //知识库的命名\n    &quot;mdNameFormat&quot;: &quot;slug&quot;, \n    &quot;postPath&quot;: &quot;source/_posts/yuque&quot; //同步下来，文章的存放路径，这里拷贝默认即可\n  }\n}</code></pre><p><br /></p><h2 id=\"6f7e90ea\">语雀常用命令</h2><p><br /></p><pre data-lang=\"bash\"><code>yuque-hexo sync</code></pre><p style=\"text-indent: 2em;\">同步上面配置的知识库的文章，到本地目录，并更新yuque.json</p><p style=\"text-indent: 2em;\"><br /></p><pre data-lang=\"bash\"><code>yuque-hexo clean</code></pre><p style=\"text-indent: 2em;\"><span style=\"color: #000000;\">删除</span><strong><span style=\"color: #F5222D;\">yuque.json<span style=\"color: #000000;\">，</span></span></strong><span style=\"color: #F5222D;\"><span style=\"color: #000000;\">清理掉上面配置的postPath里面的文章（比如你删除了语雀的文章，重命名等，本地也要相应的删除，要不然会出现重复的文章，我就碰到这个坑）</span></span></p><p><span style=\"color: #F5222D;\"><span style=\"color: #000000;\"><br /></span></span></p><p>常用的就这两个，其他的我也没用过，没研究过，剩下的就是发布博客，推送到远端什么的，就是hexo那一套了</p><p>因为clean跟sync 一般是一起执行，这里我是把命令写在scripts配置里面执行的。</p><p><br /></p><pre data-lang=\"json\"><code>&quot;scripts&quot;:{\n    &quot;update&quot;:&quot;yuque-hexo clean &amp;&amp; yuque-hexo sync&quot;,\n}</code></pre><p>下一篇介绍下，搭配ci怎么做到自动化构建，发布等</p>",
    "body_lake": "<!doctype lake><h2 id=\"88210852\">准备工作</h2><ul><li>yuque-hexo （node package）</li><li>已经搭建好了hexo博客（可参考上一篇<a href=\"https://maclejean.github.io/2019/02/26/yuque/config/\" target=\"_blank\">文章</a>）</li><li><a href=\"https://www.yuque.com/dashboard\" target=\"_blank\">语雀</a>注册，并新建<span style=\"color: #F5222D;\"><strong>公开</strong></span>知识库（必须公开，会有个知识库路径<span style=\"color: #F5222D;\"><strong>命名</strong></span>）</li><li>文章部分内容参考<a href=\"https://luan.ma/post/yuque2blog/\" target=\"_blank\">乱码</a></li></ul><h2 id=\"224e2ccd\">配置</h2><p style=\"text-indent: 2em;\">在你的项目根目录的package.json追加一下内容</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22json%22%2C%22code%22%3A%22%2F%2F%E5%81%87%E8%AE%BEjson%E5%8F%AF%E4%BB%A5%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A%5Cn%7B%5Cn%20%20%5C%22yuqueConfig%5C%22%3A%20%7B%5Cn%20%20%20%20%5C%22baseUrl%5C%22%3A%20%5C%22https%3A%2F%2Fwww.yuque.com%2Fapi%2Fv2%5C%22%2C%20%2F%2Fapi%E9%85%8D%E7%BD%AE%EF%BC%8C%E6%97%A0%E9%9C%80%E6%9B%B4%E6%94%B9%5Cn%20%20%20%20%5C%22login%5C%22%3A%20%5C%22maclejean%5C%22%2C%20%2F%2F%E7%94%A8%E6%88%B7%E5%90%8D%5Cn%20%20%20%20%5C%22repo%5C%22%3A%20%5C%22luan.ma%5C%22%2C%20%20%2F%2F%E7%9F%A5%E8%AF%86%E5%BA%93%E7%9A%84%E5%91%BD%E5%90%8D%5Cn%20%20%20%20%5C%22mdNameFormat%5C%22%3A%20%5C%22slug%5C%22%2C%20%5Cn%20%20%20%20%5C%22postPath%5C%22%3A%20%5C%22source%2F_posts%2Fyuque%5C%22%20%2F%2F%E5%90%8C%E6%AD%A5%E4%B8%8B%E6%9D%A5%EF%BC%8C%E6%96%87%E7%AB%A0%E7%9A%84%E5%AD%98%E6%94%BE%E8%B7%AF%E5%BE%84%EF%BC%8C%E8%BF%99%E9%87%8C%E6%8B%B7%E8%B4%9D%E9%BB%98%E8%AE%A4%E5%8D%B3%E5%8F%AF%5Cn%20%20%7D%5Cn%7D%22%7D\"></card><p><br /></p><h2 id=\"6f7e90ea\">语雀常用命令</h2><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22yuque-hexo%20sync%22%7D\"></card><p style=\"text-indent: 2em;\">同步上面配置的知识库的文章，到本地目录，并更新yuque.json</p><p style=\"text-indent: 2em;\"><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22yuque-hexo%20clean%22%7D\"></card><p style=\"text-indent: 2em;\"><span style=\"color: #000000;\">删除</span><strong><span style=\"color: #F5222D;\">yuque.json<span style=\"color: #000000;\">，</span></span></strong><span style=\"color: #F5222D;\"><span style=\"color: #000000;\">清理掉上面配置的postPath里面的文章（比如你删除了语雀的文章，重命名等，本地也要相应的删除，要不然会出现重复的文章，我就碰到这个坑）</span></span></p><p><span style=\"color: #F5222D;\"><span style=\"color: #000000;\"><br /></span></span></p><p>常用的就这两个，其他的我也没用过，没研究过，剩下的就是发布博客，推送到远端什么的，就是hexo那一套了</p><p>因为clean跟sync 一般是一起执行，这里我是把命令写在scripts配置里面执行的。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22json%22%2C%22code%22%3A%22%5C%22scripts%5C%22%3A%7B%5Cn%20%20%20%20%5C%22update%5C%22%3A%5C%22yuque-hexo%20clean%20%26%26%20yuque-hexo%20sync%5C%22%2C%5Cn%7D%22%7D\"></card><p>下一篇介绍下，搭配ci怎么做到自动化构建，发布等</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-03-04T14:26:49.000Z",
    "deleted_at": null,
    "created_at": "2019-03-04T13:55:55.000Z",
    "updated_at": "2019-03-04T14:27:52.000Z",
    "published_at": "2019-03-04T14:27:04.000Z",
    "first_published_at": "2019-03-04T14:26:49.000Z",
    "word_count": 369,
    "cover": null,
    "description": "准备工作yuque-hexo （node package）已经搭建好了hexo博客（可参考上一篇文章）语雀注册，并新建公开知识库（必须公开，会有个知识库路径命名）文章部分内容参考乱码配置在你的项目根目录的package.json追加一下内容//假设json可以添加注释 {   &quot;yu...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1300578,
    "slug": "config",
    "title": "搭建属于我的静态博客",
    "book_id": 223480,
    "book": {
      "id": 223480,
      "type": "Book",
      "slug": "lch",
      "name": "Lite Code House",
      "user_id": 273716,
      "description": "share mark",
      "creator_id": 273716,
      "public": 1,
      "items_count": 6,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-05T14:56:11.170Z",
      "updated_at": "2019-03-05T14:56:11.000Z",
      "created_at": "2019-02-23T14:05:16.000Z",
      "namespace": "maclejean/lch",
      "user": {
        "id": 273716,
        "type": "User",
        "login": "maclejean",
        "name": "张杰",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2019-02-23T08:29:39.000Z",
        "updated_at": "2019-02-26T02:38:41.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 273716,
    "creator": {
      "id": 273716,
      "type": "User",
      "login": "maclejean",
      "name": "张杰",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2019-02-23T08:29:39.000Z",
      "updated_at": "2019-02-26T02:38:41.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "<a name=\"3f38a0ec\"></a>\n## 相关工具\n* node （安装）\n* ruby （安装）\n* hexo （node package）\n* github （githubpages 配置）\n* hexo-deployer-git（node package）\n<a name=\"88210852\"></a>\n## 准备工作\n1.安装[node](https://nodejs.org/zh-cn/)<br />2.安装[ruby](https://rubyinstaller.org/)<br />3.安装[hexo](https://hexo.io/zh-cn/)命令行工具\n\n```bash\nnpm install -g hexo-cli\n```\n\n4.[githubpage](https://pages.github.com/)配置<br />\n![image.png](https://cdn.nlark.com/yuque/0/2019/png/273716/1551274000249-20d4c46d-9084-4a10-aa59-c43835840ca9.png#align=left&display=inline&height=423&name=image.png&originHeight=423&originWidth=952&size=55903&status=done&width=952)<br />“User or organization site”是生成username.github.io的域名静态博客（推荐这一种，逼格更高）<br />“Project site”是生成github.io/projectname的静态博客<br />其他的配置就参照githubpage的教程，就两三步。\n\n5.安装hexo-deployer-git 博客推送到github的工具\n\n```bash\n npm install hexo-deployer-git --save\n```\n\n6.配置静态博客仓库地址<br />找到hexo项目配置文件_config.yml，找到deploy属性，没有则新增，注意不能出现重复属性。\n\n```yaml\ndeploy: \n    type: git \n    repository: https://github.com/${username}/${username}.github.io.git  // username为github用户名，\n    branch: master //默认master，也可以自己指定\n```\n\n<a name=\"61771f08\"></a>\n## hexo常用命令\n\n```bash\nhexo init\n```\n新建一个网站。如果没有设置 `folder` ，Hexo 默认在目前的文件夹建立网站。\n\n```bash\nhexo new [layout] <title>\n```\n新建一篇文章。如果没有设置 `layout` 的话，默认使用 [_config.yml](https://hexo.io/zh-cn/docs/configuration) 中的 `default_layout` 参数代替。如果标        题包含空格的话，请使用引号括起来。\n\n```bash\nhexo generate\n```\n生成静态文件。\n\n```bash\nhexo server\n```\n启动服务器。默认情况下，访问网址为： `http://localhost:4000/`。\n\n```bash\nhexo clean\n```\n清除缓存文件 (`db.json`) 和已生成的静态文件 (`public`)。<br />在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。\n\n```bash\nhexo deploy\n```\n部署网站（简而言之，就是把生成的网页，推送到你设置的github仓库地址）<br />**以上仅列出我经常用到的一些命令，更多命令及配置请移步**[**hexo中文文档**](https://hexo.io/zh-cn/docs/commands)**。**<br />下篇，mark一下语雀+hexo的协作，毕竟markdown，不如所见即所得的富文本编辑器好用，而且分类管理起来，语雀确实要方便些。\n\n",
    "body_draft": "",
    "body_html": "<h2 id=\"3f38a0ec\">相关工具</h2><ul><li>node （安装）</li><li>ruby （安装）</li><li>hexo （<span>node package</span>）</li><li>github （githubpages 配置）</li><li><span class=\"lake-fontsize-11\">hexo-deployer-git（node package）</span></li></ul><h2 id=\"88210852\">准备工作</h2><p>1.安装<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\">node</a></p><p>2.安装<a href=\"https://rubyinstaller.org/\" target=\"_blank\">ruby</a></p><p>3.安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\">hexo</a>命令行工具</p><p><br /></p><pre data-lang=\"bash\"><code>npm install -g hexo-cli</code></pre><p><br /></p><p>4.<a href=\"https://pages.github.com/\" target=\"_blank\">githubpage</a>配置</p><p><br /><img alt=\"image.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/273716/1551274000249-20d4c46d-9084-4a10-aa59-c43835840ca9.png#align=left&amp;display=inline&amp;height=423&amp;name=image.png&amp;originHeight=423&amp;originWidth=952&amp;size=55903&amp;status=done&amp;width=952\" style=\"max-width: 600px; width: 952px;\" /></p><p>“User or organization site”是生成username.github.io的域名静态博客（推荐这一种，逼格更高）</p><p>“Project site”是生成github.io/projectname的静态博客</p><p>其他的配置就参照githubpage的教程，就两三步。</p><p><br /></p><p>5.安装<span>hexo-deployer-git 博客推送到github的工具</span></p><p><br /></p><pre data-lang=\"bash\"><code> npm install hexo-deployer-git --save</code></pre><p><br /></p><p>6.配置静态博客仓库地址</p><p style=\"text-indent: 2em;\">找到hexo项目配置文件<span style=\"background-color: #E9E9E9;\">_config.yml，</span>找到deploy属性，没有则新增，注意不能出现重复属性。</p><p><br /></p><pre data-lang=\"yaml\"><code>deploy: \n    type: git \n    repository: https://github.com/${username}/${username}.github.io.git  // username为github用户名，\n    branch: master //默认master，也可以自己指定</code></pre><p><br /></p><h2 id=\"61771f08\">hexo常用命令</h2><p><br /></p><pre data-lang=\"bash\"><code>hexo init</code></pre><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">新建一个网站。如果没有设置 </span><code>folder</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> ，Hexo 默认在目前的文件夹建立网站。</span></p><p><br /></p><pre data-lang=\"bash\"><code>hexo new [layout] &lt;title&gt;</code></pre><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">新建一篇文章。如果没有设置 </span><code>layout</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> 的话，默认使用 </span><a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\">_config.yml</a><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> 中的 </span><code>default_layout</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> 参数代替。如果标        题包含空格的话，请使用引号括起来。</span></p><p><br /></p><pre data-lang=\"bash\"><code>hexo generate</code></pre><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">生成静态文件。</span></p><p><br /></p><pre data-lang=\"bash\"><code>hexo server</code></pre><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">启动服务器。默认情况下，访问网址为： </span><code>http://localhost:4000/</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\">。</span></p><p><br /></p><pre data-lang=\"bash\"><code>hexo clean</code></pre><p style=\"text-indent: 2em;\">清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p style=\"text-indent: 2em;\">在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p><br /></p><pre data-lang=\"bash\"><code>hexo deploy</code></pre><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">部署网站（简而言之，就是把生成的网页，推送到你设置的github仓库地址）</span></p><p><strong>以上仅列出我经常用到的一些命令，更多命令及配置请移步</strong><a href=\"https://hexo.io/zh-cn/docs/commands\" target=\"_blank\"><strong>hexo中文文档</strong></a><strong>。</strong></p><p>下篇，mark一下语雀+hexo的协作，毕竟markdown，不如所见即所得的富文本编辑器好用，而且分类管理起来，语雀确实要方便些。</p><p><br /></p>",
    "body_lake": "<!doctype lake><h2 id=\"3f38a0ec\">相关工具</h2><ul><li>node （安装）</li><li>ruby （安装）</li><li>hexo （<span>node package</span>）</li><li>github （githubpages 配置）</li><li><span class=\"lake-fontsize-11\">hexo-deployer-git（node package）</span></li></ul><h2 id=\"88210852\">准备工作</h2><p>1.安装<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\">node</a></p><p>2.安装<a href=\"https://rubyinstaller.org/\" target=\"_blank\">ruby</a></p><p>3.安装<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\">hexo</a>命令行工具</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22npm%20install%20-g%20hexo-cli%22%7D\"></card><p><br /></p><p>4.<a href=\"https://pages.github.com/\" target=\"_blank\">githubpage</a>配置</p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F273716%2F1551274000249-20d4c46d-9084-4a10-aa59-c43835840ca9.png%22%2C%22originWidth%22%3A952%2C%22originHeight%22%3A423%2C%22name%22%3A%22image.png%22%2C%22size%22%3A55903%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A952%2C%22height%22%3A423%7D\"></card></p><p>“User or organization site”是生成username.github.io的域名静态博客（推荐这一种，逼格更高）</p><p>“Project site”是生成github.io/projectname的静态博客</p><p>其他的配置就参照githubpage的教程，就两三步。</p><p><br /></p><p>5.安装<span>hexo-deployer-git 博客推送到github的工具</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22%20npm%20install%20hexo-deployer-git%20--save%22%7D\"></card><p><br /></p><p>6.配置静态博客仓库地址</p><p style=\"text-indent: 2em;\">找到hexo项目配置文件<span style=\"background-color: #E9E9E9;\">_config.yml，</span>找到deploy属性，没有则新增，注意不能出现重复属性。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22yaml%22%2C%22code%22%3A%22deploy%3A%20%5Cn%20%20%20%20type%3A%20git%20%5Cn%20%20%20%20repository%3A%20https%3A%2F%2Fgithub.com%2F%24%7Busername%7D%2F%24%7Busername%7D.github.io.git%20%20%2F%2F%20username%E4%B8%BAgithub%E7%94%A8%E6%88%B7%E5%90%8D%EF%BC%8C%5Cn%20%20%20%20branch%3A%20master%20%2F%2F%E9%BB%98%E8%AE%A4master%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E6%8C%87%E5%AE%9A%22%7D\"></card><p><br /></p><h2 id=\"61771f08\">hexo常用命令</h2><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22hexo%20init%22%7D\"></card><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">新建一个网站。如果没有设置 </span><code>folder</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> ，Hexo 默认在目前的文件夹建立网站。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22hexo%20new%20%5Blayout%5D%20%3Ctitle%3E%22%7D\"></card><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">新建一篇文章。如果没有设置 </span><code>layout</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> 的话，默认使用 </span><a href=\"https://hexo.io/zh-cn/docs/configuration\" target=\"_blank\">_config.yml</a><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> 中的 </span><code>default_layout</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\"> 参数代替。如果标        题包含空格的话，请使用引号括起来。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22hexo%20generate%22%7D\"></card><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">生成静态文件。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22hexo%20server%22%7D\"></card><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">启动服务器。默认情况下，访问网址为： </span><code>http://localhost:4000/</code><span class=\"lake-fontsize-11\" style=\"color: #444444;\">。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22hexo%20clean%22%7D\"></card><p style=\"text-indent: 2em;\">清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p><p style=\"text-indent: 2em;\">在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22bash%22%2C%22code%22%3A%22hexo%20deploy%22%7D\"></card><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\" style=\"color: #444444;\">部署网站（简而言之，就是把生成的网页，推送到你设置的github仓库地址）</span></p><p><strong>以上仅列出我经常用到的一些命令，更多命令及配置请移步</strong><a href=\"https://hexo.io/zh-cn/docs/commands\" target=\"_blank\"><strong>hexo中文文档</strong></a><strong>。</strong></p><p>下篇，mark一下语雀+hexo的协作，毕竟markdown，不如所见即所得的富文本编辑器好用，而且分类管理起来，语雀确实要方便些。<cursor /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 1,
    "content_updated_at": "2019-03-03T08:56:36.000Z",
    "deleted_at": null,
    "created_at": "2019-02-26T13:37:15.000Z",
    "updated_at": "2019-03-03T08:56:36.000Z",
    "published_at": "2019-03-03T08:56:36.000Z",
    "first_published_at": "2019-02-27T13:43:02.000Z",
    "word_count": 485,
    "cover": null,
    "description": "相关工具node （安装）ruby （安装）hexo （node package）github （githubpages 配置）hexo-deployer-git（node package）准备工作1.安装node2.安装ruby3.安装hexo命令行工具npm install -g hexo...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1287538,
    "slug": "start",
    "title": "博客记",
    "book_id": 223480,
    "book": {
      "id": 223480,
      "type": "Book",
      "slug": "lch",
      "name": "Lite Code House",
      "user_id": 273716,
      "description": "share mark",
      "creator_id": 273716,
      "public": 1,
      "items_count": 6,
      "likes_count": 0,
      "watches_count": 1,
      "content_updated_at": "2019-03-05T14:56:11.170Z",
      "updated_at": "2019-03-05T14:56:11.000Z",
      "created_at": "2019-02-23T14:05:16.000Z",
      "namespace": "maclejean/lch",
      "user": {
        "id": 273716,
        "type": "User",
        "login": "maclejean",
        "name": "张杰",
        "description": null,
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 1,
        "following_count": 0,
        "created_at": "2019-02-23T08:29:39.000Z",
        "updated_at": "2019-02-26T02:38:41.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 273716,
    "creator": {
      "id": 273716,
      "type": "User",
      "login": "maclejean",
      "name": "张杰",
      "description": null,
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/jpeg/anonymous/1550910561567-1954fd8e-f8ed-4762-879d-b6b3cffdffcd.jpeg?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 1,
      "following_count": 0,
      "created_at": "2019-02-23T08:29:39.000Z",
      "updated_at": "2019-02-26T02:38:41.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "最近终于把博客写起来了，本来准备随便找个类似于CDSN之类的博客网站，写一下流水账之类的，后来看到了githubpages这个产品，很对胃口。然后就一步步地搭建静态博客，用到了hexo，yuque，travis之类的开源技术，真的是感谢互联网，感谢开源，我要汲取，也要奉献。\n> 一千个读者就有一千个哈姆雷特\n\n虽说我们一直在使用别人的工具，所碰到的问题也千篇一律，但若找到极其类似的场景，也能更快地解决问题。<br />我虽然知道我所做的工作是大部分人都做过的，所遇到的所有bug都是别人碰到过的，但是检索查到比较匹配的解决方式或者启发，有的时候还是很困难的，当然，也有很多时候发现是自己比较粗心导致的。<br />今天就到这，瞎写测试一下，看整个流程是否通畅。<br />下一篇就好好写一下这整个搭建过程吧。<br />当然，是针对有一定前端及构建基础的人的。\n\n\n\n\n\n",
    "body_draft": "",
    "body_html": "<p style=\"text-indent: 2em;\">最近终于把博客写起来了，本来准备随便找个类似于CDSN之类的博客网站，写一下流水账之类的，后来看到了githubpages这个产品，很对胃口。然后就一步步地搭建静态博客，用到了hexo，yuque，travis之类的开源技术，真的是感谢互联网，感谢开源，我要汲取，也要奉献。</p><blockquote><p>一千个读者就有一千个哈姆雷特</p></blockquote><p style=\"text-indent: 2em;\">虽说我们一直在使用别人的工具，所碰到的问题也千篇一律，但若找到极其类似的场景，也能更快地解决问题。</p><p style=\"text-indent: 2em;\">我虽然知道我所做的工作是大部分人都做过的，所遇到的所有bug都是别人碰到过的，但是检索查到比较匹配的解决方式或者启发，有的时候还是很困难的，当然，也有很多时候发现是自己比较粗心导致的。</p><p style=\"text-indent: 2em;\">今天就到这，瞎写测试一下，看整个流程是否通畅。</p><p style=\"text-indent: 2em;\">下一篇就好好写一下这整个搭建过程吧。</p><p style=\"text-indent: 2em;\">当然，是针对有一定前端及构建基础的人的。</p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p style=\"text-indent: 2em;\">最近终于把博客写起来了，本来准备随便找个类似于CDSN之类的博客网站，写一下流水账之类的，后来看到了githubpages这个产品，很对胃口。然后就一步步地搭建静态博客，用到了hexo，yuque，travis之类的开源技术，真的是感谢互联网，感谢开源，我要汲取，也要奉献。</p><blockquote><p>一千个读者就有一千个哈姆雷特</p></blockquote><p style=\"text-indent: 2em;\">虽说我们一直在使用别人的工具，所碰到的问题也千篇一律，但若找到极其类似的场景，也能更快地解决问题。</p><p style=\"text-indent: 2em;\">我虽然知道我所做的工作是大部分人都做过的，所遇到的所有bug都是别人碰到过的，但是检索查到比较匹配的解决方式或者启发，有的时候还是很困难的，当然，也有很多时候发现是自己比较粗心导致的。</p><p style=\"text-indent: 2em;\">今天就到这，瞎写测试一下，看整个流程是否通畅。</p><p style=\"text-indent: 2em;\">下一篇就好好写一下这整个搭建过程吧。</p><p style=\"text-indent: 2em;\">当然，是针对有一定前端及构建基础的人的。<cursor /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-02-27T13:10:07.000Z",
    "deleted_at": null,
    "created_at": "2019-02-23T14:54:07.000Z",
    "updated_at": "2019-02-27T13:10:07.000Z",
    "published_at": "2019-02-27T13:10:07.000Z",
    "first_published_at": "2019-02-23T14:54:49.000Z",
    "word_count": 297,
    "cover": "",
    "description": "最近终于把博客写起来了，本来准备随便找个类似于CDSN之类的博客网站，写一下流水账之类的，后来看到了githubpages这个产品，很对胃口。然后就一步步地搭建静态博客，用到了hexo，yuque，travis之类的开源技术，真的是感谢互联网，感谢开源，我要汲取，也要奉献。一千个读者就有一千个...",
    "custom_description": "博客记序章",
    "_serializer": "v2.doc_detail"
  }
]